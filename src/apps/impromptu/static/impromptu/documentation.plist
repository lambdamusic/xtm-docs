<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>*</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>numbers</key>
			<string>n numbers to be multiplied</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(* 2 2 2) =&gt; 8</string>
			<string>(* 2 2)   =&gt; 4</string>
			<string>(* 2)     =&gt; 2</string>
			<string>(*)       =&gt; 0</string>
		</array>
		<key>long</key>
		<array>
			<string>The product of all numbers</string>
		</array>
		<key>returns</key>
		<string>The product of all numbers</string>
		<key>short</key>
		<string>(* . numbers)</string>
	</dict>
	<key>+</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>numbers</key>
			<string>n numbers to be summed</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(+ 2 2 2) =&gt; 6</string>
			<string>(+ 2 2)   =&gt; 4</string>
			<string>(+ 2)     =&gt; 2</string>
			<string>(+)       =&gt; 0</string>
		</array>
		<key>long</key>
		<array>
			<string>The sum of all numbers</string>
		</array>
		<key>returns</key>
		<string>The sum of all numbers</string>
		<key>short</key>
		<string>(+ . numbers)</string>
	</dict>
	<key>-</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>number</key>
			<string>A real or integer atom</string>
			<key>numbers</key>
			<string>Any additional numbers</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(- 3 4 5) =&gt; -6</string>
			<string>(- 3 4)   =&gt; -1</string>
			<string>(- 3)     =&gt; -3</string>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>The difference of number and numbers</string>
		</array>
		<key>returns</key>
		<string>The difference of number and numbers</string>
		<key>short</key>
		<string>(- number . numbers)</string>
	</dict>
	<key>/</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>number</key>
			<string>A real or integer atom</string>
			<key>numbers</key>
			<string>Any additional integer or real numbers</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(/ 2 4 2) =&gt; 0.25</string>
			<string>(/ 4 2)   =&gt; 2</string>
			<string>(/ 2)     =&gt; 0.5</string>
		</array>
		<key>long</key>
		<array>
			<string>The quotient of number and numbers</string>
		</array>
		<key>returns</key>
		<string>The quotient of number and numbers</string>
		<key>short</key>
		<string>(/ number . numbers)</string>
	</dict>
	<key>&lt;</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>n1</key>
			<string>Any integer or real valued atom</string>
			<key>n2</key>
			<string>Any integer or real valued atom</string>
			<key>numbers</key>
			<string>Any additional integer or real values</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(&lt; 1 2 3 4) =&gt; #t</string>
			<string>(&lt; 2 1)     =&gt; #f</string>
		</array>
		<key>long</key>
		<array>
			<string>Predicate testing exactness of numeric
	  quantites. Returns #t if arguments continue to increase in
	  quantity.</string>
		</array>
		<key>returns</key>
		<string>Returns #t if arguments continue to increase in
	quantity.</string>
		<key>short</key>
		<string>(&lt; n1 n2 . numbers)</string>
	</dict>
	<key>&lt;=</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>n1</key>
			<string>Any integer or real valued atom</string>
			<key>n2</key>
			<string>Any integer or real valued atom</string>
			<key>numbers</key>
			<string>Any additional integer or real values</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(&lt;= 1 1 2 2 3 3) =&gt; #t</string>
			<string>(&lt;= 1 1 2 2 1 1) =&gt; #f</string>
		</array>
		<key>long</key>
		<array>
			<string>Predicate testing exactness of numeric
	  quantites. Returns #t if arguments continue to increase or
	  equal in quantity.</string>
		</array>
		<key>returns</key>
		<string>Returns #t if arguments continue to increase or equal
	in quantity</string>
		<key>short</key>
		<string>(&lt;= n1 n2 . numbers)</string>
	</dict>
	<key>&lt;&gt;</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For &lt;&gt;</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(&lt;&gt;)</string>
	</dict>
	<key>=</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>n1</key>
			<string>Any integer or real valued atom</string>
			<key>n2</key>
			<string>Any integer or real valued atom</string>
			<key>numbers</key>
			<string>Any additional integer or real values</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(= 1.1 1.1 1.1 1.1) =&gt; #t</string>
			<string>(= 2.1 1.2)         =&gt; #f</string>
		</array>
		<key>long</key>
		<array>
			<string>Predicate testing exactness of numeric
	  quantites. Returns #t if arguments continue to equal in
	  quantity.</string>
		</array>
		<key>returns</key>
		<string>Returns #t if arguments continue to equal in
	  quantity.</string>
		<key>short</key>
		<string>(= n1 n2 . numbers)</string>
	</dict>
	<key>&gt;</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>n1</key>
			<string>Any integer or real valued atom</string>
			<key>n2</key>
			<string>Any integer or real valued atom</string>
			<key>numbers</key>
			<string>Any additional integer or real values</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(&gt; 3 2 1) =&gt; #t)</string>
			<string>(&gt; 1 2)   =&gt; #f)</string>
		</array>
		<key>long</key>
		<array>
			<string>Predicate testing exactness of numeric
	  quantites. Returns #t if arguments continue to decrease in
	  quantity.</string>
		</array>
		<key>returns</key>
		<string>Returns #t if arguments continue to decrease in
	quantity.</string>
		<key>short</key>
		<string>(&gt; n1 n2 . numbers)</string>
	</dict>
	<key>&gt;=</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>n1</key>
			<string>Any integer or real valued atom</string>
			<key>n2</key>
			<string>Any integer or real valued atom</string>
			<key>numbers</key>
			<string>Any additional integer or real values</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(&gt;= 3 3 2 2 1 1) =&gt; #t</string>
			<string>(&gt;= 3 3 2 2 3 3) =&gt; #f</string>
		</array>
		<key>long</key>
		<array>
			<string>Predicate testing exactness of numeric
	  quantites. Returns #t if arguments continue to decrease or
	  equal in quantity.</string>
		</array>
		<key>returns</key>
		<string>Returns #t if arguments continue to decrease or equal
	in quantity.</string>
		<key>short</key>
		<string>(&gt;= n1 n2 . numbers)</string>
	</dict>
	<key>abs</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>n1</key>
			<string>Any integer or real valued atom</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(abs -5)   =&gt; 5</string>
			<string>(abs -5.5) =&gt; 5.5</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns the absolute value of n1</string>
		</array>
		<key>returns</key>
		<string>Returns the absolute value of n1</string>
		<key>short</key>
		<string>(abs n1)</string>
	</dict>
	<key>acons</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>al</key>
			<string>Associative List</string>
			<key>o1</key>
			<string>Scheme object</string>
			<key>o2</key>
			<string>Scheme object</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(acons 10 &quot;ten&quot; &apos;((5 . &quot;five&quot;) (6 . &quot;six&quot;)))</string>
			<string>=&gt; ((10 . &quot;ten&quot;) (5 . &quot;five&quot;) (6 . &quot;six&quot;))</string>
		</array>
		<key>long</key>
		<array>
			<string>The cons of the pair (o1 . o2) to the associative
	  list al</string>
		</array>
		<key>returns</key>
		<string>A new associative list including the pair (o1 . o2)</string>
		<key>short</key>
		<string>(acons o1 o2 al)</string>
	</dict>
	<key>acos</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>n1</key>
			<string>A real value</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(acos 0.5) =&gt; 1.0472</string>
		</array>
		<key>long</key>
		<array>
			<string>The trigonometric arccosine funtion.</string>
		</array>
		<key>returns</key>
		<string>The result of applying n1 to the trigonetric function
	arccosine</string>
		<key>short</key>
		<string>(acos n1)</string>
	</dict>
	<key>and</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array>
			<string>(and (= 2 2) (&gt; 2 1)) =&gt;  #t</string>
			<string>(and (= 2 2) (&lt; 2 1)) =&gt;  #f</string>
			<string>(and 1 2 &apos;c &apos;(f g))   =&gt;  (f g)</string>
			<string>(and)                 =&gt;  #t</string>
		</array>
		<key>long</key>
		<array>
			<string>The &lt;test&gt; expressions are evaluated from left
	  to right, and the value of the first expression that
	  evaluates to a false value is returned.  Any remaining
	  expressions are not evaluated.  If all the expressions
	  evaluate to true values, the value of the last expression is
	  returned.  If there are no expressions then #t is
	  returned.</string>
		</array>
		<key>returns</key>
		<string>If all the expressions evaluate to true values, the
	value of the last expression is returned.  If there are no
	expressions then #t is returned.</string>
		<key>short</key>
		<string>(and &lt;test1&gt; ...)</string>
	</dict>
	<key>anyatom-&gt;string</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For anyatom-&gt;string</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(anyatom-&gt;string)</string>
	</dict>
	<key>append</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>args</key>
			<string>any number of lists</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(append &apos;(a b c) &apos;(d e f) &apos;(h i j))</string>
			<string>=&gt; (a b c e f g h i j)</string>
			<string>(append &apos;(a b c))</string>
			<string>=&gt; ((a b c))</string>
			<string>(append)</string>
			<string>=&gt; NIL</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns a list consisting of the elements of the
	  first list followed by the elements of the other
	  lists.</string>
		</array>
		<key>returns</key>
		<string>a new list consisting of elements of all lists</string>
		<key>short</key>
		<string>(append lst . args)</string>
	</dict>
	<key>apply</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>arg1 ...</key>
			<string>any scheme objects to pass as arguments</string>
			<key>args</key>
			<string>a list of scheme objects to pass as arguments</string>
			<key>proc</key>
			<string>the procedure to call</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(apply + (list 3 4)) =&gt; 7</string>
		</array>
		<key>long</key>
		<array>
			<string>Proc must be a procedure and list-of-args must be a list.
	  Calls proc with the elements of the list (append (list arg1
	  ...) args) as the actual arguments.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(apply proc arg1 ... list-of-args)</string>
	</dict>
	<key>asin</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>n1</key>
			<string>a real value</string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>The trigonometric funtion arcsine.</string>
		</array>
		<key>returns</key>
		<string>number</string>
		<key>short</key>
		<string>(asin n1)</string>
	</dict>
	<key>assoc</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>alst</key>
			<string>an associative list</string>
			<key>obj</key>
			<string>a scheme object</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(assoc 4 &apos;((4 . &quot;four&quot;) (5 . &quot;five&quot;))) =&gt; (4 . &quot;four&quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>Finds the pair who&apos;s car is equal? to obj.</string>
		</array>
		<key>related</key>
		<string>assq assv acons</string>
		<key>returns</key>
		<string>the pair who&apos;s car is equal? to obj or #f.</string>
		<key>short</key>
		<string>(assoc obj alst)</string>
	</dict>
	<key>assocdel</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>al</key>
			<string>an associated list</string>
			<key>o</key>
			<string>any scheme object</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(assocdel &apos;a &apos;((a . b) (c . d))) =&gt; ((c . d))</string>
		</array>
		<key>long</key>
		<array>
			<string>Deletes pair who&apos;s car is obj from alst.  Matches using equal?</string>
		</array>
		<key>returns</key>
		<string>associated list with pair who&apos;s car is o removed</string>
		<key>short</key>
		<string>(assocdel obj alst)</string>
	</dict>
	<key>assq</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>alst</key>
			<string>the associative list to search</string>
			<key>obj</key>
			<string>a scheme object to search for</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(assq 4 &apos;((4 . &quot;four&quot;) (5 . &quot;five&quot;))) =&gt; #f</string>
			<string></string>
			<string>(define a 4)</string>
			<string>(assq a `((,a . &quot;four&quot;) (5 . &quot;five&quot;))) =&gt; (4 . &quot;four&quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>Finds the pair who&apos;s car is eq? to obj.</string>
		</array>
		<key>related</key>
		<string>assoc assv acons</string>
		<key>returns</key>
		<string>the pair who&apos;s car is eq? to obj or #f</string>
		<key>short</key>
		<string>(assq obj alst)</string>
	</dict>
	<key>assqdel</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>al</key>
			<string>an associated list</string>
			<key>o</key>
			<string>any scheme object</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(assqdel &apos;a &apos;((a . b) (c . d))) =&gt; ((c . d))</string>
		</array>
		<key>long</key>
		<array>
			<string>Deletes pair who&apos;s car is obj from alst.  Matches using eq?</string>
		</array>
		<key>returns</key>
		<string>associated list with pair who&apos;s car is o removed</string>
		<key>short</key>
		<string>(assqdel obj alst)</string>
	</dict>
	<key>assv</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>alst</key>
			<string>the associative list to search</string>
			<key>obj</key>
			<string>a scheme object to search for</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(assv 4 &apos;((4 . &quot;four&quot;) (5 . &quot;five&quot;))) =&gt; (4 . &quot;four&quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>Finds the pair who&apos;s car is eqv? to obj.</string>
		</array>
		<key>related</key>
		<string>assoc assq acons</string>
		<key>returns</key>
		<string>the pair who&apos;s car is eqv? to obj or #f</string>
		<key>short</key>
		<string>(assv obj alst)</string>
	</dict>
	<key>assvdel</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>al</key>
			<string>an associated list</string>
			<key>o</key>
			<string>any scheme object</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(assvdel &apos;a &apos;((a . b) (c . d))) =&gt; ((c . d))</string>
		</array>
		<key>long</key>
		<array>
			<string>Deletes pair who&apos;s car is obj from alst.  Matches using eqv?</string>
		</array>
		<key>returns</key>
		<string>associated list with pair who&apos;s car is o removed</string>
		<key>short</key>
		<string>(assvdel obj alst)</string>
	</dict>
	<key>atan</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>n1</key>
			<string>a real value</string>
			<key>n2</key>
			<string>a real value</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(atan 1.0)
(atan 0.5 0.7)</string>
		</array>
		<key>long</key>
		<array>
			<string>The trignonetric function arctan</string>
		</array>
		<key>returns</key>
		<string>the arctan of n1 (optional n2)</string>
		<key>short</key>
		<string>(atan n1 [n2])</string>
	</dict>
	<key>atom-&gt;string</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>a1</key>
			<string>a scheme atom</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(atom-&gt;string #\c)    =&gt; &quot;c&quot;</string>
			<string>(atom-&gt;string 5)      =&gt; &quot;5&quot;</string>
			<string>(atom-&gt;string &apos;hello) =&gt; &quot;hello&quot;</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns any scheme atom as a string representation
	  of itself</string>
		</array>
		<key>returns</key>
		<string>a string represetation of a1</string>
		<key>short</key>
		<string>(atom-&gt;string a1)</string>
	</dict>
	<key>atom?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>is obj an atom?</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(atom? 5)    =&gt; #t</string>
			<string>(atom? &apos;(5)) =&gt; #f</string>
		</array>
		<key>long</key>
		<array>
			<string>A predicate to test the atomicity of obj</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(atom? obj)</string>
	</dict>
	<key>au:asys:get-fft-data</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>An AudioUnit of type &quot;aufx&quot; &quot;asys&quot; &quot;moso&quot;</string>
			<key>data</key>
			<string>Data should be an instance of NSMutableArray</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Fills a supplied NSMutableArray with fft magnitude data from analysis audiounit (&quot;aufx&quot; &quot;asys&quot; &quot;moso&quot;).  Data can then be passed to au:play:set-sample-data</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:asys:get-fft-data au data)</string>
	</dict>
	<key>au:asys:get-frequency-bins</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>An AudioUnit of type &quot;aufx&quot; &quot;asys&quot; &quot;moso&quot;</string>
			<key>data</key>
			<string>Data should be an instance of NSMutableArray</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns the frequencies of each bin in the current analysis au. You only need to call this once. It does not change</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:asys:get-frequency-data au data)</string>
	</dict>
	<key>au:bypassed</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>check to see if this au has been bypassed</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define dls (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))</string>
			<string>(define rev (au:make-node &quot;aufx&quot; &quot;mrev&quot; &quot;appl&quot;))</string>
			<string>(au:connect-node rev 0 *au:output-node* 0)</string>
			<string>(au:connect-node dls 0 rev 0)</string>
			<string>(au:update-graph)</string>
			<string></string>
			<string>(print (au:get-bypass rev))</string>
			<string>(play-note (now) dls 60 20 1000000)</string>
			<string>(au:set-bypass (now) rev #t)</string>
		</array>
		<key>long</key>
		<array>
			<string>Predicate checking to see if au has been bypassed in the audio unit graph</string>
		</array>
		<key>related</key>
		<string>au:set-bypass</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:bypassed? au)</string>
	</dict>
	<key>au:clear-graph</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array>
			<string>(au:clear-graph)</string>
		</array>
		<key>long</key>
		<array>
			<string>clear any connections in the running audiounit graph
	  and deinitialize any initialized audiounits effectively
	  resetting the graph to it&apos;s initial state.</string>
		</array>
		<key>related</key>
		<string>au:update-graph au:print-graph au:connect-node au:make-node</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:clear-graph)</string>
	</dict>
	<key>au:code:load</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>audiounit</string>
			<key>data</key>
			<string>an optional nsdata object of doubles which will be passed to function</string>
			<key>function</key>
			<string>scheme function that must accept 4 arguments sample (incoming sample) time (time in samples) channel (incoming channel number) data (including data)</string>
			<key>name</key>
			<string>a string name which must be provided if function is a lambda or list expression (does not need to be provided if a closure or precompiled foreign function)</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define aucode1 (au:make-node &quot;aumf&quot; &quot;code&quot; &quot;MOSO&quot;))
(define aucode2 (au:make-node &quot;aumf&quot; &quot;code&quot; &quot;MOSO&quot;))
(define aucode3 (au:make-node &quot;aumf&quot; &quot;code&quot; &quot;MOSO&quot;))
(define mix (au:make-node &quot;aumx&quot; &quot;smxr&quot; &quot;appl&quot;))
(au:connect-node aucode1 0 aucode3 0)
(au:connect-node aucode3 0 mix 0)
(au:connect-node aucode2 0 mix 1)
(au:connect-node aucode3 0 mix 1)          
(au:connect-node mix 0 *au:output-node* 0)
(au:update-graph)

;; simplest of the simple - whitenoise
(au:code:load aucode1 &quot;dsp&quot; (lambda (sample time channel data)
                               (* 0.1 (random))))


;; sinewave with phase information maintained
(define sinewave
   (lambda (sample time channel data)
      (let ((phase (objc:data:get-double data channel))
            (freq (objc:data:get-double data 2))
            (inc (* 2.0 3.141592 (/ freq 44100))))
         (objc:data:set-double data channel (+ inc phase))
         (* 0.3 (sin (+ inc phase))))))

;; create a data object to share with aucode1
(define dat (objc:data:make (* 8 3)))
;; set frequency in dat[2] save dat[0] and dat[1] for left and right phase
(objc:data:set-double dat 2 220.0)
;; load sinewave with dat into aucode1
(au:code:load aucode1 sinewave dat)

;; define simple fm
(define fm
   (lambda (sample time channel data)
      (let ((carrier-freq (objc:data:get-double data 4))
            (mod-freq (objc:data:get-double data 5))
            (carrier-phase (objc:data:get-double data (+ channel 0)))
            (mod-phase (objc:data:get-double data (+ channel 2)))
            (mod-width (objc:data:get-double data 6))
            (carrier-inc 0)            
            (mod-inc 0))
         (set! mod-inc (sin (* 3.141592 2 (/ mod-freq 44100))))  
         (set! carrier-inc (sin (* 3.141592 2 (/ carrier-freq 44100))))                            
         (objc:data:set-double data (+ channel 0) (+ carrier-inc carrier-phase))
         (objc:data:set-double data (+ channel 2) (+ mod-inc mod-phase)) 
         (* .5 (cos (+ carrier-phase carrier-inc (* mod-width (cos (+ mod-phase mod-inc)))))))))

;; create a data object to share with aucode1
(define dat2 (objc:data:make (* 8 7)))
;; set frequency in dat[4] save dat[0-3] for phase information 
(objc:data:set-double dat2 4 180.0)
(objc:data:set-double dat2 5 (* 180 2.5))
(objc:data:set-double dat2 6 0.5)
;; load sinewave with dat into aucode1
(au:code:load aucode2 fm dat2)

;; play frequencies - carrier with mod ratio
(define loop1
   (lambda (beat) 
      (let ((freq (random 60 480)))
         (objc:data:set-double dat2 4 freq)
         (objc:data:set-double dat2 5 (* 2.5 freq))
         (callback (*metro* (+ beat (* .98 8))) &apos;loop1 (+ beat 8)))))

(loop1 (*metro* &apos;get-beat 4))


;; and loop 2 fast for mod-width
(define loop2
   (lambda (beat) 
      (objc:data:set-double dat2 6 (cosr 0.5 0.4 1/8))      
      (callback (*metro* (+ beat (* .5 1/32))) &apos;loop2 (+ beat 1/32))))

(loop2 (*metro* &apos;get-beat 4))


;; An example which operates as an effect
;; rather than a generator (i.e. effects an incoming signal)
;;
;; A simple low-pass filter
;;
;; first go back and redefine the original noise signal for aucode1
;;
;; there are aliases for setting and getting data objects
;; float 64 bit set = f64s = objc:data:set-double
;; float 64 bit get = f64g = objc:data:get-double

(define filter
   (lambda (sample time channel data)
      (let ((frequency (f64g data 0))
            (p0 (f64g data 1))
            (p1 (f64g data 2)))
         (set! p0 (+ p0 (* frequency (- sample p0))))
         (set! p1 (+ p1 (* frequency (- p0 p1))))
         (f64s data 1 p0)
         (f64s data 2 p1)  
         p1)))

(define filter-dat (objc:data:make (* 8 3)))
;; don&apos;t push frequency higher than 1.0
(objc:data:set-double filter-dat 0 0.5)

(au:code:load aucode3 &quot;filter&quot; filter filter-dat)

;; filter frequency sweep
(define loop3
   (lambda (beat) 
      (objc:data:set-double filter-dat 0 (cosr .5 .4 1/12))
      (callback (*metro* (+ beat (* .5 1/32))) &apos;loop3 (+ beat 1/32))))

(loop3 (*metro* &apos;get-beat 4))</string>
		</array>
		<key>long</key>
		<array>
			<string>au:code:load compiles a scheme function into machine code and then loads that code into an audiounit of type &quot;aumf&quot; &quot;code&quot; &quot;MOSO&quot;.  The scheme function accepted by au:code:load must accept 4 arguments and cannot use any global values (i.e. it can only use symbols defined within the function or the 4 incoming arguments.  sample - which is the incoming sample, time - in samples, channel - the incomding channel number and data - an nsdata object which can be passed in when loading the function.  All arguments are doubles and the return value of the function is the sample to send to the following audiounit.</string>
		</array>
		<key>related</key>
		<string>sys:compile</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:code:load au [name] function [nsdata])</string>
	</dict>
	<key>au:connect-node</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au1</key>
			<string>the audiounit sending the audio signal</string>
			<key>au1-output-bus</key>
			<string>the output-bus to send the audio signal on</string>
			<key>au2</key>
			<string>the audiounit receiving the audio signal</string>
			<key>au2-input-bus</key>
			<string>the input-bus to receive the audio signal on</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define instrument (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))</string>
			<string>(define reverb (au:make-node &quot;aufx&quot; &quot;mrev&quot; &quot;appl&quot;))</string>
			<string>(define mixer (au:make-node &quot;aumx&quot; &quot;smxr&quot; &quot;appl&quot;))</string>
			<string>(au:connect-node instrument 0 reverb 0)</string>
			<string>; connect reverb to mixer input bus 5</string>
			<string>(au:connect-node reverb 0 mixer 5)</string>
			<string>(au:connect-node mixer 0 *au:output-node* 0)</string>
			<string>(au:update-graph)</string>
			<string>(au:print-graph)</string>
		</array>
		<key>long</key>
		<array>
			<string>connects one audiounit to another in series. The two
	  units are connected by connecting the output-bus of the
	  first audiounit to the input bus of the second
	  audiounit. busses are numbered starting from 0. audiounits
	  can be connected, disconnected, re-connected in real-time
	  only taking effect once au:update-graph is called</string>
		</array>
		<key>related</key>
		<string>au:update-graph au:clear-graph au:disconnect-node
	au:print-graph au:make-node au:print-graph</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:connect-node au1 au1-output-bus au2 au2-input-bus)</string>
	</dict>
	<key>au:disconnect-node</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au1</key>
			<string>audiounit who&apos;s input bus will be disconnected</string>
			<key>input-bus</key>
			<string>the bus to connect connections too</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define inst1 (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))</string>
			<string>(define inst2 (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))</string>
			<string>(define reverb (au:make-node &quot;aufx&quot; &quot;mrev&quot; &quot;appl&quot;))</string>
			<string>(define mixer (au:make-node &quot;aumx&quot; &quot;smxr&quot; &quot;appl&quot;))</string>
			<string>(au:connect-node inst1 0 reverb 0)</string>
			<string>(au:connect-node reverb 0 mixer 0)</string>
			<string>(au:connect-node inst2 0 mixer 1)</string>
			<string>(au:connect-node mixer 0 *au:output-node* 0)</string>
			<string>(au:update-graph)</string>
			<string>(play-note (now) inst2 72 80 *second*)</string>
			<string>; now add a reverb for inst2</string>
			<string>(au:disconnect-node mixer 1)</string>
			<string>(define reverb2 (au:make-node &quot;aufx&quot; &quot;mrev&quot; &quot;appl&quot;))</string>
			<string>(au:connect-node inst2 0 reverb2 0)</string>
			<string>(au:connect-node reverb2 0 mixer 1)</string>
			<string>(au:update-graph)</string>
			<string>(play-note (now) inst2 72 80 *second*)</string>
		</array>
		<key>long</key>
		<array>
			<string>disconnects an audiounit&apos;s input-bus from any
	  current connection. new connections can now be made to the
	  disconnected bus before a call to au:update-graph is
	  made.</string>
		</array>
		<key>related</key>
		<string>au:update-graph au:print-audiounits au:set-param
	au:print-params au:get-param au:clear-graph au:print-graph
	au:connect-node au:disconnect-node</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:disconnect-node au1 input-bus)</string>
	</dict>
	<key>au:get-audio-data-from-movie</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>dur</key>
			<string>duration of extraction (in seconds) (optional defaulting to whole file - start)</string>
			<key>movie</key>
			<string>a movie with audio as loaded by calling (gfx:load-movie)</string>
			<key>start</key>
			<string>start extracting audio from start (in seconds) (optional defaulting to start of file)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns audio data loaded from mov</string>
		</array>
		<key>returns</key>
		<string>audio data (NSArray)</string>
		<key>short</key>
		<string>(au:get-audio-data-from-movie movie [start] [duration])</string>
	</dict>
	<key>au:get-device-input-channels</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>returns the number of input channels for the device</string>
		</array>
		<key>returns</key>
		<string>integer</string>
		<key>short</key>
		<string>(au:get-device-input-channels)</string>
	</dict>
	<key>au:get-device-output-channels</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>returns the number of output channels for the device</string>
		</array>
		<key>returns</key>
		<string>integer</string>
		<key>short</key>
		<string>(au:get-device-output-channels)</string>
	</dict>
	<key>au:get-node-strings</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>type</key>
			<string>four char type code (i.e. &quot;aumu&quot; &quot;aufx&quot; etc.)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns a string containing all audiounits of type</string>
		</array>
		<key>related</key>
		<string>au:print-audiounits</string>
		<key>returns</key>
		<string>string of all audiounits of type</string>
		<key>short</key>
		<string>(au:get-node-strings type)</string>
	</dict>
	<key>au:get-node-vector</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>type</key>
			<string>four char type code (i.e. &quot;aumu&quot; &quot;aufx&quot; etc.)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns a vector containing all audiounits of type. each audiounit is also represented as a vector of 4 elements name,type,subtype,manu</string>
		</array>
		<key>related</key>
		<string>au:print-audiounits</string>
		<key>returns</key>
		<string>a vector containing audiounit info</string>
		<key>short</key>
		<string>(au:get-node-vector type)</string>
	</dict>
	<key>au:get-number-input-busses</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>audiounit</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns the number of input busses for the au</string>
		</array>
		<key>returns</key>
		<string>int</string>
		<key>short</key>
		<string>(au:get-number-input-busses au)</string>
	</dict>
	<key>au:get-number-output-busses</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>audiounit</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns the number of output busses for the au</string>
		</array>
		<key>returns</key>
		<string>int</string>
		<key>short</key>
		<string>(au:get-number-output-busses au)</string>
	</dict>
	<key>au:get-param</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>element</key>
			<string>the parameter&apos;s element index - (mixers have a
	  different element for each input bus for example).</string>
			<key>id</key>
			<string>the parameter&apos;s id - an integer index</string>
			<key>scope</key>
			<string>the parameter&apos;s scope (global=0 input=1 output=2 group=3)</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define inst1 (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))</string>
			<string>(define inst2 (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))</string>
			<string>(define reverb (au:make-node &quot;aufx&quot; &quot;mrev&quot; &quot;appl&quot;))</string>
			<string>(define mixer (au:make-node &quot;aumx&quot; &quot;smxr&quot; &quot;appl&quot;))</string>
			<string>(au:connect-node inst1 0 reverb 0)</string>
			<string>(au:connect-node reverb 0 mixer 0)</string>
			<string>(au:connect-node inst2 0 mixer 1)</string>
			<string>(au:connect-node mixer 0 *au:output-node* 0)</string>
			<string>(au:update-graph)</string>
			<string>; print mixer parameters</string>
			<string>(au:print-params mixer *au:global-scope*)</string>
			<string>; gain of mixer bus 1 - connected to inst1</string>
			<string>(print (au:get-param mixer 0 *au:input-scope* 0))</string>
			<string>; gain of mixer bus 2 - connected to inst2</string>
			<string>(print (au:get-param mixer 0 *au:input-scope* 1))</string>
		</array>
		<key>long</key>
		<array>
			<string>returns parameter id-scope-group from the given
	  audiounit</string>
		</array>
		<key>related</key>
		<string>au:set-param au:print-params au:midi-out</string>
		<key>returns</key>
		<string>the parameters value - always a real number</string>
		<key>short</key>
		<string>(au:get-param au id scope group)</string>
	</dict>
	<key>au:get-param-ids</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>audiounit to retrieve parameter name from</string>
			<key>scope</key>
			<string>the scope of the parameter</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(au:get-param-ids stereo-mixer *au:input-scope*) =&gt; #(0 1)</string>
		</array>
		<key>long</key>
		<array>
			<string>returns a vector of parameter id numbers for this au</string>
		</array>
		<key>returns</key>
		<string>the string name of the parameter</string>
		<key>short</key>
		<string>(au:get-param-ids au scope)</string>
	</dict>
	<key>au:get-param-info</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>audiounit to retrieve parameter name from</string>
			<key>id</key>
			<string>the parameter number</string>
			<key>scope</key>
			<string>the scope of the parameter</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(au:get-param-info reverb *au:global-scope* 0) =&gt; (&quot;default:dry/wet mix&quot; 0 100 100 &quot;kAudioUnitParameterUnit_EqualPowerCrossfade -  0 -&gt; 100, crossfade mix two sources according to sqrt(x) and sqrt(1.0 - x) &quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>returns a parameters information in a list the order of which is (name min-value max-value default-value parameter type)</string>
		</array>
		<key>returns</key>
		<string>the string name of the parameter</string>
		<key>short</key>
		<string>(au:get-param-info au scope id)</string>
	</dict>
	<key>au:get-property</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>audiounit</string>
			<key>cptr</key>
			<string>a void* pointer</string>
			<key>element</key>
			<string>element</string>
			<key>id</key>
			<string>property id</string>
			<key>scope</key>
			<string>scope (global, input etc..)</string>
			<key>size</key>
			<string>the size in bytes of cptr</string>
		</dict>
		<key>long</key>
		<array>
			<string>gets the property id and writes it to the supplied cptr (which must be of the correct size!!!.  You can find out how large cptr should be by calling au:get-property-info).  You can make a cptr by using NSMutableData</string>
		</array>
		<key>related</key>
		<string>au:get-property-info</string>
		<key>returns</key>
		<string>number</string>
		<key>short</key>
		<string>(au:get-property au id scope element cptr size)</string>
		<key>the number of bytes written to cptr</key>
		<array/>
	</dict>
	<key>au:get-property-info</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>audiounit</string>
			<key>element</key>
			<string>element</string>
			<key>id</key>
			<string>property id</string>
			<key>scope</key>
			<string>scope (global, input etc..)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Check the size of the data for property id</string>
		</array>
		<key>related</key>
		<string>au:get-property</string>
		<key>returns</key>
		<string>number</string>
		<key>short</key>
		<string>(au:get-property-info au id scope element)</string>
	</dict>
	<key>au:get-sample-markers</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>sample-data</key>
			<string>An object containing audio data.  Usually audio data will be from calling au:load-audio-data</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns the number of markers in the given sample data.  Usually sample data will come from calling au:load-audio-data</string>
		</array>
		<key>returns</key>
		<string>NSArray of sample markers</string>
		<key>short</key>
		<string>(au:get-sample-markers sample-data)</string>
	</dict>
	<key>au:get-speech-channel</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array>
			<string>(define speech1 (au:get-speech-channel))</string>
		</array>
		<key>long</key>
		<array>
			<string>Opens and returns a new speech channel</string>
		</array>
		<key>returns</key>
		<string>speech channel</string>
		<key>short</key>
		<string>(au:get-speech-channel)</string>
	</dict>
	<key>au:get-speech-info</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>No Description For get-speech-info</string>
		</array>
		<key>returns</key>
		<string>num</string>
		<key>short</key>
		<string>(au:get-speech-info speech-channel)</string>
	</dict>
	<key>au:has-custom-ui</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>audiounit</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Does the au have a custom UI?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:has-custom-ui au)</string>
	</dict>
	<key>au:load-audio-data</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>path</key>
			<string>the path to the audiofile to load</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns audio data loaded from the audiofile pointed to by path</string>
		</array>
		<key>returns</key>
		<string>audio data (NSArray)</string>
		<key>short</key>
		<string>(au:load-audio-data path)</string>
	</dict>
	<key>au:load-preset</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>audiounit to load the state of</string>
			<key>path</key>
			<string>the fully qualified path to the preset file</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(au:load-preset reverb &quot;/tmp/concert_hall.aupreset&quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>loads an audiounits state from a preset file</string>
		</array>
		<key>related</key>
		<string>au:save-preset</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:load-preset au path)</string>
	</dict>
	<key>au:make-node</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>channels-in</key>
			<string>An optional argument specifying the number of channels that this audiounit should take as input (defaults to 2 - i.e Stereo).  If your AU supports multiple input busses then you can specify input channels per bus by passing a list of integers - one for each bus.  Check that your audiounit supports more than 2 channels in (you can check using AULab among other things). Be careful what you connect it to as it will force this input of the next audiounit in the chain to match the number of channels you spec here</string>
			<key>channels-out</key>
			<string>An optional argument specifying the number of channels that this audiounit should output (defaults to 2 - i.e Stereo).  If your AU supports multiple output busses then you can specify output channels per bus as a list of integers - one for each bus.  Check that your audiounit supports more than 2 channels out (you can check using AULab among other things). Be careful what you connect it to as it will force this input of the next audiounit in the chain to match the number of channels you spec here</string>
			<key>manufacturer</key>
			<string>a four chanarcter string describing The manufacturers name. Apple audiounits are tagged &quot;appl&quot;.</string>
			<key>sub-type</key>
			<string>a four character string describing the name of the audiounit that you wish to open. A common instrument available on every OSX system is &quot;dls &quot;</string>
			<key>type</key>
			<string>a four character string representing the type of audiounit. the type is one of &quot;aumu&quot; &quot;aufx&quot; &quot;aumx&quot; &quot;aupn&quot; &quot;aufc&quot; &quot;augn&quot; &quot;aumf&quot;</string>
		</dict>
		<key>examples</key>
		<array>
			<string>; connect two dls audiounits</string>
			<string>; one with reverb and one without</string>
			<string>(define inst1 (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))</string>
			<string>(define inst2 (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))</string>
			<string>(define reverb (au:make-node &quot;aufx&quot; &quot;mrev&quot; &quot;appl&quot;))</string>
			<string>(define mixer (au:make-node &quot;aumx&quot; &quot;smxr&quot; &quot;appl&quot;))</string>
			<string>(au:connect-node inst1 0 reverb 0)</string>
			<string>(au:connect-node reverb 0 mixer 0)</string>
			<string>(au:connect-node inst2 0 mixer 1)</string>
			<string>(au:connect-node mixer 0 *au:output-node* 0)</string>
			<string>(au:update-graph)</string>
			<string></string>
			<string>(au:open-view inst1)</string>
			<string>(play-note (now) inst1 60 80 *second*)</string>
			<string>(play-note (now) inst2 72 80 *second*)</string>
		</array>
		<key>long</key>
		<array>
			<string>Creates a new audiounit node.  Audiounit nodes can
	  be connected together to form complex audio processing
	  graphs (see au:connect-node, au:update-graph). You can
	  manipulate audiounit nodes using a variety of impromptu
	  functions (play-note au:set-param au:print-params
	  au:get-param au:midi-out etc.). A visual user interface for
	  each audiounit node can be opened by calling (au:open-view
	  au:node).  The type, sub-type and manu for each audiounit on
	  your system can be found by using the (au:print-audiounits
	  type) function or use the OSX command line tool auval with
	  the -a option.</string>
		</array>
		<key>related</key>
		<string>au:update-graph au:print-audiounits au:set-param
	au:print-params au:get-param au:clear-graph au:print-graph
	au:connect-node au:disconnect-node play-note
	au:midi-out</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:make-node type sub-type manu [channels-out] [channels-in])</string>
	</dict>
	<key>au:midi-out</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>a</key>
			<string>byte a of the message (integer 0-127)</string>
			<key>au</key>
			<string>audiounit to send midi message to</string>
			<key>b</key>
			<string>byte b of the message (integer 0-127)</string>
			<key>channel</key>
			<string>the midi channel</string>
			<key>time</key>
			<string>time in samples</string>
			<key>type</key>
			<string>the type of message *io:midi-on* *io:midi-off* *io:midi-cc* *io:midi-pc*</string>
		</dict>
		<key>examples</key>
		<array>
			<string>; send midi note on pitch 60 velocity 80</string>
			<string>(au:midi-out (now) piano *io:midi-on* 0 60 80)</string>
			<string></string>
			<string>; send midi control change 23 with value 90</string>
			<string>(au:midi-out (now) piano *io:midi-cc* 0 23 90)</string>
		</array>
		<key>long</key>
		<array>
			<string>sends a midi message to an audiounit</string>
		</array>
		<key>related</key>
		<string>io:osc:receive io:osc:send io:midi-in io:midi-out</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:midi-out time au type channel a b)</string>
	</dict>
	<key>au:open-view</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>audiounit to open UI for</string>
			<key>generic-view</key>
			<string>optional boolean argument to force a generic cocoa view</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(au:open-view automat)</string>
			<string>(au:open-view mixer #t)</string>
		</array>
		<key>long</key>
		<array>
			<string>opens an audiounits user interface for user interaction. If a custom view is available this will be opened, otherwise a generic carbon view will be used.  You can force a generic cocoa view by passing the boolean generic-view argument a #t (this is useful for mixer&apos;s in particular).</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:open-view au [generic-view])</string>
	</dict>
	<key>au:play-note</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>audiounit</string>
			<key>duration</key>
			<string>in samples</string>
			<key>midi-channel</key>
			<string>optional midi-channel defaults to 0</string>
			<key>pitch</key>
			<string>0-127 midi</string>
			<key>time</key>
			<string>time in samples to play note</string>
			<key>volume</key>
			<string>0-127 midi</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(au:play-note (now) inst 60 80 (* *second* 1.0))</string>
		</array>
		<key>long</key>
		<array>
			<string>Play a note by sending a note-on then a note-off event seperated by duration to au.  Duration is in samples.  Pitch values falling outside of 0-127 are ignored (so you can use negative numbers as rests if you like).  If for some reason you need to send pitch values outside of 0-127 you can call au:midi-out which does not bounds checking.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:play-note time au pitch volume duration [midi-channel])</string>
	</dict>
	<key>au:play-sound</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>audiounit</string>
			<key>duration</key>
			<string>in samples</string>
			<key>pitch</key>
			<string>real number value where decimal portion is in cents (i.e. 60.25 = C+25cents)</string>
			<key>time</key>
			<string>time in samples to play note</string>
			<key>volume</key>
			<string>real number volume</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(play-sound (now) inst 60.25 80.5 (* *second* 1.0))</string>
		</array>
		<key>long</key>
		<array>
			<string>Play a sound of duration by sending extended api information to the specified au. Duration is in samples.  Pitch values are real numbers where the decimal portion is in cents (i.e. 60.25 = C+25cents).  volumes are also real number values.  NOTE: this only works with audiounits supporting the extended AudioUnit Note API (at the present the only AU I know that supports this is apples DLS). If your AU does not support this use the standard play-note function instead.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:play-sound time au pitch volume duration)</string>
	</dict>
	<key>au:play:set-sample-data</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>An AudioUnit of type &quot;aumu&quot; &quot;play&quot; &quot;moso&quot;</string>
			<key>data</key>
			<string>An object containing audio data.  Usually audio data will be from calling au:load-audio-data</string>
			<key>pitch</key>
			<string>The root pitch to set the audio data at</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Sets audio data into sampler (&quot;aumu&quot; &quot;play&quot; &quot;moso&quot;) at a given root pitch.  Usually sample data will come from calling au:load-audio-data</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:play:set-sample-data au pitch data)</string>
	</dict>
	<key>au:print-audiounits</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>type</key>
			<string>a four char code for the type of audiounits to
	  print</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>prints a list of audiounits of type available on the
	  system to the log view.  the type can be one of &quot;aumu&quot;
	  &quot;aufx&quot; &quot;aumx&quot; &quot;augn&quot; &quot;auou&quot; &quot;aufc&quot; &quot;aumf&quot;</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:print-audiounits type)</string>
	</dict>
	<key>au:print-graph</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>prints the current status of the audiounit graph to the log view</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:print-graph)</string>
	</dict>
	<key>au:print-params</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>audiounit whos parameters we want to print to the log</string>
			<key>scope</key>
			<string>the scope whos parameters we want to print (i.e. *au:output-scope* *au:global-scope* *au:input-scope* *au:group-scope*)</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define dls (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))</string>
			<string>(au:connect-node dls 0 *au:output-node* 0)</string>
			<string>(au:update-graph)</string>
			<string></string>
			<string>; print all global parameters for dls (note that tuning is id 0)</string>
			<string>(au:print-params dls *au:global-scope*)</string>
			<string></string>
			<string>; get the current tuning for the dls</string>
			<string>(define tuning (au:get-param dls 0 *au:global-scope* 0))</string>
			<string>; raise the dls tuning parameter by 300 cents </string>
			<string>(au:set-param (now) dls 0 *au:global-scope* 0 (+ tuning 300))</string>
		</array>
		<key>long</key>
		<array>
			<string>prints any parameters associated with au to the log view</string>
		</array>
		<key>related</key>
		<string>au:set-param au:get-param au:midi-out</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:print-params au scope)</string>
	</dict>
	<key>au:rec_:get-sample-data</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>An AudioUnit of type &quot;aufx&quot; &quot;rec_&quot; &quot;moso&quot;</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Gets audio data from recorder audiounit (&quot;aufx&quot; &quot;rec_&quot; &quot;moso&quot;).  Data can then be passed to au:play:set-sample-data</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:rec_:get-sample-data au)</string>
	</dict>
	<key>au:save-preset</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>the audiounit who&apos;s settings you want to save</string>
			<key>path</key>
			<string>the fully qualified path to the file (as a string)</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(au:save-preset au &quot;/tmp/piano.aupreset&quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>Saves an audiounits settings to disk</string>
		</array>
		<key>related</key>
		<string>au:load-preset</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:save-preset au path)</string>
	</dict>
	<key>au:set-bypass</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>the au to bypass or unbypass</string>
			<key>bool</key>
			<string>#t bypasses the au #f unbypasses the au</string>
			<key>time</key>
			<string>time in samples to schedule this event</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define dls (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))</string>
			<string>(define rev (au:make-node &quot;aufx&quot; &quot;mrev&quot; &quot;appl&quot;))</string>
			<string>(au:connect-node rev 0 *au:output-node* 0)</string>
			<string>(au:connect-node dls 0 rev 0)</string>
			<string>(au:update-graph)</string>
			<string></string>
			<string>(print (au:get-bypass rev))</string>
			<string>(play-note (now) dls 60 20 1000000)</string>
			<string>(au:set-bypass (now) rev #t)</string>
		</array>
		<key>long</key>
		<array>
			<string>Turns on or off bypassing of au</string>
		</array>
		<key>related</key>
		<string>au:bypassed?</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:set-bypass time au bool)</string>
	</dict>
	<key>au:set-global-beat</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>beat</key>
			<string>beat to set globally</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Sets the global beat for any au&apos;s to pick up on. this must be set continuously.  1.0 is 1 beat etc.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:set-global-beat beat)</string>
	</dict>
	<key>au:set-global-tempo</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>tempo</key>
			<string>tempo in beat per minute</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(au:set-global-tempo 120)</string>
		</array>
		<key>long</key>
		<array>
			<string>Sets the global tempo to bpm.  Note that this makes no difference to Impromptu timing but is picked up by instantiated AudioUnit&apos;s (for delay times etc.)</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:set-global-tempo bpm)</string>
	</dict>
	<key>au:set-param</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>audiounit</string>
			<key>element</key>
			<string>element (usually 0)</string>
			<key>id</key>
			<string>param id</string>
			<key>scope</key>
			<string>scope (usually *au:global-scope*)</string>
			<key>time</key>
			<string>time in samples</string>
			<key>val</key>
			<string>value to set param to</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define dls (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))</string>
			<string>(au:connect-node dls 0 *au:output-node* 0)</string>
			<string>(au:update-graph)</string>
			<string></string>
			<string>; print all global parameters for dls (note that tuning is id 0)</string>
			<string>(au:print-params dls *au:global-scope*)</string>
			<string></string>
			<string>; get the current tuning for the dls</string>
			<string>(define tuning (au:get-param dls 0 *au:global-scope* 0))</string>
			<string>; raise the dls tuning parameter by 300 cents </string>
			<string>(au:set-param (now) dls 0 *au:global-scope* 0 (+ tuning 300))</string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For au:set-param</string>
		</array>
		<key>related</key>
		<string>au:get-param au:print-params</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:set-param time au id scope element val)</string>
	</dict>
	<key>au:set-property</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>audiounit</string>
			<key>cptr</key>
			<string>a void pointer (i.e. cptr) which is the value to assign</string>
			<key>element</key>
			<string>element</string>
			<key>id</key>
			<string>property id</string>
			<key>length</key>
			<string>the length in bytes of the cptr value</string>
			<key>scope</key>
			<string>scope (global, input etc..)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Sets the property value (cptr) of id in the audiounit au</string>
		</array>
		<key>related</key>
		<string>au:get-param</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:set-property au id scope element cptr length)</string>
	</dict>
	<key>au:set-speech-vol</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>time</key>
			<string>time in samples</string>
			<key>voice</key>
			<string>the voice to set volume for</string>
			<key>volume</key>
			<string>volume between 0.0 and 1.0</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Sets the voices volume</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:set-speech-vol time voice volume)</string>
	</dict>
	<key>au:speak</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>str</key>
			<string>string</string>
			<key>time</key>
			<string>in samples</string>
			<key>voice</key>
			<string>voice channel to speak on</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Speak str at time on voice channel</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:speak time voice str)</string>
	</dict>
	<key>au:start-audio-capture</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>channels</key>
			<string>optional channels argument defaults to 2 (stereo)</string>
			<key>file-path</key>
			<string>fully qualified path for new .aif or .m4a file. just add the appropriate file extension</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Start capturing any audio output to aif or m4a file specified by file-path.  will save as aif if aif file extension or to m4a if m4a file extension.  number of channels defaults to 2. m4a must be 2</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:start-audio-capture file-path [channels])</string>
	</dict>
	<key>au:start-note</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>an aumu or augn</string>
			<key>channel</key>
			<string>optional midi channel defaults to 0</string>
			<key>pitch</key>
			<string>midi pitch number</string>
			<key>time</key>
			<string>in samples</string>
			<key>volume</key>
			<string>midi volume number</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Send a note-on event to au of pitch and volume. pitch values outside 0-127 are ignored.  use au:midi-out if for some reason you want to send pitch values outside 0-127</string>
		</array>
		<key>related</key>
		<string>au:stop-note au:start-sound au:midi-out</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:start-note time au pitch volume [channel])</string>
	</dict>
	<key>au:start-sound</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>an aumu or augn</string>
			<key>pitch</key>
			<string>a real number value where decimal numbers are in cents (i.e. 60.25 is C+25cents)</string>
			<key>time</key>
			<string>in samples</string>
			<key>volume</key>
			<string>real number volume</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Sends a start sound event to an audiounit supporting the extended AU note api. pitch values are real numbers where decimals represent cents (i.e. 60.25 is a middle C+25 cents). volume is also a real number value.  NOTE: this only works with audiounits supporting the extended AudioUnit Note API (at the present the only AU I know that supports this is apples DLS). If your AU does not support this use the standard au:start-note function instead.</string>
		</array>
		<key>related</key>
		<string>au:stop-sound au:play-sound au:play-note au:start-note au:midi-out</string>
		<key>returns</key>
		<string>a unique integer note-index which must be passed to au:stop-sound to stop the sound</string>
		<key>short</key>
		<string>(au:start-sound time au pitch volume)</string>
	</dict>
	<key>au:start-visual-ui</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>height</key>
			<string>height in pixels of the window</string>
			<key>transparency</key>
			<string>a transparency for the background (1.0 is opaque)</string>
			<key>width</key>
			<string>width in pixels of the window</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>All available AudioUnits are represented as rectangles across the bottom of the screen.  You can write click on any audiounit to see it&apos;s full name.  To instantiate an AudioUnit you can left click and drag it into position.  Available inputs and outputs are represented as boxes into and out of the audiounit (same as MAX, Reaktor etc.). You can connect two AudioUnits by right click dragging from an output to an input.  Connections must always be made from an output.  You can delete an AudioUnit by selecting it (left clicking on it) and then pressing the delete button. Double clicking on an AudioUnit will open it&apos;s UI. Instantiated AudioUnits are displayed with their node number.  You can use this node number to bind the AudioUnit in Scheme.  This makes
it trivial to tie the graphical representation back into your Scheme code.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:start-visual-ui height width transparency)</string>
	</dict>
	<key>au:stop-audio-capture</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Stop audio capture and close aif file</string>
		</array>
		<key>related</key>
		<string>au:start-audio-capture</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:stop-audio-capture)</string>
	</dict>
	<key>au:stop-note</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>an aumu or augn</string>
			<key>channel</key>
			<string>optional channel defaults to 0</string>
			<key>pitch</key>
			<string>midi pitch number</string>
			<key>time</key>
			<string>time in samples</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>send note-off to au. pitch values outside of 0-127 are ignored.</string>
		</array>
		<key>related</key>
		<string>au:start-note au:start-sound start-sound au:midi-out</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:stop-note time au pitch [channel])</string>
	</dict>
	<key>au:stop-sound</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>an aumu or augn</string>
			<key>note-index</key>
			<string>unique integer note index</string>
			<key>pitch</key>
			<string>midi pitch number</string>
			<key>time</key>
			<string>time in samples</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>stops the sound associated with note-index.   NOTE: this only works with audiounits supporting the extended AudioUnit Note API (at the present the only AU I know that supports this is apples DLS). If your AU does not support this use the standard au:stop-note function instead.</string>
		</array>
		<key>related</key>
		<string>au:start-sound au:start-note stop-sound start-sound au:midi-out</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:stop-sound time au pitch note-index)</string>
	</dict>
	<key>au:update-graph</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array>
			<string>(define dls (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))</string>
			<string>(au:connect-node dls 0 *au:output-node* 0)</string>
			<string>(au:update-graph)</string>
		</array>
		<key>long</key>
		<array>
			<string>Update the audiounit graph to reflect any changes made using au:connect-node au:disconnect-node.  Any number of connections and disconnetions can be made before updating the graph (which is an atomic action).</string>
		</array>
		<key>related</key>
		<string>au:connect-node au:disconnect-node au:make-node</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(au:update-graph)</string>
	</dict>
	<key>begin</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array>
			<string>(define x 0)</string>
			<string></string>
			<string>(begin (set! x 5)</string>
			<string>       (+ x 1))                  =&gt;  6</string>
			<string></string>
			<string>(begin (print &quot;4 plus 1 equals &quot;)</string>
			<string>       (print (+ 4 1)))        -|  4 plus 1 equals 5</string>
			<string>                                 =&gt;  unspecified</string>
		</array>
		<key>long</key>
		<array>
			<string>The &lt;expression&gt;s are evaluated sequentially from left to right, and the</string>
			<string>value(s) of the last &lt;expression&gt; is(are) returned.  This expression</string>
			<string>type is used to sequence side effects such as input and output.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(begin &lt;expression1&gt; &lt;expression2&gt; ...)</string>
	</dict>
	<key>boolean?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>any valid scheme obj</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(boolean? #f)      =&gt; #t</string>
			<string>(boolean? 0)       =&gt; #f</string>
			<string>(boolean? &quot;hello&quot;) =&gt; #f</string>
		</array>
		<key>long</key>
		<array>
			<string>A boolean test for obj.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(boolean? obj)</string>
	</dict>
	<key>caaaar</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>a scheme pair</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>The car of the car of the car of the car (i.e. (car (car (car (car val)))))</string>
		</array>
		<key>returns</key>
		<string>a scheme object</string>
		<key>short</key>
		<string>(caaaar pair)</string>
	</dict>
	<key>caaadr</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>pair</key>
			<string>a scheme pair</string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>The car of the car of the car of the cdr (i.e. (car (car (car (cdr val)))))</string>
		</array>
		<key>returns</key>
		<string>a scheme object</string>
		<key>short</key>
		<string>(caaadr pair)</string>
	</dict>
	<key>caaar</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>pair</key>
			<string>a scheme pair</string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>The car of the car of the car (i.e. (car (car (car val))))</string>
		</array>
		<key>returns</key>
		<string>a scheme value</string>
		<key>short</key>
		<string>(caaar pair)</string>
	</dict>
	<key>caadar</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>pair</key>
			<string>a valid scheme pair</string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>(car (car (cdr (car pair))))</string>
		</array>
		<key>returns</key>
		<string>a scheme object</string>
		<key>short</key>
		<string>(caadar pair)</string>
	</dict>
	<key>caaddr</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For caaddr</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(caaddr pair)</string>
	</dict>
	<key>caadr</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For caadr</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(caadr)</string>
	</dict>
	<key>caar</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string>(caar &apos;((1 . 2) (3 . 4))) =&gt; 1</string>
		</array>
		<key>long</key>
		<array>
			<string>The car of the car of a pair.  (car (car pair))</string>
		</array>
		<key>returns</key>
		<string>a valide scheme object</string>
		<key>short</key>
		<string>(caar pair)</string>
	</dict>
	<key>cadaar</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cadaar</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cadaar)</string>
	</dict>
	<key>cadadr</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cadadr</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cadadr)</string>
	</dict>
	<key>cadar</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cadar</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cadar)</string>
	</dict>
	<key>caddar</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For caddar</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(caddar)</string>
	</dict>
	<key>cadddr</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cadddr</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cadddr)</string>
	</dict>
	<key>caddr</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For caddr</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(caddr)</string>
	</dict>
	<key>cadr</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>pair</key>
			<string>a scheme pair</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(cadr &apos;((1 . 2) . (3 . 4))) =&gt; 3</string>
		</array>
		<key>long</key>
		<array>
			<string>The car of the cdr of pair.  (car (cdr pair))</string>
		</array>
		<key>returns</key>
		<string>a scheme object</string>
		<key>short</key>
		<string>(cadr pair)</string>
	</dict>
	<key>call-cpp</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>time</key>
			<string>time can be either an integer or a cons of two integers a time and a marker</string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>call-cpp calls the C++ instace method defined by cptr.  This should never be called directly and is usually wrapped by scheduler functions such as play-note gfx:draw-path etc.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(call-cpp time cptr . args)</string>
	</dict>
	<key>call-cpp-at-time</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Should not be called directly.  For internal impromptu use only.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(call-cpp-at-time)</string>
	</dict>
	<key>call-with-current-continuation</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For call-with-current-continuation</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(call-with-current-continuation func)</string>
	</dict>
	<key>call-with-input-file</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For call-with-input-file</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(call-with-input-file)</string>
	</dict>
	<key>call-with-output-file</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For call-with-output-file</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(call-with-output-file)</string>
	</dict>
	<key>call/cc</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For call/cc</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(call/cc func)</string>
	</dict>
	<key>callback</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>args</key>
			<string>any arguments required by proc</string>
			<key>proc|symbol</key>
			<string>the procedure to callback into or the symbol of the procedure to callback into</string>
			<key>time</key>
			<string>to to callback to proc</string>
		</dict>
		<key>examples</key>
		<array>
			<string>; a one off callback</string>
			<string>(callback (+ (now) (* *minute* 10)) (lambda (str) (print str)) &quot;Hello World&quot;)</string>
			<string></string>
			<string>; a termporally recursive function</string>
			<string>(define loop</string>
			<string>	(lambda (time str)</string>
			<string>		(print &quot;Hello World&quot;)</string>
			<string>		(callback (+ time 10000) &apos;loop (+ time 11025) str)))</string>
		</array>
		<key>long</key>
		<array>
			<string>Callback to proc (or the proc bound to symbol) at time.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(callback time proc|symbol . args)</string>
	</dict>
	<key>callback-adapter</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>For internal impromptu use only.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(callback-adapter)</string>
	</dict>
	<key>car</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>pair</key>
			<string>a scheme pair</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(car (cons 1 2)) =&gt; 1</string>
		</array>
		<key>long</key>
		<array>
			<string>The first element of a scheme pair (being the cons of two elements)</string>
		</array>
		<key>related</key>
		<string>cdr cadr cons list</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(car pair)</string>
	</dict>
	<key>case</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array>
			<string>(case (* 2 3)</string>
			<string>  ((2 3 5 7) &apos;prime)</string>
			<string>  ((1 4 6 8 9) &apos;composite))     =&gt;  composite</string>
			<string>(case (car &apos;(c d))</string>
			<string>  ((a) &apos;a)</string>
			<string>  ((b) &apos;b))                     =&gt;  unspecified</string>
			<string>(case (car &apos;(c d))</string>
			<string>  ((a e i o u) &apos;vowel)</string>
			<string>  ((w y) &apos;semivowel)</string>
			<string>  (else &apos;consonant))            =&gt;  consonant</string>
		</array>
		<key>long</key>
		<array>
			<string>Syntax: &lt;Key&gt; may be any expression.  Each &lt;clause&gt; should have the form</string>
			<string></string>
			<string>         ((&lt;datum1&gt; ...) &lt;expression1&gt; &lt;expression2&gt; ...),</string>
			<string></string>
			<string>where each &lt;datum&gt; is an external representation of some object.  All</string>
			<string>the &lt;datum&gt;s must be distinct.  The last &lt;clause&gt; may be an &quot;else</string>
			<string>clause,&quot; which has the form</string>
			<string></string>
			<string>         (else &lt;expression1&gt; &lt;expression2&gt; ...).</string>
			<string></string>
			<string>Semantics: A case expression is evaluated as follows.  &lt;Key&gt; is</string>
			<string>evaluated and its result is compared against each &lt;datum&gt;.  If the</string>
			<string>result of evaluating &lt;key&gt; is equivalent (in the sense of eqv?; see</string>
			<string>section 6.1) to a &lt;datum&gt;, then the expressions in the corresponding</string>
			<string>&lt;clause&gt; are evaluated from left to right and the result(s) of the last</string>
			<string>expression in the &lt;clause&gt; is(are) returned as the result(s) of the</string>
			<string>case expression.  If the result of evaluating &lt;key&gt; is different from</string>
			<string>every &lt;datum&gt;, then if there is an else clause its expressions are</string>
			<string>evaluated and the result(s) of the last is(are) the result(s) of the</string>
			<string>case expression; otherwise the result of the case expression is</string>
			<string>unspecified.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(case &lt;key&gt; &lt;clause1&gt; &lt;clause2&gt; ...)</string>
	</dict>
	<key>catch</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array>
			<string>(define myfunc</string>
			<string>   (lambda (x)</string>
			<string>      (if (negative? x) (throw) x)))</string>
			<string></string>
			<string>(catch (print-error &quot;Negatives Not Allowed&quot;)</string>
			<string>       (print &quot;Try 5&quot;)</string>
			<string>       (print (myfunc 5))</string>
			<string>       (print &quot;Try -5&quot;)</string>
			<string>       (print (myfunc -5)))	</string>
		</array>
		<key>long</key>
		<array>
			<string>Catch statement surrounding eval expressions. error expression will be run upon experiencing a throw in any eval expressions</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(catch (error expression) . (eval expressions))</string>
	</dict>
	<key>cdaaar</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cdaaar</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cdaaar pair)</string>
	</dict>
	<key>cdaadr</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cdaadr</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cdaadr pair)</string>
	</dict>
	<key>cdaar</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cdaar</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cdaar pair)</string>
	</dict>
	<key>cdadar</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cdadar</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cdadar pair)</string>
	</dict>
	<key>cdaddr</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cdaddr</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cdaddr pair)</string>
	</dict>
	<key>cdadr</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cdadr</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cdadr pair)</string>
	</dict>
	<key>cdar</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string>(cdar &apos;((1 . 2) . (3 . 4))) =&gt; 2</string>
		</array>
		<key>long</key>
		<array>
			<string>The cdr of the car of pair (cdr (car pair))</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cdar pair)</string>
	</dict>
	<key>cddaar</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cddaar</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cddaar pair)</string>
	</dict>
	<key>cddadr</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cddadr</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cddadr pair)</string>
	</dict>
	<key>cddar</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cddar</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cddar pair)</string>
	</dict>
	<key>cdddar</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cdddar</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cdddar pair)</string>
	</dict>
	<key>cddddr</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cddddr</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cddddr pair)</string>
	</dict>
	<key>cdddr</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cdddr</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cdddr pair)</string>
	</dict>
	<key>cddr</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string>(cddr &apos;((1 . 2) . (3 . 4))) =&gt; 4</string>
		</array>
		<key>long</key>
		<array>
			<string>The cdr of the cdr of pair (cdr (cdr pair))</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cddr pair)</string>
	</dict>
	<key>cdr</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>pair</key>
			<string>the cons of two objects</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(cdr (cons 1 2)) =&gt; 2</string>
		</array>
		<key>long</key>
		<array>
			<string>The second object of pair (being the cons of two objects)</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cdr pair)</string>
	</dict>
	<key>ceiling</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>number</key>
			<string>any valid scheme number</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(ceiling 5.1) =&gt; 6</string>
		</array>
		<key>long</key>
		<array>
			<string>Rounds real numbers up to the next whole integer.</string>
		</array>
		<key>returns</key>
		<string>number</string>
		<key>short</key>
		<string>(ceiling number)</string>
	</dict>
	<key>change-over-time</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>args</key>
			<string>Any aditional args that may be needed by function (not including beat and value)</string>
			<key>duration</key>
			<string>How long to run change over time</string>
			<key>from</key>
			<string>The value to start at</string>
			<key>function</key>
			<string>A function accepting two arguments beat and value (and optionally includuing any additional arguments passed as args). The beat the function is called at and the value passed</string>
			<key>rate</key>
			<string>How many intervals moving from start to (+ start duration)</string>
			<key>start</key>
			<string>When to start change-over-time</string>
			<key>to</key>
			<string>The value to end at</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define test-func</string>
			<string>   (lambda (beat value name) </string>
			<string>      (gfx:draw-path (*metro* beat) *canvas* </string>
			<string>                     (gfx:make-circle (random 640) (random 480) value)</string>
			<string>                     &apos;() &apos;(1 0 1 1))</string>
			<string>      (print name)</string>
			<string>      (au:set-param (*metro* beat) synth 77 0 value)))</string>
			<string></string>
			<string>(change-over-time (*metro* &apos;get-beat 4) 8 1/8 10 100 test-func &quot;Impromptu&quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>Change over time calls the given function at rate starting at start and going for duration. Function must take two arguments, a beat and a value - you do not need to use them - and additionally any arguments passed as args. The value passed to the function moves from to over duration at rate.</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>bool</string>
		<key>short</key>
		<string>(change-over-time start duration rate from to function . args)</string>
	</dict>
	<key>char-&gt;integer</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>char</key>
			<string>the characters whos ascii value we want to find</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(char-&gt;integer #\a) =&gt; 97</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns the ascii value of char</string>
		</array>
		<key>related</key>
		<string>integer-&gt;char number-&gt;string string-&gt;number</string>
		<key>returns</key>
		<string>integer</string>
		<key>short</key>
		<string>(char-&gt;integer char)</string>
	</dict>
	<key>char-alphabetic?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For char-alphabetic?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(char-alphabetic? char)</string>
	</dict>
	<key>char-ci-cmp?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Case insensitive compare</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(char-ci-cmp? predicate c1 c2)</string>
	</dict>
	<key>char-ci&lt;=?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Case insensitive compare</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(char-ci&lt;=? c1 c2)</string>
	</dict>
	<key>char-ci&lt;?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Case insensitive compare</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(char-ci&lt;? c1 c2)</string>
	</dict>
	<key>char-ci=?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Case insensitive compare</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(char-ci=? c1 c2)</string>
	</dict>
	<key>char-ci&gt;=?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Case insensitive compare</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(char-ci&gt;=? c1 c2)</string>
	</dict>
	<key>char-ci&gt;?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Case insensitive compare</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(char-ci&gt;?)</string>
	</dict>
	<key>char-cmp?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Character compare</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(char-cmp? predicate c1 c2)</string>
	</dict>
	<key>char-downcase</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Force lowercase of char</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(char-downcase char)</string>
	</dict>
	<key>char-lower-case?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Predicate is lower case</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(char-lower-case? char)</string>
	</dict>
	<key>char-numeric?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Predicate is numberic</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(char-numeric? char)</string>
	</dict>
	<key>char-ready?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Predicate is there a character to read on port</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(char-ready? port)</string>
	</dict>
	<key>char-upcase</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Force char upcass</string>
		</array>
		<key>returns</key>
		<string>character</string>
		<key>short</key>
		<string>(char-upcase char)</string>
	</dict>
	<key>char-upper-case?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Predicate is char uppercase</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(char-upper-case? char)</string>
	</dict>
	<key>char-whitespace?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Prediate is char whitespace?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(char-whitespace? char)</string>
	</dict>
	<key>char&lt;=?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Character compare</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(char&lt;=? c1 c2)</string>
	</dict>
	<key>char&lt;?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Character compare</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(char&lt;? c1 c2)</string>
	</dict>
	<key>char=?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Character compare</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(char=? c1 c2)</string>
	</dict>
	<key>char&gt;=?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Character compare</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(char&gt;=? c1 c2)</string>
	</dict>
	<key>char&gt;?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Character compare</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(char&gt;? c1 c2)</string>
	</dict>
	<key>char?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Prediate is character</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(char? obj)</string>
	</dict>
	<key>cl:adjoin</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:adjoin</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:adjoin)</string>
	</dict>
	<key>cl:and?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:and?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:and?)</string>
	</dict>
	<key>cl:atom?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:atom?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:atom?)</string>
	</dict>
	<key>cl:butlast</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:butlast</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:butlast)</string>
	</dict>
	<key>cl:butnthcdr</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:butnthcdr</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:butnthcdr)</string>
	</dict>
	<key>cl:copy-list</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:copy-list</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:copy-list)</string>
	</dict>
	<key>cl:delete</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:delete</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:delete)</string>
	</dict>
	<key>cl:delete-if</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:delete-if</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:delete-if)</string>
	</dict>
	<key>cl:delete-if-not</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:delete-if-not</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:delete-if-not)</string>
	</dict>
	<key>cl:every</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:every</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:every)</string>
	</dict>
	<key>cl:find-if</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:find-if</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:find-if)</string>
	</dict>
	<key>cl:has-duplicates?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:has-duplicates?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:has-duplicates?)</string>
	</dict>
	<key>cl:intersection</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:intersection</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:intersection)</string>
	</dict>
	<key>cl:last</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:last</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:last)</string>
	</dict>
	<key>cl:list*</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:list*</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:list*)</string>
	</dict>
	<key>cl:list-of??</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:list-of??</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:list-of??)</string>
	</dict>
	<key>cl:make-list</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:make-list</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:make-list)</string>
	</dict>
	<key>cl:member-if</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:member-if</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:member-if)</string>
	</dict>
	<key>cl:merge</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:merge</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:merge)</string>
	</dict>
	<key>cl:merge!</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:merge!</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:merge!)</string>
	</dict>
	<key>cl:nconc</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:nconc</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:nconc)</string>
	</dict>
	<key>cl:notany</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:notany</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:notany)</string>
	</dict>
	<key>cl:notevery</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:notevery</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:notevery)</string>
	</dict>
	<key>cl:nreverse</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:nreverse</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:nreverse)</string>
	</dict>
	<key>cl:nthcdr</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:nthcdr</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:nthcdr)</string>
	</dict>
	<key>cl:or?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:or?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:or?)</string>
	</dict>
	<key>cl:position</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:position</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:position)</string>
	</dict>
	<key>cl:reduce</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:reduce</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:reduce)</string>
	</dict>
	<key>cl:reduce-init</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:reduce-init</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:reduce-init)</string>
	</dict>
	<key>cl:remove</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:remove</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:remove)</string>
	</dict>
	<key>cl:remove-duplicates</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:remove-duplicates</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:remove-duplicates)</string>
	</dict>
	<key>cl:remove-if</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>lst</key>
			<string>list of items to test against predicate?</string>
			<key>predicate?</key>
			<string>predicate test for items in lst</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;; remove all names that include at least one &apos;i&apos;
(cl:remove-if (lambda (s)
                 (regex-match s &quot;.*i.*&quot;))
              &apos;(&quot;andrew&quot; &quot;ben&quot; &quot;david&quot; &quot;michele&quot; &quot;paul&quot; &quot;adam&quot; &quot;jim&quot;))</string>
		</array>
		<key>long</key>
		<array>
			<string>Remove all items in lst that successfully match predicate?</string>
		</array>
		<key>returns</key>
		<string>list</string>
		<key>short</key>
		<string>(cl:remove-if predicate? lst)</string>
	</dict>
	<key>cl:remove-if-not</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>lst</key>
			<string>list of items to test against predicate?</string>
			<key>predicate?</key>
			<string>predicate test for items in lst</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(cl:remove-if-not (lambda (s)
                     (regex-match s &quot;.*i.*&quot;))
                  &apos;(&quot;andrew&quot; &quot;ben&quot; &quot;david&quot; &quot;michele&quot; &quot;paul&quot; &quot;adam&quot; &quot;jim&quot;))</string>
		</array>
		<key>long</key>
		<array>
			<string>Removes all items of lst that do NOT conform to predicate?</string>
		</array>
		<key>returns</key>
		<string>list</string>
		<key>short</key>
		<string>(cl:remove-if-not predicate? lst)</string>
	</dict>
	<key>cl:set-difference</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:set-difference</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:set-difference)</string>
	</dict>
	<key>cl:some</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:some</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:some)</string>
	</dict>
	<key>cl:sort</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:sort</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:sort)</string>
	</dict>
	<key>cl:sort!</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:sort!</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:sort!)</string>
	</dict>
	<key>cl:sorted?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:sorted?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:sorted?)</string>
	</dict>
	<key>cl:subset?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:subset?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:subset?)</string>
	</dict>
	<key>cl:union</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cl:union</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cl:union)</string>
	</dict>
	<key>clock</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>time-string</key>
			<string>An optional string of format YYYY-MM-DD HH:MM:SS HHMM that specifies a time other than *now* to return.  e.g. &quot;2001-03-24 10:45:32 +0600&quot;</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;; play note in 3 and one quarter seconds from now
(play-note (clock-&gt;samples (+ (clock) 3.25)) inst 60 80 (* 1.0 *second*))
;; play note at 9pm on the 4th June 2012 +10 GMT
(play-note (clock-&gt;samples (clock &quot;2012-06-04 21:00:00 +1000&quot;)) inst 60 80 (* 1.0 *second*))</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns the time since 1st of January 2001 as a real value in seconds (and parts of seconds).  This value comes from the OSX system clock which on most OSX systems is set using NTP or networked time protcol.  Clock suppliments (now) by providing a real-world time source for impromptu.  Conversion back to impromptu&apos;s sample bass can be made using clock-&gt;samples.  If a time-string is provided then clock uses that time rather than the current time.  The string format is YYYY-MM-DD HH:MM:SS HHMM and must be provided in full.  example: &quot;2001-03-24 10:45:32 +0600&quot;</string>
		</array>
		<key>related</key>
		<string>clock-&gt;samples samples-&gt;clock now</string>
		<key>returns - 2</key>
		<string>real</string>
		<key>short</key>
		<string>(clock [time string])</string>
	</dict>
	<key>clock-&gt;samples</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>time</key>
			<string>time in clock time (real number) before being converted to samples</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(clock-&gt;samples (clock))</string>
		</array>
		<key>long</key>
		<array>
			<string>Takes a real valued clock time and returns a time in samples (that could be used in play-note for example) </string>
		</array>
		<key>returns</key>
		<string>integer (samples since impromptu started)</string>
		<key>short</key>
		<string>(clock-&gt;samples time)</string>
	</dict>
	<key>clock:sync-adjust</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>local-proc</key>
			<string>The name of the process the server should callback to (i.e. the servers name for the local process)</string>
			<key>samples</key>
			<string>the number of messages to send - multiple messages provide an average of the network round trip time</string>
			<key>server-proc</key>
			<string>The name of the server process to get time from</string>
			<key>std-dev</key>
			<string>an optional test for std-deviation of sample number of offsets.  Defaults to .0005</string>
			<key>wait-time</key>
			<string>the time gap between each call - multiple calls used to average the network time</string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Adjusts the local system clock to reflect the time on the server (i.e. the result of calling (clock) - not (now) ).  This call uses the delay and offset algorithms from the SNTP spec.  Multiple samples can be used to provide a more accurate average of network delay times.</string>
		</array>
		<key>related</key>
		<string>clock:update-metro</string>
		<key>returns</key>
		<string>bool</string>
		<key>short</key>
		<string>(clock:sync-adjust server-proc local-proc samples wait-time [std-dev])</string>
	</dict>
	<key>clock:update-metro</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>local-process</key>
			<string>The name of the process the server should callback to (i.e. the servers name for the local process)</string>
			<key>server-process</key>
			<string>The name of the server process to get time from</string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Sets this processes *metro* to be the same as the *metro* in the remote process (this relies on sync&apos;d clocks - i.e. call clock:sync-adjust first)</string>
		</array>
		<key>related</key>
		<string>clock:update-metro</string>
		<key>returns</key>
		<string>bool</string>
		<key>short</key>
		<string>(clock:sync-adjust server-proc local-proc samples wait-time)</string>
	</dict>
	<key>close-input-port</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>port</key>
			<string>scheme port</string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Closes the file associated with port</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(close-input-port port)</string>
	</dict>
	<key>close-output-port</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>port</key>
			<string>scheme port</string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Closes the file associated with port</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(close-output-port port)</string>
	</dict>
	<key>close-port</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>port</key>
			<string>scheme port</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Close file associated with scheme port</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(close-port port)</string>
	</dict>
	<key>closure?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>scheme obj</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Predicate is scheme obj a closure?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(closure? obj)</string>
	</dict>
	<key>complex?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For complex?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(complex?)</string>
	</dict>
	<key>cond</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array>
			<string>(cond ((&gt; 3 2) &apos;greater)</string>
			<string>      ((&lt; 3 2) &apos;less))                    =&gt;  greater</string>
			<string>      </string>
			<string>(cond ((&gt; 3 3) &apos;greater)</string>
			<string>      ((&lt; 3 3) &apos;less)</string>
			<string>      (else &apos;equal))                      =&gt;  equal</string>
			<string>      </string>
			<string>(cond ((assv &apos;b &apos;((a 1) (b 2))) =&gt; cadr)</string>
			<string>      (else #f))                          =&gt;  2</string>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Syntax: Each &lt;clause&gt; should be of the form</string>
			<string>         (&lt;test&gt; &lt;expression1&gt; ...)</string>
			<string>where &lt;test&gt; is any expression.  Alternatively, a &lt;clause&gt; may be of</string>
			<string>the form</string>
			<string>         (&lt;test&gt; =&gt; &lt;expression&gt;)</string>
			<string>The last &lt;clause&gt; may be an &quot;else clause,&quot; which has the form</string>
			<string>         (else &lt;expression1&gt; &lt;expression2&gt; ...).</string>
			<string>Semantics: A cond expression is evaluated by evaluating the &lt;test&gt;</string>
			<string>expressions of successive &lt;clause&gt;s in order until one of them</string>
			<string>evaluates to a true value (see section 6.3.1).  When a &lt;test&gt; evaluates</string>
			<string>to a true value, then the remaining &lt;expression&gt;s in its &lt;clause&gt; are</string>
			<string>evaluated in order, and the result(s) of the last &lt;expression&gt; in the</string>
			<string>&lt;clause&gt; is(are) returned as the result(s) of the entire cond</string>
			<string>expression.  If the selected &lt;clause&gt; contains only the &lt;test&gt; and no</string>
			<string>&lt;expression&gt;s, then the value of the &lt;test&gt; is returned as the result.</string>
			<string>If the selected &lt;clause&gt; uses the =&gt; alternate form, then the</string>
			<string>&lt;expression&gt; is evaluated.  Its value must be a procedure that accepts</string>
			<string>one argument; this procedure is then called on the value of the &lt;test&gt;</string>
			<string>and the value(s) returned by this procedure is(are) returned by the</string>
			<string>cond expression.  If all &lt;test&gt;s evaluate to false values, and there is</string>
			<string>no else clause, then the result of the conditional expression is</string>
			<string>unspecified; if there is an else clause, then its &lt;expression&gt;s are</string>
			<string>evaluated, and the value(s) of the last one is(are) returned.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cond &lt;clause1&gt; &lt;clause2&gt;)</string>
	</dict>
	<key>cond-eval</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cond-eval</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cond-eval)</string>
	</dict>
	<key>cond-eval-and</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cond-eval-and</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cond-eval-and)</string>
	</dict>
	<key>cond-eval-or</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cond-eval-or</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cond-eval-or)</string>
	</dict>
	<key>cond-expand-runtime</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cond-expand-runtime</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cond-expand-runtime)</string>
	</dict>
	<key>cons</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj1</key>
			<string>any scheme object</string>
			<key>obj2</key>
			<string>any scheme object</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(cons 5 10)                    =&gt; (5 . 10)</string>
			<string>(cons 5 (cons 6 7)             =&gt; (5 . (6 . 7))</string>
			<string>(cons 5 (cons 6 (cons 7 &apos;()))) =&gt; &apos;(5 6 7)</string>
		</array>
		<key>long</key>
		<array>
			<string>Construct a pair from two objects.</string>
		</array>
		<key>returns</key>
		<string>pair</string>
		<key>short</key>
		<string>(cons obj1 obj2)</string>
	</dict>
	<key>cons-stream</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For cons-stream</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cons-stream)</string>
	</dict>
	<key>cos</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>number</key>
			<string></string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns the cosine</string>
		</array>
		<key>returns</key>
		<string>number</string>
		<key>short</key>
		<string>(cos number)</string>
	</dict>
	<key>cosr</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>centre</key>
			<string>the centre point of your oscillation</string>
			<key>cycle</key>
			<string>the cycle of the oscillation</string>
			<key>range</key>
			<string>the amplitude of the oscillationg</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>oscillates around a central point with the period determined by beat (this macro requires that a symbol &apos;beat&apos; be valid in the environment)</string>
		</array>
		<key>related</key>
		<string>sinr</string>
		<key>returns</key>
		<string>number</string>
		<key>short</key>
		<string>(cosr centre range cycle)</string>
	</dict>
	<key>cptr?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>any scheme object</string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Predicate to check of obj is a cptr</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(cptr? obj)</string>
	</dict>
	<key>current-environment</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns the current environment</string>
		</array>
		<key>returns</key>
		<string>Environment</string>
		<key>short</key>
		<string>(current-environment)</string>
	</dict>
	<key>current-input-port</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns the current input port</string>
		</array>
		<key>returns</key>
		<string>current input port</string>
		<key>short</key>
		<string>(current-input-port)</string>
	</dict>
	<key>current-output-port</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns the current output port</string>
		</array>
		<key>returns</key>
		<string>current output port</string>
		<key>short</key>
		<string>(current-output-port)</string>
	</dict>
	<key>define</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>any valid scheme object</string>
			<key>variable</key>
			<string>any valid scheme symbol name</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define instrument (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))</string>
		</array>
		<key>long</key>
		<array>
			<string>Define binds variable to obj</string>
		</array>
		<key>returns</key>
		<string>symbol</string>
		<key>short</key>
		<string>(define variable obj)</string>
	</dict>
	<key>definec</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>[types]</key>
			<string>any types represented as cons pairs</string>
			<key>body</key>
			<string>the closure body code</string>
			<key>name</key>
			<string>symbol name for compiled function</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Some simple examples compiling scheme -&gt; x86
;;
;; Here are the ICR&apos;s primary types:
;; 
;; i1 -&gt; boolean
;; i8 -&gt; 8bit byte
;; i32 -&gt; 32bit integer
;; i64 -&gt; 64bit integer
;; float -&gt; 32 bit floating point
;; double -&gt; 64 bit floating point
;; [type,type ...] -&gt; is a closure including a return type followed by &apos;n&apos; argument types
;; &lt;type,type ...&gt; -&gt; is a tuple which contains &apos;n&apos; number of types
;; 
;; All of the above can pointers - indeed tuples and closures are always pointers.  
;; A pointer type uses &apos;*&apos; as in C.  So for example, an i8 pointer is i8* a pointer 
;; to a closure that returns a double and has a 32 bit integer argument would 
;; be [double,i32]* etc..  Strings are represented as i8*.  void pointers are also represented as i8*.
;; 
;; It is possible to allocate memory using (make-array) which allows you to allocate &apos;n&apos; number 
;; of &apos;type&apos;.  (make-array 8 double) will return a double* which points to the first double in 
;; an array of 8 doubles.  You are responsible for calling free on any memory that you allocate.  
;; (make-array) returns a pointer to the type you defined.  So (make-array 8 double) returns double*.  
;; (make-array 8 double*) returns double**.  (make-array 8 [double]*) returns [double]** etc..
;; 
;; You can &quot;cast&quot; numbers using the ftoi64, dtof, i32toi64 etc.. as discussed above
;; You can also &quot;cast&quot; pointers - where the first argument is a pointer value and the second argument 
;; is a pointer type to cast to - using bitcast: (bitcast my-ptr i8*) -&gt; casts my-ptr to i8*.  
;; Don&apos;t forget complex types - this is perfectly valid: (bitcast my-ptr (closure* double double)).  
;; However, as per C this is NOT type safe - you will crash Impromptu if you don&apos;t know what 
;; you&apos;re doing.  If in doubt don&apos;t use bitcast!!
;; 
;; Variables are introduced and scoped using closures and lets as per Scheme.  Let in the ICR is 
;; similar to let* in Scheme and can be used for recursive closure definition - similar to letrec.  
;; Closures in the ICR are first-class, you can pass them as arguments, store them in tuples or 
;; arrays or return them as per Scheme.
;; 
;; Some mathematical functions are overridden depending on type - here is a complete list of those that are:
;; * / - + override depending on type - for both reals and integers.
;; &lt; &gt; = &lt;&gt; also override depending on type - for both reals and integers.  These always return a boolean result (i1).
;; modulo is overridden for real and integer types.
;; dotimes overrides it&apos;s incrementor depending on type (real or integer)
;; 
;; For all other operations are of singular type.
;; 
;; This is a complete list of ICR&apos;s built-in functions:
;; * / - + &lt; &gt; = &lt;&gt; ;; integer or real -&gt; returns i1 (bool)
;; (modulo real real) or (modulo int int) ;; as per impromptu
;; (dotimes (i integer|real) ...) ; as per impromptu
;; (printf &quot;format-string&quot; ...) ; as per C.
;; (random) -&gt; returns double
;; (random i64) -&gt; returns i64
;; (random i64 i64) -&gt; returns i64
;; if statements as per scheme
;; cond statements as per scheme
;; and or as per scheme
;; #t and #f as per scheme
;; null for null pointer
;; i8* malloc(i64) and free (free overrides on any pointer type - be careful!)
;; (array-ref ptr index) -&gt; where ptr is any pointer, index is any integer and the return type is a de-reference 
;; of the pointer. (i.e. a pointer double* returns a double) - array-ref has an alias aref
;; (array-set! ptr index value) -&gt; where ptr is any pointer, index is any integer, value is a de-reference of 
;; the pointer. (i.e. you set a value of type double in a ptr of type double*), returns the value. 
;; array-set! has an alias aset!
;; (tuple-ref tuple index) -&gt; where tuple is a tuple pointer (tuple*) and index is an integer.  The return type 
;; is the type of the value at tuple index.  tuple-ref has an alias tref.
;; (tuple-set! tuple index value) -&gt; where tuple is a tuple pointer (tuple*) and index is an integer, the value must 
;; be the same type as tuple index.  Returns value.  tuple-set! has an alias tset!
;; (make-tuple type1 type2 type3 ) where type is any valid type.
;; lambda -&gt; as per scheme
;; let -&gt; like scheme let*
;; set! -&gt; as per scheme
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; something simple to start
(define my-sqr
   (lambda (x)
      (* x x)))

;; first we compile the closure my-sqr and define the result
(define my-compiled-sqr (sys:compile my-sqr))
;; now we can call my-compiled-sqr
(my-compiled-sqr 7.0)

;; also runs fine as a normal scheme call
(my-sqr 7.0)

;; print will show us the difference but both do the same thing
;; my-sqr is a scheme closure
;; my-compiled-sqr is an ffi call (x86 code)
(print my-sqr my-compiled-sqr)

;; of course we can use our compiled function anywhere
;; that we could usually use a scheme function
(define proof
   (lambda (x)
      (dotimes (i x)
         (my-compiled-sqr i))
      &quot;done&quot;))

(proof 100)

;; what happens if we try to compile proof
(define my-compiled-proof (sys:compile proof))

;; you should have a compiler warning 
;; this warning basically states that the compiler doesn&apos;t know what &apos;my-compiled-sqr&apos; is
;; this is fare enough as it&apos;s a scheme closure and not native x86 code
;;
;; however the compiler has kindly offered to interpret this expression for us at runtime
;; so we can still call my-compiled-proof

(my-compiled-proof 1000)

;; this is quite slow however, let&apos;s time it with 1000000 iterations
(let ((t (now)))
   (my-compiled-proof 1000000)
   (print &apos;done-in (rational-&gt;real (/ (- (now) t) *samplerate*)) &apos;seconds))

;; however, we can remove the scheme call to my-compiled-sqr by using the compiled
;; version of my-compiled-sqr. Somewhat confusingly this version is called my-sqr.
;; When you called (sys:compile my-sqr) internally the compiler remembers this compiled
;; code by the name of the closure you pass it.
;; Don&apos;t be confused by the fact that there is also a scheme definition of this function.
;; The compiler will always try to use a compiled definiton before using a scheme 
;; definition if possible.  
;;
;;So let&apos;s rewrite and recompile proof using the compiled my-sqr function.
(define proof
   (lambda (x)
      (dotimes (i x)
         (my-sqr i))
      &quot;done&quot;))

;; recompile and redefine my-compiled-proof
(define my-compiled-proof (sys:compile proof))

;; and re-run the performance test
(let ((t (now)))
   (my-compiled-proof 1000000)
   (print &apos;done-in (rational-&gt;real (/ (- (now) t) *samplerate*)) &apos;seconds))

;; wow! that&apos;s quite a difference!
;; So, the moral of the story is try to compile functions without using any scheme
;; interpretation ... and if you must use a scheme call then make sure it&apos;s outside
;; of any tight loops etc...
;; 
;; You can also tell the compiler to expliclty NOT ALLOW scheme calls by calling
;; (sys:compiler-allow-interpreted-code #f).  This will force a compiler error
;; if you try to use calls not understood by the compiler
 

;; So the main purpose of including compilation support in impromptu is for fast
;; data processing.  For the impromptu compiler this means working with the calls
;; objc:data:set* objc:data:get* objc:data:make objc:data:subref

;; a simple little array test
(define data-test
   (lambda (x)
      ;; first create an array of 1000 floats
      (let ((a (objc:data:make (* 1000 4))))
         ;; index our float array by writing in i
         (dotimes (i 1000)
            (objc:data:set-double x i i)
            (objc:data:set-float a i i))
         ;; get a subref of &apos;a&apos; 
         ;; (equivelent to the C code &apos;&amp;a[100]&apos; but increment must be in bytes)
         (define b (objc:data:subref a (* 100 4) (* 900 4)))
         ;; get a subref of &apos;x&apos; 
         ;; (equivelent to the C code &apos;&amp;x[200]&apos; but increment must be in bytes)
         (define c (objc:data:subref x (* 200 8) (* 800 8)))            
         ;; this should return 20000.0
         ;; (i.e. the 101st float value of &apos;a&apos; multiplied by the 201st double value of &apos;x&apos;
         ;; or 100.0 * 200.0)
         (* (objc:data:get-double c 0) (objc:data:get-float b 0)))))

;; first make a data object to pass into data-test
(define my-data (objc:data:make (* 1000 8)))

;; runs fine as a scheme call
(data-test my-data)

;; let&apos;s compile it
(define datatest (sys:compile data-test))
;; and runs fine as compiled code
(datatest my-data)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; We can also do string manipulation
(define string-test
   (lambda (a b)
      (let ((str (string-append a b)))
         (if (string=? str &quot;imprompturocks&quot;)
             (substring str 
                        (* (string-length str) 0.25)
                        (* (string-length str) 0.75))
             (begin (string-set! str 0 48)
                    (string-set! str 2 48)
                    (string-set! str 4 48)
                    str)))))
      
(define string-code (sys:compile string-test))
(string-code &quot;impromptu&quot; &quot;rocks&quot;)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; And a small opengl example
(define *gl* (gl:make-opengl))
(gl:open-opengl *gl* &apos;(200 200 640 480))

(define init
   (lambda ()
      (gl:clear-color *gl* 0.0 0.0 0.0 0.0)
      (gl:enable *gl* *gl:depth-test*)))

(define view
   (lambda ()
      (gl:viewport *gl* 0 0 640 480)
      (gl:matrix-mode *gl* *gl:projection*)
      (gl:load-identity *gl*)
      (glu:perspective *gl* 40.0 (/ 640 480) 1.0 10.0)
      (gl:matrix-mode *gl* *gl:modelview*)))

(define draw
   (lambda (angle gl)     
      (gl:clear gl (+ *gl:depth-buffer-bit* *gl:color-buffer-bit*))
      (gl:load-identity gl)
      (glu:look-at gl (* -5 (cos (* .05 angle))) 0 2 0 0 0 0 1 0)
      (dotimes (i 50)     
         (gl:rotate gl angle 1 .1 1)
         (dotimes (k 50)
            (gl:push-matrix gl)
            (gl:color gl .2 (/ k 50) (/ i 30) 1)
            (gl:rotate gl (* .01 angle k) 0 1.0 1.0)
            (gl:translate gl (/ k 50) (/ k 100) (/ i 20))            
            (glut:wire-cube gl 0.1)
            (gl:pop-matrix gl)))))
      
;; fast as we can
(define draw-loop
   (lambda (angle)
      (gl:lock-context *gl*)
      (draw angle *gl*)
      (gl:unlock-context *gl*)
      (gl:flush *gl*)      
      (callback (now) &apos;draw-loop (fmod (+ angle .25) 360))))

(init)
(view)
(draw-loop 0)

;; redefine draw to a compiled version of itself
(define draw (sys:compile draw))

;; try re-evaluating draw back to a scheme function
;; and then recompile it again :)
</string>
		</array>
		<key>long</key>
		<array>
			<string>The ICR is the most recent addition to the Impromptu family and completely replaces my first aborted attempt at an LLVM compiler for Impromptu (the first impromptu compiler was introduced in 2.0 through the now defunct sys:compile call).  The new compiler is a far more robust and serious attempt at providing low level, but completely dynamic programming support within the Impromptu ecosystem.  It is designed for situations requireing low-level systems style programming in the style of C.  Two primary examples are audio signal processing and opengl programming - both of which require the production of highly efficient code.  While attempting to achieve runtime efficiency the ICR also tries to maintain Impromptu&apos;s love of all things dynamic and is designed to cohexist with the rest of Impromptu&apos;s infrastructure (Scheme, Objective-C, AudioUnits etc..).

It is important to state from the outset that Impromptu&apos;s compiler is NOT a scheme compiler.  It is really its own language.  This language looks like scheme but is in many ways closer to C.  This is for good reason.  The impromptu compiler is designed for purposes that are not suitable for the standard scheme interpreted environment.  Low level tasks that require efficient processing - such as audio signal processing, graphics programming, or general numerical programming.

Unlike Scheme the Impromptu compiler is fully statically typed.  You may not always see the static typing but it is always there in the background.  The reason that you won&apos;t always see the typing is that the compiler includes a type-inferencer that attempts to guess at your types based on static analysis of your code.  Sometimes this works great, sometimes it doesn&apos;t.  When things fail, as they surely will, you are able to explicitly specify types to the compiler.

The Impromptu compiler is a translator which takes input in the form of LISP/Scheme style expressions and translates that input into LLVM&apos;s intermediate representation (IR).  LLVM is a project that supports building compilers.  You can think of LLVM as a kind of CoreAudio, or CoreGraphics, but for compiler builders :)  LLVM&apos;s IR is quite similar to assembly language - it is low level, and general.  Once we have compiled into LLVM IR we can use LLVM to compile into x86 machine code and load this machine code into our runtime environment.  The Impromptu Compiler Runtime (ICR).

It is important to always remember that this runtime is there, and to note it&apos;s distinction from the Scheme runtime.  Impromptu effectively supports three separate language runtimes, Scheme, Objective-C and now the Impromptu compiler runtime (ICR).  There are bridges between these runtimes but they have distinct semantics and it is important to recognise their separation.

One important consideration for the ICR is that it is shared across all Impromptu system threads.  This includes all Scheme processes as well as the audio signal processing chain and OpenGL.  You must therefore take some responsibility for thread safety - if you try to access a function from two different Scheme processes at once you need to be aware of the concurrency issues involved.  In general I try to make it hard (but not impossible) for you to use ICR functions in more than one Scheme process at once.  So don&apos;t panic about this issue, but do keep it in the back of your mind.

As with everything in the Impromptu world, your access to the ICR is through the Scheme interpreter.  Indeed the Impromptu compiler is written in Impromptu Scheme.  You call the compiler through the definec macro.  See examples for a more complete documentation</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(definec name [types] body)</string>
	</dict>
	<key>defined?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>variable</key>
			<string>any valid symbol name</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(defined? sin) =&gt; #t</string>
		</array>
		<key>long</key>
		<array>
			<string>Check to see if variable is bound in environment?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(defined? variable)</string>
	</dict>
	<key>delay</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For delay</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(delay expression)</string>
	</dict>
	<key>denominator</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>rational</key>
			<string>a rational number</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns the denominator of a rational number</string>
		</array>
		<key>returns</key>
		<string>integer</string>
		<key>short</key>
		<string>(denominator rational)</string>
	</dict>
	<key>display</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>object</string>
			<key>port</key>
			<string>optional port</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Write obj to [port] in human style (i.e. not scheme literal)</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(display obj [port])</string>
	</dict>
	<key>dotill</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>alist</key>
			<string>the associative list to set obj for key</string>
			<key>key</key>
			<string>The key to use for replace</string>
			<key>obj</key>
			<string>The obj to set at key in alist</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(dotill (= (length value) 5) (make-list (random 10) &apos;a))</string>
			<string>(dotill (= (length value) 5) (make-list (random 100) &apos;a) 10)</string>
		</array>
		<key>long</key>
		<array>
			<string>Keep running the expression until predicate is matched or until max-iterations is reached.  If predicate is matched the result of the final expression (i.e. value) is returned. If max-iterations is reached the symbol failed will be returned. The result of evaluating expression is bound to value on each iterations so your predicate may use value to retrieve the result.  check the examples for example usage.  max-iterations is optional and defaults to 10000000</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>The result of the final evaluation of expression or &apos;failed if max-iterations is reached first</string>
		<key>short</key>
		<string>(dotill predicate expression [max-iterations])</string>
	</dict>
	<key>dotimes</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>form</key>
			<string>one or more forms</string>
			<key>num</key>
			<string>number of times forms are evaulated</string>
			<key>var</key>
			<string>a variable to be used in any form</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(dotimes (i 5)</string>
			<string>   (print i)</string>
			<string>   (print (* i i)))</string>
		</array>
		<key>long</key>
		<array>
			<string>A form that calls forms num times incrementing the variable var from 0 to num - 1</string>
		</array>
		<key>returns</key>
		<string>last form evaluated</string>
		<key>short</key>
		<string>(dotimes (var num) form ...)</string>
	</dict>
	<key>dump-stack</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Return the current stack</string>
		</array>
		<key>returns</key>
		<string>stack</string>
		<key>short</key>
		<string>(dump-stack)</string>
	</dict>
	<key>environment?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>any valid scheme object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Predicate check if obj is an environment</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(environment? obj)</string>
	</dict>
	<key>eof-object?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>any valid scheme object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Predicate check for eof object</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(eof-object? obj)</string>
	</dict>
	<key>eq?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj1</key>
			<string>any valid scheme object</string>
			<key>obj2</key>
			<string>any valid scheme object</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(eq? &apos;a &apos;a)               =&gt; #t</string>
			<string>(eq? (list &apos;a) (list &apos;a)) =&gt; #f</string>
		</array>
		<key>long</key>
		<array>
			<string>Check to see if two objects are the same (i.e. share the same reference).  eq? is the most strigent of the equality checks</string>
		</array>
		<key>related</key>
		<string>equal? eqv?</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(eq? obj1 obj2)</string>
	</dict>
	<key>equal?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj1</key>
			<string>any valid scheme object</string>
			<key>obj2</key>
			<string>any valid scheme object</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(equal? &apos;a &apos;a)			   =&gt; #t</string>
			<string>(equal? (list &apos;a) (list &apos;a)) =&gt; #t</string>
		</array>
		<key>long</key>
		<array>
			<string>Check to see if two objects are similar.  equal? is the weakest of the equality checks</string>
		</array>
		<key>related</key>
		<string>eq? eqv?</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(equal? obj1 obj2)</string>
	</dict>
	<key>eqv?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj1</key>
			<string>any valid scheme object</string>
			<key>obj2</key>
			<string>any valid scheme object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>check for equivelence</string>
		</array>
		<key>related</key>
		<string>equal? eq?</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(eqv? obj1 obj2)</string>
	</dict>
	<key>error</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>any valid scheme object</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(error &quot;this is an error&quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>Throws an error condition and returns string representation of obj</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(error obj)</string>
	</dict>
	<key>eval</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>expr</key>
			<string>the expression to evaluate</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(eval &apos;(* 3 4))  =&gt; 12</string>
			<string>(define a 12)</string>
			<string>(eval &apos;a)        =&gt; 12</string>
		</array>
		<key>long</key>
		<array>
			<string>Evaluate an expression and return its value</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(eval expr)</string>
	</dict>
	<key>even?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>integer</key>
			<string>integer</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(even? 4) =&gt; #t</string>
		</array>
		<key>long</key>
		<array>
			<string>Is integer even</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(even? integer)</string>
	</dict>
	<key>exact-&gt;inexact</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>No Description For exact-&gt;inexact</string>
		</array>
		<key>returns</key>
		<string>number</string>
		<key>short</key>
		<string>(exact-&gt;inexact num)</string>
	</dict>
	<key>exact?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>No Description For exact?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(exact? num)</string>
	</dict>
	<key>exp</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>num</key>
			<string>number</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>bass-e exponential of num</string>
		</array>
		<key>returns</key>
		<string>real</string>
		<key>short</key>
		<string>(exp num)</string>
	</dict>
	<key>expt</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>n1</key>
			<string>bass</string>
			<key>n2</key>
			<string>power</string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Returns n1 raised to the power n2</string>
		</array>
		<key>returns</key>
		<string>number</string>
		<key>short</key>
		<string>(expt n1 n2)</string>
	</dict>
	<key>floor</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>No Description For floor</string>
		</array>
		<key>returns</key>
		<string>number</string>
		<key>short</key>
		<string>(floor num)</string>
	</dict>
	<key>fmod</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>num1</key>
			<string></string>
			<key>num2</key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string>(fmod 73 12) =&gt; 1</string>
		</array>
		<key>long</key>
		<array>
			<string>Floating point remainder function of num1/num2.  Note that at the moment impromptu rounds to 4 decimal places to try to avoid some floating point precision problems.</string>
		</array>
		<key>returns</key>
		<string>number</string>
		<key>short</key>
		<string>(fmod num1 num2)</string>
	</dict>
	<key>foldr</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For foldr</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(foldr)</string>
	</dict>
	<key>foo</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For foo</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(foo)</string>
	</dict>
	<key>for-each</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For for-each</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(for-each)</string>
	</dict>
	<key>force</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For force</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(force)</string>
	</dict>
	<key>gcd</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For gcd</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gcd)</string>
	</dict>
	<key>generic-assoc</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For generic-assoc</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(generic-assoc)</string>
	</dict>
	<key>generic-member</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For generic-member</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(generic-member)</string>
	</dict>
	<key>gensym</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Generate and return a new symbol guaranteed to be unquie</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gensym)</string>
	</dict>
	<key>get</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>key</key>
			<string>a symbol key for property list</string>
			<key>sym1</key>
			<string>this symbols property list</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define test 100)</string>
			<string>(put &apos;test &apos;val 50)</string>
			<string>(get &apos;test &apos;val) =&gt; 50</string>
		</array>
		<key>long</key>
		<array>
			<string>get value from symbol property list</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(get sym1 key)</string>
	</dict>
	<key>get-closure-code</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string>(get-closure-code io:midi-out) =&gt; (lambda (time event channel a b) (call-cpp time *io:midi-out* event channel a b))</string>
		</array>
		<key>long</key>
		<array>
			<string>Return closure as expression</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(get-closure-code closure)</string>
	</dict>
	<key>get-named-arg</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>args</key>
			<string>list of arguments</string>
			<key>default-value</key>
			<string>optional return value if named arg does not exist</string>
			<key>name</key>
			<string>symbol name marking argument</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Get named argument from args</string>
		</array>
		<key>returns</key>
		<string>scheme object</string>
		<key>short</key>
		<string>(get-named-arg name args [default-value])</string>
	</dict>
	<key>getp</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>audiounit</string>
			<key>id</key>
			<string>au parameter id</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>macro for au:get-param. gets audiounits global parameter id</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(setp au id value [duration])</string>
	</dict>
	<key>gfx:add-arc</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>clockwise?</key>
			<string>if true move clockwise - default is anticlockwise</string>
			<key>end</key>
			<string>The end of the arc in degrees</string>
			<key>path</key>
			<string>The path to append this arc to</string>
			<key>radius</key>
			<string>The radius of the arc</string>
			<key>start</key>
			<string>The start of the arc in degrees</string>
			<key>x</key>
			<string>x centre point</string>
			<key>y</key>
			<string>y centre point</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define *canvas* (gfx:make-canvas &apos;(100 100 600 600))</string>
			<string>(define *path* (gfx:make-path))</string>
			<string>; start arc at 12oclock finish at 6oclock</string>
			<string>; start at end of path with radius 50</string>
			<string>(define *point* (gfx:get-path-point *path*))</string>
			<string>(add-arc *path* (car *point*) (cons *point*) 50
	  1.5708 4.7124)</string>
			<string>(gfx:draw-path (now) *canvas* *path* &apos;(0 0 1 1) &apos;(1 0 0
	  1) 10.0)</string>
		</array>
		<key>long</key>
		<array>
			<string>Appends an arc to the given path. be aware that the x and y coordinates are the centre of the arc.  if you are adding to an existing path there will be a line drawn from the last point defined. this goes for the set-start-point function as well that you may not want to use with add-arc.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:add-arc path x y radius start end [clockwise?])</string>
	</dict>
	<key>gfx:add-curve</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>cx1</key>
			<string>x coordinate of control point one</string>
			<key>cx2</key>
			<string>x coordinate of control point two</string>
			<key>cy1</key>
			<string>y coordinate of control point one</string>
			<key>cy2</key>
			<string>y coordinate of control point two</string>
			<key>path</key>
			<string>The path to append the curve too</string>
			<key>x</key>
			<string>Extends curve to x</string>
			<key>y</key>
			<string>Extends curve to y</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define *canvas* (gfx:make-canvas &apos;(100 100 600 600))</string>
			<string>(define *path* (gfx:make-path))</string>
			<string>(gfx:set-start-point *path* 100 100)</string>
			<string>(gfx:add-curve *path* 200 200 240 120 100 290)</string>
			<string>(gfx:draw-path (now) *canvas* *path* &apos;(0 0 1 1) &apos;(1 0 0
	  1) 10.0)</string>
		</array>
		<key>long</key>
		<array>
			<string>Appends a curve to the given path where the curve
	  uses two control points and extends from the current end
	  point to x,y.  See core graphics CGPathAddCurveToPoint for
	  more information.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:add-curve path x y cx1 cy1 cx2 cy2)</string>
	</dict>
	<key>gfx:add-glyphs</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>glyphs</key>
			<string>A list of glyph indexes (integers)</string>
			<key>path</key>
			<string>Bezier path to append text to</string>
			<key>text-style</key>
			<string>The font to use for rendering the string</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define *canvas* (gfx:make-canvas &apos;(0 0 800 600)))</string>
			<string>(define *text-style* (gfx:make-text-style &quot;Times-Roman&quot; 72.0 (list 1.0 1.0 1.0 0.25)))</string>
			<string>(define *path* (gfx:make-path))</string>
			<string>(gfx:set-start-point *path* 150 250)</string>
			<string>(gfx:add-glyphs *path* *text-style* &apos;(10 20 30 40))</string>
			<string>(gfx:draw-path (now) *canvas* *path* &apos;(1 0 0 1) &apos;())</string>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Appends a series of glyphs (specified as integer indexes in the list glyphs).  The glyphs are
	  converted into a bezier path before being appended to the
	  given path.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:add-glyphs path text-style glyphs)</string>
	</dict>
	<key>gfx:add-line</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>path</key>
			<string>The path to append the line to</string>
			<key>x</key>
			<string>x coordinate to extend path to</string>
			<key>y</key>
			<string>y coordinate to extend path to</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define *canvas* (gfx:make-canvas &apos;(100 100 600 600)))</string>
			<string>(define *path* (gfx:make-path))</string>
			<string>(set-start-point *path* 0 0)</string>
			<string>(add-line *path* 200 200)</string>
			<string>(gfx:draw-path (now) *canvas* *path* &apos;(0 0 1 1) &apos;(1 0 0
	  1) 10.0 *whole-path*)</string>
		</array>
		<key>long</key>
		<array>
			<string>Appends a line to the end of the given path</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:add-line path x y)</string>
	</dict>
	<key>gfx:add-oval</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>height</key>
			<string>Height of rectangle used to contrain oval</string>
			<key>path</key>
			<string>The path to append oval too</string>
			<key>width</key>
			<string>Width of rectangle used to contrain oval</string>
			<key>x</key>
			<string>x coordinate to append oval</string>
			<key>y</key>
			<string>y coordinate to append oval</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define *canvas* (gfx:make-canvas &apos;(100 100 600 600)))</string>
			<string>(define *path* (gfx:make-path))</string>
			<string>(gfx:set-start-point *path* 0 0)</string>
			<string>(gfx:add-oval *path* 100 100 300 100)</string>
			<string>(gfx:draw-path (now) *canvas* *path* &apos;(0 0 1 1) &apos;(1 0 0
	  1) 10.0 *whole-path*)</string>
		</array>
		<key>long</key>
		<array>
			<string>Appends an oval to x y coordinates of the given
	  path.  The oval is constrained to the bounds of the
	  rectangle specified by width and height.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:add-oval path x y width height)</string>
	</dict>
	<key>gfx:add-path</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>new-path</key>
			<string>path</string>
			<key>path</key>
			<string>path</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Appends new-path to path</string>
		</array>
		<key>returns</key>
		<string>bool</string>
		<key>short</key>
		<string>(gfx:add-path path new-path)</string>
	</dict>
	<key>gfx:add-rect</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>h</key>
			<string>height of rectangle</string>
			<key>path</key>
			<string>The path to append the curve too</string>
			<key>w</key>
			<string>width of rectangle</string>
			<key>x</key>
			<string>x</string>
			<key>y</key>
			<string>y</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Appends a rectangle to the given path
	  point to x,y.  See core graphics CGPathAddCurveToPoint for
	  more information.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:add-rect path x y w h)</string>
	</dict>
	<key>gfx:add-rounded-rect</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>h</key>
			<string>height of rectangle</string>
			<key>path</key>
			<string>The path to append the curve too</string>
			<key>w</key>
			<string>width of rectangle</string>
			<key>x</key>
			<string>x</string>
			<key>x-radius</key>
			<string>radius of rounded corner</string>
			<key>y</key>
			<string>y</string>
			<key>y-radius</key>
			<string>radius of rounded corner</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Appends a rounded rectangle to the given path
	  point to x,y.  See core graphics CGPathAddCurveToPoint for
	  more information.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:add-rounded-rect path x y w h x-radius y-radius)</string>
	</dict>
	<key>gfx:add-text</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>path</key>
			<string>Bezier path to append text to</string>
			<key>s</key>
			<string>The string to append to the bezier path</string>
			<key>text-style</key>
			<string>The font to use for rendering the string</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define *canvas* (gfx:make-canvas &apos;(0 0 800 600)))</string>
			<string>(define *text-style* (gfx:make-text-style &quot;Times-Roman&quot; 72.0 (list 1.0 1.0 1.0 0.25)))</string>
			<string>(define *path* (gfx:make-path))</string>
			<string>(gfx:set-start-point *path* 150 250)</string>
			<string>(gfx:add-text *path* *text-style* &quot;impromptu&quot;)</string>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Appends a string (scheme string or NSString) to the given path.  The string is
	  converted into a bezier path before being appended to the
	  given path.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:add-text path text-style s)</string>
	</dict>
	<key>gfx:apply-filter</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>filter</key>
			<string>The filter to apply</string>
			<key>image</key>
			<string>Optional image to apply filter too.  you will only not supply this argument if you are using a generator filter</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define gl (gl:make-opengl))
(gl:open-opengl gl (list 0 0 640 480))

(define mov (gfx:load-movie &quot;/Volumes/Macintosh HD 2/ss-Mobile.mov&quot;))

(define f1 (gfx:make-filter &quot;CIBloom&quot;))

(define loop
   (lambda (beat) 
      (let* ((i1 (objc:r (gfx:get-live-frame)))
             (i2 (objc:r (gfx:apply-filter f1 i1)))
             (i3 (objc:r (gfx:get-movie-frame mov (cosr 3 3 1/2)))))
         (gfx:set-filter-param f1 &quot;inputIntensity&quot; (cosr 2 2 1))
         (gfx:image2image i3 i2 .5 (list 0 0 640 480)) 
         (gl:draw-ciimage gl i2)
         (gl:flush gl)
         (callback (*metro* (+ beat (* 1/2 1/12))) &apos;loop (+ beat 1/12)))))

(loop (*metro* &apos;get-beat 4))</string>
		</array>
		<key>long</key>
		<array>
			<string>Appends a string to the given path.  The string is
	  converted into a bezier path before being appended to the
	  given path.</string>
		</array>
		<key>returns</key>
		<string>ciimage</string>
		<key>short</key>
		<string>(gfx:apply-filter filter [ciimage])</string>
	</dict>
	<key>gfx:cache-movie</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>end</key>
			<string>the time in the movie you want to stolp caching at (defaults to the end)</string>
			<key>movie</key>
			<string>the movie you want to cache</string>
			<key>start</key>
			<string>the time in the movie you want to start caching from (defaults to the start)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Decompresses the supplied movie and caches the result into a movie-cache that is returned to the user. You can then pass movie-cache to gfx:get-cached-frame to retrieve a movie frame just as you would normarlly use gfx:get-movie-frame. You can supply start and end values in seconds if you only want to cache a part of the movie.</string>
		</array>
		<key>returns</key>
		<string>movie-cache (NSArray)</string>
		<key>short</key>
		<string>(gfx:cache-movie movie [start] [end])</string>
	</dict>
	<key>gfx:canvas-key-down</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>char</key>
			<string>scheme character</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>The character pressed.  The default implementation of gfx:canvas-key-down sets a global variable *io:key*</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>bool</string>
		<key>short</key>
		<string>(gfx:canvas-key-down char)</string>
	</dict>
	<key>gfx:canvas-key-up</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>char</key>
			<string>scheme character</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>The character pressed</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>bool</string>
		<key>short</key>
		<string>(gfx:canvas-key-up char)</string>
	</dict>
	<key>gfx:capture-canvas</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>canvas</key>
			<string>canvas to capture</string>
			<key>file</key>
			<string>fully qulified path to file to save canvas to</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define movie-capture</string>
			<string>   (lambda (time inc cnt)</string>
			<string>      (gfx:capture-canvas canvas (string-append &quot;/tmp/throb_&quot; (number-&gt;string cnt) &quot;.png&quot;))</string>
			<string>      (if (&lt; cnt 100) </string>
			<string>          (callback (+ time inc) &apos;movie-capture (+ time inc) inc (+ cnt 1)))))</string>
		</array>
		<key>long</key>
		<array>
			<string>Captures canvas as a png to file.</string>
		</array>
		<key>related</key>
		<string>gfx:capture-image gfx:start-pdf-capture gfx:stop-pdf-capture au:start-audio-capture au:stop-audio-capture</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:capture-canvas canvas file)</string>
	</dict>
	<key>gfx:capture-image</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>file</key>
			<string>fully qualifed file to store png data</string>
			<key>image</key>
			<string>an impromptu bitmap image</string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Capture image in png format to file.</string>
		</array>
		<key>related</key>
		<string>gfx:capture-canvas gfx:start-pdf-capture gfx:stop-pdf-capture</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:capture-image image file)</string>
	</dict>
	<key>gfx:clear-canvas</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>canvas</key>
			<string>the canvas to clear</string>
			<key>colour</key>
			<string>optional colour to clear with (where colour is an (r g b a) list)</string>
			<key>time</key>
			<string>time in samples</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(gfx:clear-canvas (now) *canvas*)</string>
			<string>(gfx:clear-canvas (now) *canvas* &apos;(0 0.24 0.5 1.0))</string>
		</array>
		<key>long</key>
		<array>
			<string>Clears the entire canvas (totally transparent) or to a colour if provided.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:clear-canvas time canvas [colour])</string>
	</dict>
	<key>gfx:clear-image</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>colour</key>
			<string>optional colour argument (default is transparent)</string>
			<key>image</key>
			<string>image to clear</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(gfx:clear-image image)</string>
			<string>(gfx:clear-image image &apos;(0.1 0.4 0.9 1.0))</string>
		</array>
		<key>long</key>
		<array>
			<string>Clear entire image to 100% transparent or use colour if supplied</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:clear-image image [colour])</string>
	</dict>
	<key>gfx:close-canvas</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>canvas</key>
			<string>canvas whos window you want to close</string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Closes the canvas window. Can be reopended by calling gfx:open-canvas</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:close-canvas canvas)</string>
	</dict>
	<key>gfx:close-path</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>path</key>
			<string>close off path</string>
		</dict>
		<key>examples</key>
		<array>
			<string>; create and return a square path object</string>
			<string>(define (gfx:make-square x y size)</string>
			<string>   (let ((path (gfx:make-path)))</string>
			<string>      (gfx:set-start-point path x y)</string>
			<string>      (gfx:add-line path x (+ y size))</string>
			<string>      (gfx:add-line path (+ x size) (+ y size))</string>
			<string>      (gfx:add-line path (+ x size) y)</string>
			<string>      (gfx:add-line path x y)</string>
			<string>	  (gfx:close-path path)</string>
			<string>      path))</string>
		</array>
		<key>long</key>
		<array>
			<string>Closes off a path.  Not required if drawing a simple path.  It is required to complete the construction of a complex path (i.e. a path that contains other paths).</string>
		</array>
		<key>related</key>
		<string>gfx:make-path gfx:set-start-point gfx:add-line gfx:add-curve gfx:add-arc gfx:make-oval gfx:gfx:make-circle</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:close-path path)</string>
	</dict>
	<key>gfx:convert-image</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>image</key>
			<string>The image to convert (can be either a coreimage or bitmap image)</string>
			<key>type</key>
			<string>Optional string argument for the format of the image to convert into.  one of &quot;ARGB&quot; (UInt8 - default) &quot;RGBA&quot; (UInt8) &quot;ARGBF&quot; (Float32) &quot;RGBAF&quot; (Float32) or &quot;CI&quot; (CoreImage)</string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Converts an image (either ciimage or nsimage) into it&apos;s reverse (i.e. nsimage or ciimage)</string>
		</array>
		<key>returns</key>
		<string>ciimage or nsimage depending on input type</string>
		<key>short</key>
		<string>(gfx:convert-image image [format])</string>
	</dict>
	<key>gfx:debug-graphics</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>bool</key>
			<string>#t or #f</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>When set to true prints a red bounds marking around each screen update (i.e. shows the bounds of the update)</string>
		</array>
		<key>returns</key>
		<string>bool</string>
		<key>short</key>
		<string>(gfx:debug-graphics bool)</string>
	</dict>
	<key>gfx:destroy-movie</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>movie</key>
			<string>The movie to destroy</string>
			<key>time</key>
			<string>time in samples to destroy movie</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Destory movie and reclaim memory at time.  Movies DO need to be destroyed, the will not be GC&apos;d</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:destroy-movie time movie)</string>
	</dict>
	<key>gfx:draw-group</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>canvas</key>
			<string>the canvas to draw to</string>
			<key>fills</key>
			<string>a flat vector of fill colours</string>
			<key>paths</key>
			<string>a vector of paths to draw</string>
			<key>strokes</key>
			<string>a flat vector of stroke colours</string>
			<key>styles</key>
			<string>a vector of style values</string>
			<key>time</key>
			<string>time to draw group</string>
			<key>widths</key>
			<string>a vector of width values</string>
		</dict>
		<key>examples</key>
		<array>
			<string>; set up graphics including vectors for paths, points, colours, styes etc.</string>
			<string>(define canvas (gfx:make-canvas))</string>
			<string>(gfx:clear-canvas (now) canvas &apos;(0 0 0 1)) ; black background </string>
			<string>(define nodes 200) ; number of squares to animate </string>
			<string>(define size 5) ; square size </string>
			<string>; setup paths at random coordinates between 100,100 and 200,200</string>
			<string>(define paths (make-vector-proc nodes</string>
			<string>                                (lambda (i)</string>
			<string>                                   (gfx:make-square (random 100 200)</string>
			<string>                                                    (random 100 200)</string>
			<string>                                                    size))))</string>
			<string>; defaults for drawing path group</string>
			<string>(define widths (make-vector nodes 1.0))</string>
			<string>(define styles (make-vector nodes *gfx:stroke-path*)) ; stroke only </string>
			<string>; setup default colours </string>
			<string>(define fills (make-vector (* nodes 4))) ; we are not going to fill </string>
			<string>(define strokes (make-vector (* nodes 4)))</string>
			<string>(vector= strokes 1.0 (list 0 nodes 4)) ; set red to 1.0 </string>
			<string>(vector-rand strokes (list 1 nodes 4)) ; randomize green </string>
			<string>(vector= strokes 0.0 (list 2 nodes 4)) ; set blue to 0.0 </string>
			<string>(vector= strokes 0.3 (list 3 nodes 4)) ; set alpha to 0.3 </string>
			<string>; main animation loop</string>
			<string>; NOTE: we could declare xpoints and ypoints globally and</string>
			<string>; resuse these each time through loop in order to avoid</string>
			<string>; constantly reallocating vector memory </string>
			<string>(define loop</string>
			<string>   (lambda (time)</string>
			<string>      (let ((xpoints (make-vector nodes))</string>
			<string>            (ypoints (make-vector nodes)))</string>
			<string>         (vector-rand xpoints) </string>
			<string>         (vector- xpoints 0.5) </string>
			<string>         (vector* xpoints 20.0)</string>
			<string>         (vector-rand ypoints)</string>
			<string>         (vector- ypoints 0.5)</string>
			<string>         (vector* ypoints 20.0)</string>
			<string>         (gfx:move-group time paths xpoints ypoints)</string>
			<string>         (gfx:draw-group (+ time 5) canvas paths strokes fills widths styles)</string>
			<string>         (callback (+ time 1000) &apos;loop (+ time 4410)))))</string>
			<string>; start </string>
			<string>(loop (now))</string>
		</array>
		<key>long</key>
		<array>
			<string>Draws a group of paths where paths is a vector of paths. strokes fills widths and styles are all flat vectors corresponding to paths. Fills and Strokes are flat vectors rgba.</string>
		</array>
		<key>related</key>
		<string>gfx:draw-image gfx:draw-path</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:draw-group time canvas paths strokes fills widths styles)</string>
	</dict>
	<key>gfx:draw-image</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>alpha</key>
			<string>the amount of transparency to apply between 0 and 1</string>
			<key>canvas</key>
			<string>canvas to draw to</string>
			<key>dest-bounds</key>
			<string>optional bounds to draw image into. of list form (x y w h) where w and h are optional</string>
			<key>image</key>
			<string>image to draw (can be either an nsimage or a ciimage)</string>
			<key>src-bounds</key>
			<string>optional bounds to take image data from.  of list form (x y w h) where w and h are optional</string>
			<key>time</key>
			<string>time in samples to draw image to canvas</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define canvas (gfx:make-canvas))</string>
			<string></string>
			<string>; make sure you set the string to a movie location on your system</string>
			<string>(define movie (gfx:load-movie &quot;/tmp/myfilm.mov&quot;))</string>
			<string>(define frame-length (* *second* 0.041))</string>
			<string></string>
			<string>(define mlgth (- (gfx:get-movie-duration movie) 1.0))</string>
			<string></string>
			<string>(define loop</string>
			<string>   (lambda (time mtime)</string>
			<string>      (let ((image (gfx:convert-image (gfx:get-movie-frame movie mtime))))</string>
			<string>         (gfx:draw-image time canvas image 0.5 (list (random -100 500) </string>
			<string>                                                     (random -100 500)</string>
			<string>                                                     (random 0 500)</string>
			<string>                                                     (random 0 500)))</string>
			<string>         ; advance time by a 24th of a second</string>
			<string>         (set! time (+ time frame-length))</string>
			<string>         (if (&lt; mtime mlgth)</string>
			<string>             (callback (- time 1500) &apos;loop time (+ mtime 0.041))))))</string>
			<string></string>
			<string>(loop (now) 0.0)	</string>
		</array>
		<key>long</key>
		<array>
			<string>Draw image to canvas with an alpha transparency between 0 and 1 (transparency argument is ignored for CIImages).  Optional destination bounds and source bounds can be added (defaults to source size at destination coordinate 0,0).  Source and destination bounds will resize image if required.</string>
		</array>
		<key>related</key>
		<string>gfx:draw-path gfx:draw-group</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:draw-image time canvas image alpha [dest-bounds] [src-bounds])</string>
	</dict>
	<key>gfx:draw-line</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>canvas</key>
			<string>graphics canvas to draw to</string>
			<key>colour</key>
			<string>list rgba</string>
			<key>time</key>
			<string>time in samples</string>
			<key>x1</key>
			<string>number</string>
			<key>x2</key>
			<string>number</string>
			<key>y1</key>
			<string>number</string>
			<key>y2</key>
			<string>number</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>draws a line on the canvas from the point x1,y1 to the point x2,y2</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:draw-line time canvas x1 y1 x2 y2 colour)</string>
	</dict>
	<key>gfx:draw-path</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>canvas</key>
			<string>canvas to draw to</string>
			<key>fill</key>
			<string>fill colour (r g b a). an empty list will stop the fill. the symbol stencil will remove the fill (i.e. transparent)</string>
			<key>path</key>
			<string>path to draw</string>
			<key>stroke</key>
			<string>stroke colour (r g b a). an emptly list will stop the stroke. the symbol stencil will remove the stroke (i.e. transparent)</string>
			<key>stroke-width</key>
			<string>optional stroke width. defaults to 1.0</string>
			<key>time</key>
			<string>time to draw at</string>
		</dict>
		<key>examples</key>
		<array>
			<string>; stroke and fill with default width</string>
			<string>(gfx:draw-path (now) *canvas* *square* &apos;(0.3 0.4 0.5 1.0) &apos;(1.0 0.2 0.4 0.5))</string>
			<string>; just fill</string>
			<string>(gfx:draw-path (now) *canvas* *square* &apos;() &apos;(1.0 0.2 0.4 0.5))</string>
			<string>; just stroke with width 4.0</string>
			<string>(gfx:draw-path (now) *canvas* *square* &apos;(0.3 0.4 0.5 1.0) &apos;() 4.0)</string>
			<string>; cut out a square stencil</string>
			<string>(gfx:draw-path (now) *canvas* *square* &apos;stencil &apos;stencil 4.0)</string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For gfx:draw-path</string>
		</array>
		<key>related</key>
		<string>gfx:draw-image</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:draw-path time canvas path stroke fill [stroke-width])</string>
	</dict>
	<key>gfx:draw-text</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>bounds</key>
			<string>a list of &apos;(x y) or &apos;(x y w h)</string>
			<key>canvas</key>
			<string>the canvas to draw to</string>
			<key>font-style</key>
			<string>the font-style to use</string>
			<key>string</key>
			<string>the string to draw (scheme string or NSString)</string>
			<key>time</key>
			<string>time in samples to draw string</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define canvas (gfx:make-canvas))</string>
			<string></string>
			<string>; change the path to the movie file to suit your computer</string>
			<string>(define movie (gfx:load-movie &quot;/tmp/myfilm.mov&quot;))</string>
			<string>(define mlgth (- (gfx:get-movie-duration movie) 1.0))</string>
			<string>(define frame-length (* *second* 0.1))</string>
			<string>(define font-style (gfx:make-text-style &quot;Times-Roman&quot; 250.0 (list 1.0 1.0 1.0 0.25)))</string>
			<string></string>
			<string>(define loop</string>
			<string>   (lambda (time mtime)</string>
			<string>      (let ((image (gfx:get-movie-frame movie mtime)))</string>
			<string>         ;; to avoid slight flicker use the text2image line below instead of</string>
			<string>         ; the draw-text line. It will composit the text and image before</string>
			<string>         ; drawing to the screen.</string>
			<string>         ; (gfx:text2image (number-&gt;string mtime) image font-style &apos;(0 120))</string>
			<string>         (gfx:draw-image time canvas image 1.0)</string>
			<string>         (gfx:draw-text time canvas (number-&gt;string mtime) font-style &apos;(0 120))</string>
			<string>         (set! time (+ time frame-length))</string>
			<string>         (if (&lt; mtime mlgth)</string>
			<string>             (callback (- time 4000) &apos;loop time (+ mtime 0.1))))))</string>
			<string></string>
			<string>(loop (now) 0.0)</string>
			<string>; the loop will stop when the end of the movie is reached	</string>
		</array>
		<key>long</key>
		<array>
			<string>Draw string (scheme string or NSString) to canvas using font-style at bounds</string>
		</array>
		<key>related</key>
		<string>gfx:text2image gfx:add-text</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:draw-text time canvas string font-style bounds)</string>
	</dict>
	<key>gfx:filter-image</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>filter-name</key>
			<string>filter-name as string</string>
			<key>image</key>
			<string>image to filter</string>
			<key>params</key>
			<string>the parameter list for the filter</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define canvas (gfx:make-canvas))</string>
			<string>(define movie (gfx:load-movie &quot;/tmp/myfilm.mov&quot;))</string>
			<string>(define params &apos;((&quot;inputIntensity&quot; . 5)))</string>
			<string>(define lgth (- (gfx:get-movie-duration movie) 1.0))</string>
			<string>(define frame-length (* *second* 0.1))</string>
			<string></string>
			<string>(define loop</string>
			<string>   (lambda (time movie-time)</string>
			<string>      (let* ((image (gfx:convert-image (gfx:get-movie-frame movie movie-time)))</string>
			<string>             (filtered-image (gfx:filter-image image &quot;CIEdges&quot; params)))</string>
			<string>         (gfx:draw-image time canvas filtered-image 1.0 &apos;(75 150))</string>
			<string>         (set! time (+ time frame-length))</string>
			<string>         (if (&gt; movie-time lgth)</string>
			<string>             (callback (- time 4000) &apos;loop time 0.0)</string>
			<string>             (callback (- time 4000) &apos;loop time (+ movie-time 0.1))))))</string>
			<string></string>
			<string>(loop (now) 0.0)</string>
		</array>
		<key>long</key>
		<array>
			<string>DEPRECATED! (replaced by gfx:apply-filter, gfx:make-filter and gfx:set-filter-param)\nFilter image using CoreImage filter. Params is an assoc list of pairs with a car of the parameters name and a cdr of the parameters value. See examples for more.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:filter-image image filter-name params)</string>
	</dict>
	<key>gfx:flip-image</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>image</key>
			<string>the image to flip</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns a new bitmap image flipped vertically (useful for opengl pixmaps and textures)</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>NSBitmapImageRep</string>
		<key>short</key>
		<string>(gfx:flip-image image)</string>
	</dict>
	<key>gfx:get-cached-frame</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>movie-cache</key>
			<string>a movie cache as returned by gfx:cache-movie (movie-cache is an NSArray)</string>
			<key>time</key>
			<string>an image time seconds into the cache</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns an image from the movie-cache at time (in seconds)</string>
		</array>
		<key>returns</key>
		<string>image</string>
		<key>short</key>
		<string>(gfx:get-cached-frame movie-cache time)</string>
	</dict>
	<key>gfx:get-canvas-bounds</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>canvas</key>
			<string>the canvas who&apos;s dimensions we want</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>returns the bounds (x y w h) of the canvas window</string>
		</array>
		<key>returns</key>
		<string>bounds (x y w h)</string>
		<key>short</key>
		<string>(gfx:get-canvas-bounds canvas)</string>
	</dict>
	<key>gfx:get-canvas-size</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>canvas</key>
			<string>the canvas who&apos;s dimensions we want</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(gfx:get-canvas-size (gfx:make-canvas)) =&gt; (578 . 600)</string>
		</array>
		<key>long</key>
		<array>
			<string>get the width and height of this canvas as a dotted pair</string>
		</array>
		<key>returns</key>
		<string>pair</string>
		<key>short</key>
		<string>(gfx:get-canvas-size canvas)</string>
	</dict>
	<key>gfx:get-code-image</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns a bitmap image of the current scheme editor window. Note that if you want the returned image to include an alpha channel your editor window needs to be slightly transparent (by default impromptu does do this).</string>
		</array>
		<key>returns</key>
		<string>NSBitmapImageRep</string>
		<key>short</key>
		<string>(gfx:get-code-image)</string>
	</dict>
	<key>gfx:get-display-resolution</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>display</key>
			<string>The display number to get resolution of</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns a cons pair representing the width and height of the current display.</string>
		</array>
		<key>returns</key>
		<string>cons pair</string>
		<key>short</key>
		<string>(gfx:get-display-resolution display-number)</string>
	</dict>
	<key>gfx:get-filter-param</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>filter</key>
			<string>CIFilter object</string>
			<key>param</key>
			<string>Param name as scheme string (&quot;inputIntensity&quot; for example)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns the value of a given filter parameter (&quot;inputIntensity&quot; in CIBloom for example)</string>
		</array>
		<key>returns</key>
		<string>value of filter param</string>
		<key>short</key>
		<string>(gfx:get-filter-param filter param)</string>
	</dict>
	<key>gfx:get-image-data</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>image</key>
			<string>a bitmap image (NSBitmapImageRep)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Return an NSData object which references the bitmap data of the image.  This is a reference only so don&apos;t let the original image get garbage collected while you&apos;re still using the NSData object returned from this function.</string>
		</array>
		<key>returns</key>
		<string>NSData</string>
		<key>short</key>
		<string>(gfx:get-image-data image)</string>
	</dict>
	<key>gfx:get-image-dpi</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>image</key>
			<string>image</string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Returns the resultion of the image in dots per inch - this is usually 72 dpi for monitors or 300 dpi for print.</string>
		</array>
		<key>returns</key>
		<string>pair</string>
		<key>short</key>
		<string>(gfx:get-image-dpi image)</string>
	</dict>
	<key>gfx:get-image-from-canvas</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>canvas|opengl</key>
			<string>a canvas or opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns a new bitmap image whose contents is the current state of canvas or an opengl instance</string>
		</array>
		<key>related</key>
		<string>gl:get-image-from-opengl</string>
		<key>returns</key>
		<string>image</string>
		<key>short</key>
		<string>(gfx:get-image-from-canvas canvas|opengl)</string>
	</dict>
	<key>gfx:get-image-from-screen</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>bounds</key>
			<string>a scheme list (x y w h)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>returns an image taken from the screen at bounds (x y w h)</string>
		</array>
		<key>returns</key>
		<string>image</string>
		<key>short</key>
		<string>(gfx:get-image-from-screen bounds)</string>
	</dict>
	<key>gfx:get-image-from-window</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>window</key>
			<string>an NSWindow</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>returns an image taken from the screen at the bounds specified by the window</string>
		</array>
		<key>returns</key>
		<string>image</string>
		<key>short</key>
		<string>(gfx:get-image-from-screen window)</string>
	</dict>
	<key>gfx:get-image-pixels</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>coordinates</key>
			<string>flat vector of x y coordinates</string>
			<key>image</key>
			<string>image to retrieve pixels from</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(gfx:get-image-pixels image (vector 10 10)) =&gt; #(0.3 0.25 0.45 1.0)</string>
		</array>
		<key>long</key>
		<array>
			<string>returns a flat vector of pixel colours from coordinates. for doing any serious image manipulation you should be looking at writing a core image filter!  or at the very least use the objc-bridge</string>
		</array>
		<key>returns</key>
		<string>vector</string>
		<key>short</key>
		<string>(gfx:get-image-pixels image coordinates)</string>
	</dict>
	<key>gfx:get-image-size</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>image</key>
			<string>image</string>
			<key>in-pixels</key>
			<string>boolean.  true returns the value in pixels (equivelent to calling (objc:call img &quot;size&quot;)).  by default this is false and returns the value as points (equivelent to calling (objc:call img &quot;pixelsHigh&quot;) and &quot;pixelsWide&quot;)</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(gfx:get-image-size image) =&gt; (400 . 200)</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns the size (width + height) of an image as a pair.  By default this size takes account of DPI (i.e. the size is the size as rendered in the graphics context resolution).  Images in impromptu are almost always 72 dpi.  If you want the size of the image in number of pixels width and height you add #t for in-pixels.  A standard 72DPI image usually has a 1x1 correspondance between in-pixels being #t and #f.</string>
		</array>
		<key>returns</key>
		<string>pair</string>
		<key>short</key>
		<string>(gfx:get-image-size image [in-pixels])</string>
	</dict>
	<key>gfx:get-image-texture-data</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>image</key>
			<string>image</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>returns an NSData containing image data suitable for use as an opengl texture</string>
		</array>
		<key>returns</key>
		<string>NSData</string>
		<key>short</key>
		<string>(gfx:get-image-texture-data image)</string>
	</dict>
	<key>gfx:get-live-frame</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array>
			<string>(define canvas (gfx:make-canvas))</string>
			<string>(gfx:start-live-video)</string>
			<string>(define image (gfx:get-live-frame))</string>
			<string>(gfx:draw-image (now) canvas image 1.0)</string>
		</array>
		<key>long</key>
		<array>
			<string>Get the current frame from a live video feed. the image returned is of type ciimage</string>
		</array>
		<key>related</key>
		<string>gfx:start-live-video</string>
		<key>returns</key>
		<string>image (type ciimage)</string>
		<key>short</key>
		<string>(gfx:get-live-frame)</string>
	</dict>
	<key>gfx:get-movie-duration</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>movie</key>
			<string>movie</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define mlgth (- (gfx:get-movie-duration movie) 1.0))</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns the movies duration in seconds</string>
		</array>
		<key>returns</key>
		<string>number</string>
		<key>short</key>
		<string>(gfx:get-movie-duration movie)</string>
	</dict>
	<key>gfx:get-movie-fps</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>movie</key>
			<string>movie</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define fps (gfx:get-movie-fps movie))</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns the number of frames per second that the movie should run at</string>
		</array>
		<key>returns</key>
		<string>real number</string>
		<key>short</key>
		<string>(gfx:get-movie-fps movie)</string>
	</dict>
	<key>gfx:get-movie-frame</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>movie</key>
			<string>movie</string>
			<key>seconds</key>
			<string>the time in seconds since the beginning of the movie</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define image (gfx:get-movie-frame movie 110.35))</string>
		</array>
		<key>long</key>
		<array>
			<string>Get frame from movie at time in seconds.  Be aware that movies with large gaps in keyframes will suffer performance problems when playbacking backwards.  If you need efficient backwards playback (or random skipping around) make sure your video has keyframes close together (ideally every frame!).  A CIImage is returned.</string>
		</array>
		<key>returns</key>
		<string>ciimage</string>
		<key>short</key>
		<string>(gfx:get-movie-frame movie seconds)</string>
	</dict>
	<key>gfx:get-path-bounds</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>path</key>
			<string>path</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(gfx:get-path-bounds path) =&gt; (10 10 100 100)</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns the bounds of the path as list of (x y w h)</string>
		</array>
		<key>returns</key>
		<string>list</string>
		<key>short</key>
		<string>(gfx:get-path-bounds path)</string>
	</dict>
	<key>gfx:get-path-centre</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>path</key>
			<string>path</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(gfx:get-path-centre path) =&gt; (100 . 150)</string>
		</array>
		<key>long</key>
		<array>
			<string>Return the x y coordinate of the centre of the path</string>
		</array>
		<key>returns</key>
		<string>pair</string>
		<key>short</key>
		<string>(gfx:get-path-centre path)</string>
	</dict>
	<key>gfx:get-path-point</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>path</key>
			<string>path</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(gfx:get-path-point path) =&gt; (100 . 100)</string>
		</array>
		<key>long</key>
		<array>
			<string>Return the paths current end point (where to append new path segments)</string>
		</array>
		<key>returns</key>
		<string>pair</string>
		<key>short</key>
		<string>(gfx:get-path-point path)</string>
	</dict>
	<key>gfx:get-screen-size</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>returns the size of the main screen</string>
		</array>
		<key>returns</key>
		<string>size (w h)</string>
		<key>short</key>
		<string>(gfx:get-screen-size)</string>
	</dict>
	<key>gfx:get-window-bounds</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>canvas or opengl</key>
			<string>the canvas or opengl window who&apos;s dimensions we want</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>returns the bounds (x y w h) of the canvas or opengl window</string>
		</array>
		<key>returns</key>
		<string>bounds (x y w h)</string>
		<key>short</key>
		<string>(gfx:get-window-bounds canvas|opengl)</string>
	</dict>
	<key>gfx:get-window-size</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>canvas or opengl</key>
			<string>the canvas or opengl window who&apos;s dimensions we want</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(gfx:get-window-size (gfx:make-canvas)) =&gt; (578 . 600)</string>
		</array>
		<key>long</key>
		<array>
			<string>get the width and height of this canvas or opengl window as a dotted pair</string>
		</array>
		<key>returns</key>
		<string>pair</string>
		<key>short</key>
		<string>(gfx:get-window-size canvas|opengl)</string>
	</dict>
	<key>gfx:group2image</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>fills</key>
			<string>flat vector of fills</string>
			<key>image</key>
			<string>image to draw group to</string>
			<key>paths</key>
			<string>vector of paths</string>
			<key>strokes</key>
			<string>flat vector of strokes</string>
			<key>styles</key>
			<string>vector of styles</string>
			<key>widths</key>
			<string>vector of widths</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(gfx:group2image image paths strokes fills widths styles)</string>
		</array>
		<key>long</key>
		<array>
			<string>Draw group to image</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:group2image image paths strokes fills widths styles)</string>
	</dict>
	<key>gfx:hide-menu</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>hides the OSX menu and dock - usually used in conjunction with a fullscreen canvas or opengl window</string>
		</array>
		<key>related</key>
		<string>gfx:show-menu</string>
		<key>returns</key>
		<string>NSData</string>
		<key>short</key>
		<string>(gfx:hide-menu)</string>
	</dict>
	<key>gfx:image2image</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>alpha</key>
			<string>alpha transparency</string>
			<key>dest-bounds</key>
			<string>optional bounds for destination (where bounds is a list of x y w h)</string>
			<key>dest-image</key>
			<string>destination image</string>
			<key>src-bounds</key>
			<string>optional bounds for source (where bounds is a list of x y w h)</string>
			<key>src-image</key>
			<string>source image</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define gl (gl:make-opengl))
(gl:open-opengl gl (list 0 0 640 480))

(define mov (gfx:load-movie &quot;/Volumes/Macintosh HD 2/ss-Mobile.mov&quot;))

(define f1 (gfx:make-filter &quot;CIBloom&quot;))

(define loop
   (lambda (beat) 
      (let* ((i1 (objc:r (gfx:get-live-frame)))
             (i2 (objc:r (gfx:apply-filter f1 i1)))
             (i3 (objc:r (gfx:get-movie-frame mov (cosr 3 3 1/2)))))
         (gfx:set-filter-param f1 &quot;inputIntensity&quot; (cosr 2 2 1))
         (gfx:image2image i3 i2 .5 (list 0 0 640 480)) 
         (gl:draw-ciimage gl i2)
         (gl:flush gl)
         (callback (*metro* (+ beat (* 1/2 1/12))) &apos;loop (+ beat 1/12)))))

(loop (*metro* &apos;get-beat 4))</string>
		</array>
		<key>long</key>
		<array>
			<string>Draw src-image onto dest-image with an alpha transparency. src-image can be either nsimage or ciimage. dst-image must be an nsimage. dest-bounds and src-bounds are optional</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:image2image src-image dest-image alpha [dest-bounds] [src-bounds])</string>
	</dict>
	<key>gfx:load-image</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>format</key>
			<string>Optional string argument for the format of the image to convert into.  one of &quot;ARGB&quot; (UInt8 - default) &quot;RGBA&quot; (UInt8) &quot;ARGBF&quot; (Float32) &quot;RGBAF&quot; (Float32) or &quot;CI&quot; (CoreImage)</string>
			<key>path-string</key>
			<string>fully qualified path to image file</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define image (gfx:load-image &quot;/tmp/myimg.png&quot;))</string>
		</array>
		<key>long</key>
		<array>
			<string>Loads an image from the image file at path.  Image file is any valid quicktime image file</string>
		</array>
		<key>returns</key>
		<string>image</string>
		<key>short</key>
		<string>(gfx:load-image path-string [format])</string>
	</dict>
	<key>gfx:load-movie</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>path-string</key>
			<string>the fully qualified path to movie</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define movie (gfx:load-movie &quot;/tmp/myfile.mov&quot;))</string>
		</array>
		<key>long</key>
		<array>
			<string>Loads and returns the movie found at path-string. Be aware that movies compressed with I-Frame formats (H264 and MPEG for example) will not properly as gfx:get-movie-frame cannot currently handle IFrames.  PhotoJPEG is a good option for Impromptu</string>
		</array>
		<key>returns</key>
		<string>movie</string>
		<key>short</key>
		<string>(gfx:load-movie path-string)</string>
	</dict>
	<key>gfx:lock-canvas-size</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>canvas</key>
			<string>canvas</string>
			<key>h</key>
			<string>height</string>
			<key>w</key>
			<string>width</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(gfx:lock-canvas-size canvas)</string>
		</array>
		<key>long</key>
		<array>
			<string>Locks the canvas so it&apos;s size cannot be changed</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:lock-canvas-size canvas)</string>
	</dict>
	<key>gfx:make-canvas</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>bounds</key>
			<string>size of window to create</string>
			<key>fullscreen</key>
			<string>a boolean to set the canvas to fullscreen.</string>
			<key>h</key>
			<string>height</string>
			<key>screen number</key>
			<string>optional screen number index starting from 0. only available if fullscreen is #t</string>
			<key>w</key>
			<string>width</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define *canvas* (gfx:make-canvas &apos;(100 100 600 600)))</string>
			<string>(define square (gfx:make-square 100 100 50))</string>
			<string>(define circle (gfx:make-circle 200 200 20))</string>
			<string>(define oval (gfx:make-oval 200 100 50 100))</string>
			<string>(gfx:draw-path (now) *canvas* square &apos;(0.1 0.5 0.5 0.5) &apos;(0.4 0.2 0.8 0.4))</string>
			<string>(gfx:draw-path (now) *canvas* circle &apos;(0.1 0.5 0.5 0.5) &apos;() 20.0)</string>
			<string>(gfx:draw-path (now) *canvas* oval &apos;() &apos;(0.4 0.2 0.8 0.4))</string>
		</array>
		<key>long</key>
		<array>
			<string>Create and return a reference to a new graphics canvas. if fullscreen (#t) is provided then make fullscreen, if w,h make window size w,h if list make window of bounds if no args make a window of default size and position. screen number is an optional argument only available if fullscreen is #t</string>
		</array>
		<key>returns</key>
		<string>graphics canvas</string>
		<key>short</key>
		<string>(gfx:make-canvas [fullscreen] || [bounds] || [w] [h] [screen number])</string>
	</dict>
	<key>gfx:make-circle</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>radius</key>
			<string>circle radius</string>
			<key>x</key>
			<string>x coordinate of circle centre</string>
			<key>y</key>
			<string>y coordinate of circle centre</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define *canvas* (gfx:make-canvas 800 600))</string>
			<string>(define square (gfx:make-square 100 100 50))</string>
			<string>(define circle (gfx:make-circle 200 200 20))</string>
			<string>(define oval (gfx:make-oval 200 100 50 100))</string>
			<string>(gfx:draw-path (now) *canvas* square &apos;(0.1 0.5 0.5 0.5) &apos;(0.4 0.2 0.8 0.4))</string>
			<string>(gfx:draw-path (now) *canvas* circle &apos;(0.1 0.5 0.5 0.5) &apos;() 20.0)</string>
			<string>(gfx:draw-path (now) *canvas* oval &apos;() &apos;(0.4 0.2 0.8 0.4))</string>
		</array>
		<key>long</key>
		<array>
			<string>Create and return a new circular vector path</string>
		</array>
		<key>related</key>
		<string>gfx:make-square gfx:make-oval gfx:draw-path</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:make-circle x y radius)</string>
	</dict>
	<key>gfx:make-curve</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>cx1</key>
			<string>x coordinate for control point 1</string>
			<key>cx2</key>
			<string>x coordinate for control point 2</string>
			<key>cy1</key>
			<string>y coordinate for control point 1</string>
			<key>cy2</key>
			<string>y coordinate for control point 2</string>
			<key>x1</key>
			<string>x coordinate for start of curve</string>
			<key>x2</key>
			<string>x coordinate for end of curve</string>
			<key>y1</key>
			<string>y coordinate for start of curve</string>
			<key>y2</key>
			<string>y coordinate for end of curve</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns a new path that is the bezier specified by end points x1,y1 and x2,y2 and the control points cx1,cy1 and cx2,cy2</string>
		</array>
		<key>returns</key>
		<string>path</string>
		<key>short</key>
		<string>(gfx:make-oval x1 y1 x2 y2 cx1 cy1 cx2 cy2)</string>
	</dict>
	<key>gfx:make-filter</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>filter-name</key>
			<string>The string name of the filter (i.e. &quot;CIBloom&quot;)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns a CIFIlter of the given name (i.e. &quot;CIBloom&quot;)</string>
		</array>
		<key>returns</key>
		<string>CIFilter</string>
		<key>short</key>
		<string>(gfx:make-filter filter-name)</string>
	</dict>
	<key>gfx:make-image</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>format</key>
			<string>Optional string argument for the format of the image to convert into.  one of &quot;ARGB&quot; (UInt8 - default) &quot;RGBA&quot; (UInt8) &quot;ARGBF&quot; (Float32) &quot;RGBAF&quot; (Float32) or &quot;CI&quot; (CoreImage)</string>
			<key>height</key>
			<string>height of new image</string>
			<key>width</key>
			<string>width of new image</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Creates an empty image that can be used to draw into (using gfx:image2image path2image text2image etc..)</string>
		</array>
		<key>returns</key>
		<string>image</string>
		<key>short</key>
		<string>(gfx:make-image width height [format])</string>
	</dict>
	<key>gfx:make-line</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>x1</key>
			<string>start of line</string>
			<key>x2</key>
			<string>end of line</string>
			<key>y1</key>
			<string>start of line</string>
			<key>y2</key>
			<string>end of line</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Creates and returns a line path</string>
		</array>
		<key>related</key>
		<string>gfx:make-square gfx:make-oval gfx:make-circle</string>
		<key>returns</key>
		<string>path (NSPath)</string>
		<key>short</key>
		<string>(gfx:make-line x1 y1 x2 y2)</string>
	</dict>
	<key>gfx:make-oval</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>height</key>
			<string>height of bounding rectangle</string>
			<key>width</key>
			<string>width of bounding rectangle</string>
			<key>x</key>
			<string>x coordinate of bounding rectangle</string>
			<key>y</key>
			<string>y coordinate of bounding rectangle</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define *canvas* (gfx:make-canvas 800 600))</string>
			<string>(define square (gfx:make-square 100 100 50))</string>
			<string>(define circle (gfx:make-circle 200 200 20))</string>
			<string>(define oval (gfx:make-oval 200 100 50 100))</string>
			<string>(gfx:draw-path (now) *canvas* square &apos;(0.1 0.5 0.5 0.5) &apos;(0.4 0.2 0.8 0.4))</string>
			<string>(gfx:draw-path (now) *canvas* circle &apos;(0.1 0.5 0.5 0.5) &apos;() 20.0)</string>
			<string>(gfx:draw-path (now) *canvas* oval &apos;() &apos;(0.4 0.2 0.8 0.4))</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns a new path that is the oval bounded by the rectangle x y width height[</string>
		</array>
		<key>returns</key>
		<string>path</string>
		<key>short</key>
		<string>(gfx:make-oval x y width height)</string>
	</dict>
	<key>gfx:make-path</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array>
			<string>; Create and return a square path object.</string>
			<string>; A path is made up of line segments.</string>
			<string>(define gfx:make-square</string>
			<string>   (lambda (x y size)</string>
			<string>      (let ((path (gfx:make-path)))</string>
			<string>      	(gfx:set-start-point path x y)</string>
			<string>      	(gfx:add-line path x (+ y size))</string>
			<string>      	(gfx:add-line path (+ x size) (+ y size))</string>
			<string>      	(gfx:add-line path (+ x size) y)</string>
			<string>      	(gfx:add-line path x y)</string>
			<string>        (gfx:close-path path)</string>
			<string>      	path)))</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns a new empty path</string>
		</array>
		<key>related</key>
		<string>gfx:close-path gfx:add-line gfx:add-arc gfx:set-start-point</string>
		<key>returns</key>
		<string>path (NSBezierPath)</string>
		<key>short</key>
		<string>(gfx:make-path)</string>
	</dict>
	<key>gfx:make-rectangle</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>height</key>
			<string>height of rectangle</string>
			<key>width</key>
			<string>width of rectangle</string>
			<key>x</key>
			<string>x coordinate of bottom left corner</string>
			<key>x-radius</key>
			<string>optional rounded corner - x radius</string>
			<key>y</key>
			<string>x coordinate of bottom left corner</string>
			<key>y-radius</key>
			<string>optional rounded corner - y radius</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define *canvas* (gfx:make-canvas 800 600))</string>
			<string>(define square (gfx:make-square 100 100 50))</string>
			<string>(define circle (gfx:make-circle 200 200 20))</string>
			<string>(define rectangle (gfx:make-rectangle 200 100 50 100))</string>
			<string>(gfx:draw-path (now) *canvas* square &apos;(0.1 0.5 0.5 0.5) &apos;(0.4 0.2 0.8 0.4))</string>
			<string>(gfx:draw-path (now) *canvas* circle &apos;(0.1 0.5 0.5 0.5) &apos;() 20.0)</string>
			<string>(gfx:draw-path (now) *canvas* rectangle &apos;() &apos;(0.4 0.2 0.8 0.4))</string>
		</array>
		<key>long</key>
		<array>
			<string>Return a new rectanglular path - optionally with rounded corners</string>
		</array>
		<key>returns</key>
		<string>path</string>
		<key>short</key>
		<string>(gfx:make-rectangle x y width height [x-radius] [y-radius])</string>
	</dict>
	<key>gfx:make-square</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>size</key>
			<string>the length of one side</string>
			<key>x</key>
			<string>x coordinate of lower left corner</string>
			<key>y</key>
			<string>y coordinate of lower left corner</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define *canvas* (gfx:make-canvas 800 600))</string>
			<string>(define square (gfx:make-square 100 100 50))</string>
			<string>(define circle (gfx:make-circle 200 200 20))</string>
			<string>(define oval (gfx:make-oval 200 100 50 100))</string>
			<string>(gfx:draw-path (now) *canvas* square &apos;(0.1 0.5 0.5 0.5) &apos;(0.4 0.2 0.8 0.4))</string>
			<string>(gfx:draw-path (now) *canvas* circle &apos;(0.1 0.5 0.5 0.5) &apos;() 20.0)</string>
			<string>(gfx:draw-path (now) *canvas* oval &apos;() &apos;(0.4 0.2 0.8 0.4))</string>
		</array>
		<key>long</key>
		<array>
			<string>Create a new square path</string>
		</array>
		<key>returns</key>
		<string>path</string>
		<key>short</key>
		<string>(gfx:make-square x y size)</string>
	</dict>
	<key>gfx:make-text</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>font-name</key>
			<string>font-name as a string</string>
			<key>font-size</key>
			<string>font-size as a real</string>
			<key>str</key>
			<string>the string to use for text</string>
			<key>x</key>
			<string>x coordinate of path</string>
			<key>y</key>
			<string>y coordinate of path</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define *canvas* (gfx:make-canvas 300 300))</string>
			<string>(define *path* (gfx:make-text 100 100 &quot;Times-Roman&quot; 72.0 &quot;Hello&quot;))</string>
			<string>(gfx:draw-path (now) *canvas* *path* &apos;() &apos;(0.0 0.5 1.0 1.0))</string>
		</array>
		<key>long</key>
		<array>
			<string>A warpper for automatically building a text path</string>
		</array>
		<key>returns</key>
		<string>path</string>
		<key>short</key>
		<string>(gfx:make-text x y font-name font-size str)</string>
	</dict>
	<key>gfx:make-text-style</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>font-colour</key>
			<string>optional font colour</string>
			<key>font-name</key>
			<string>font family as string</string>
			<key>font-size</key>
			<string>size in points as real number</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define *canvas* (gfx:make-canvas 800 600))</string>
			<string>(define *text-style* (gfx:make-text-style &quot;Times-Roman&quot; 72.0))</string>
			<string>(define *text-path* (gfx:make-path))</string>
			<string>; make the text into a path</string>
			<string>(gfx:set-start-point *text-path* 150 250)</string>
			<string>(gfx:add-text *text-path* *text-style* &quot;impromptu&quot;)</string>
			<string>(gfx:draw-path (now) *canvas* *text-path* &apos;() &apos;(0.0 0.5 1.0 1.0))</string>
		</array>
		<key>long</key>
		<array>
			<string>Define a text style</string>
		</array>
		<key>returns</key>
		<string>font-style</string>
		<key>short</key>
		<string>(gfx:make-text-style font-name font-size [font-colour])</string>
	</dict>
	<key>gfx:make-text-with-glyphs</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>font-name</key>
			<string>font-name as a string</string>
			<key>font-size</key>
			<string>font-size as a real</string>
			<key>glyphs</key>
			<string>a list of glyph indexes</string>
			<key>x</key>
			<string>x coordinate of path</string>
			<key>y</key>
			<string>y coordinate of path</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define *canvas* (gfx:make-canvas 300 300))</string>
			<string>(define *path* (gfx:make-text-with-glyphs 100 100 &quot;Times-Roman&quot; 72.0 &apos;(10 20 30)))</string>
			<string>(gfx:draw-path (now) *canvas* *path* &apos;() &apos;(0.0 0.5 1.0 1.0))</string>
		</array>
		<key>long</key>
		<array>
			<string>A warpper for automatically building a text path using a list of glyph indexes</string>
		</array>
		<key>returns</key>
		<string>path</string>
		<key>short</key>
		<string>(gfx:make-text-with-glyphs x y font-name font-size glyphs)</string>
	</dict>
	<key>gfx:move-group</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>paths</key>
			<string>a vector of paths</string>
			<key>time</key>
			<string>time in samples to make move</string>
			<key>xs</key>
			<string>a vector of x movement amounts</string>
			<key>ys</key>
			<string>a vector of y movement amounts</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Move all paths in paths vector by x and y amounts in reciprical index values of the vectors xs and ys.  Paths xs and ys must be vectors of equal length</string>
		</array>
		<key>related</key>
		<string>gfx:draw-group</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:move-group time paths xs ys)</string>
	</dict>
	<key>gfx:move-path</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>path</key>
			<string>path</string>
			<key>time</key>
			<string>time in samples.</string>
			<key>x</key>
			<string>amount of x to move</string>
			<key>y</key>
			<string>amount of y to move</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(gfx:move-path (now) path 10 -10)</string>
		</array>
		<key>long</key>
		<array>
			<string>Move path by the amount x and y.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:move-path time path x y)</string>
	</dict>
	<key>gfx:move-path-sync</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>path</key>
			<string>path</string>
			<key>x</key>
			<string>amount of x to move</string>
			<key>y</key>
			<string>amount of y to move</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(gfx:move-path-sync path 10 -10)</string>
		</array>
		<key>long</key>
		<array>
			<string>Move path by the amount x and y.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:move-path-sync path x y)</string>
	</dict>
	<key>gfx:open-canvas</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>bounds</key>
			<string>open window within bounds</string>
			<key>canvas</key>
			<string>canvas to open window for</string>
			<key>fullscreen</key>
			<string>#t will open as fullscreen</string>
			<key>screen number</key>
			<string>optional screen number index starting from 0. only available if fullscreen is #t</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Open a window for canvas at either [fullscreen] or within [bounds]. if [fullscreen] then an optional [screen number] can be supplied (starting from idx 0).</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:open-canvas canvas [fullscreen] || [bounds] || [screen number])</string>
	</dict>
	<key>gfx:path2image</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>fill</key>
			<string>fill colour (r g b a). an empty list will stop the fill. the symbol stencil will remove the fill (i.e. transparent)</string>
			<key>image</key>
			<string>image</string>
			<key>path</key>
			<string>path</string>
			<key>stroke</key>
			<string>stroke colour (r g b a). an emptly list will stop the stroke. the symbol stencil will remove the stroke (i.e. transparent)</string>
			<key>stroke-width</key>
			<string>optional stroke width</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Draw path to image. essentially the same as gfx:draw-path. see gfx:draw-path for more information</string>
		</array>
		<key>related</key>
		<string>gfx:text2image gfx:image2image gfx:draw-path</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:path2image path image stroke fill [stroke-width])</string>
	</dict>
	<key>gfx:paths-intersect?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>patha</key>
			<string>path</string>
			<key>pathb</key>
			<string>path</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Do patha and pathb intersect?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:paths-intersect? patha pathb)</string>
	</dict>
	<key>gfx:point-in-path?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>path</key>
			<string>path</string>
			<key>x</key>
			<string>x coordinate</string>
			<key>y</key>
			<string>y coordinate</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Predicate testing if the point x,y lies inside the bounds of path</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:point-in-path? path x y)</string>
	</dict>
	<key>gfx:print-filter-params</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>filter-name</key>
			<string>the filter name as a scheme string</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Prints the params of filter-name to the log view</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>image</string>
		<key>short</key>
		<string>(gfx:print-filter-params filter-name)</string>
	</dict>
	<key>gfx:print-filters</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>category</key>
			<string>optional string argument that if provided just prints the filters from this category</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Prints a list of CIFilters installed on this machine</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:print-filter-params [category])</string>
	</dict>
	<key>gfx:print-video-devices</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Prints a list of video devices and inputs to the log view. You must call start-live-video before calling print-video-devices</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>bool</string>
		<key>short</key>
		<string>(gfx:print-vide-devices)</string>
	</dict>
	<key>gfx:rect-of-drawn-text</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>option</key>
			<string>a drawing option for the string (NSStringDrawingOptions)</string>
			<key>size</key>
			<string>a consd pair representing the size of the string</string>
			<key>string</key>
			<string>scheme string of nsstring</string>
			<key>text-style</key>
			<string>text style</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns the area that string would need to be drawn into.</string>
		</array>
		<key>related</key>
		<string>gfx:start-pdf-capture</string>
		<key>returns</key>
		<string>rectangle</string>
		<key>short</key>
		<string>(gfx:rect-of-drawn-text string text-style size option)</string>
	</dict>
	<key>gfx:rotate-path</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>path</key>
			<string>path</string>
			<key>time</key>
			<string>in samples</string>
			<key>type</key>
			<string>type is either *degrees* or *radians*</string>
			<key>val</key>
			<string>amount of rotate in degrees or radians</string>
			<key>x</key>
			<string>x coordinate to rotate around</string>
			<key>y</key>
			<string>y coordinate to rotate around</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(gfx:rotate-path (now) path 1 10 10 *gfx:degrees*)</string>
		</array>
		<key>long</key>
		<array>
			<string>rotate path about x,y point by the amount value which is either of type *degrees* or *radians*</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:rotate-path time path val x y type)</string>
	</dict>
	<key>gfx:scale-path</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>path</key>
			<string>path</string>
			<key>scale-x</key>
			<string>scale x axis</string>
			<key>scale-y</key>
			<string>scale y axis</string>
			<key>time</key>
			<string>in samples</string>
			<key>type</key>
			<string>one of *matrix-scale* *bounds-scale* or *centre-scale*</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define loopdloop</string>
			<string>   (lambda (time path stroke fill x y scale)</string>
			<string>      (gfx:draw-path time canvas path stroke fill)</string>
			<string>      (gfx:scale-path time path scale scale *gfx:matrix-scale*)</string>
			<string>      (gfx:rotate-path time path 2 x y *gfx:degrees*)</string>
			<string>      (if *go*</string>
			<string>          (callback (+ time 1000) &apos;loopdloop </string>
			<string>                    (+ time 3000) path stroke fill </string>
			<string>                    (+ x .15) (+ y .15) (+ scale 0.00001)))))	</string>
		</array>
		<key>long</key>
		<array>
			<string>Scale path by scale-x and scale-y using a type of *matrix-scale* *bounds-scale* or *centre-scale*</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:scale-path time path scale-x scale-y type)</string>
	</dict>
	<key>gfx:set-alias</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>boolean</key>
			<string>boolean</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Turns on or off anti-aliasing for path drawing</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:set-alias boolean)</string>
	</dict>
	<key>gfx:set-canvas-size</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>canvas</key>
			<string>canvas</string>
			<key>height</key>
			<string>height</string>
			<key>width</key>
			<string>width</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(gfx:set-canvas-size canvas 500 500)</string>
		</array>
		<key>long</key>
		<array>
			<string>Sets the size of the canvas window</string>
		</array>
		<key>related</key>
		<string>gfx:make-canvas gfx:lock-canvas-size gfx:close-canvas gfx:open-canvas</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:set-canvas-size canvas width height)</string>
	</dict>
	<key>gfx:set-display-resolution</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>bits</key>
			<string>The bit depth to set (usually 32)</string>
			<key>display</key>
			<string>the display to set (0 is the main display)</string>
			<key>height</key>
			<string>An integer height to set (e.g. 480 768 etc..)</string>
			<key>stretched</key>
			<string>A boolean value.  Choose a strectched resolution or not</string>
			<key>width</key>
			<string>An integer width to set (e.g. 640 1024 etc..)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Sets the resolution of the display</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>bools</string>
		<key>short</key>
		<string>(gfx:set-display-resolution display bits width height stretched)</string>
	</dict>
	<key>gfx:set-filter-param</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>duration</key>
			<string>an optional duration argument (i.e. time to move from current value to new value.</string>
			<key>filter</key>
			<string>CIFilter object</string>
			<key>param</key>
			<string>Param name as scheme string (&quot;inputIntensity&quot; for example)</string>
			<key>value</key>
			<string>A scheme number, string, list (cicolor), vector (civector), or ciimage</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define gl (gl:make-opengl))
(gl:open-opengl gl (list 0 0 640 480))

(define mov (gfx:load-movie &quot;/Volumes/Macintosh HD 2/ss-Mobile.mov&quot;))

(define f1 (gfx:make-filter &quot;CIBloom&quot;))

(define loop
   (lambda (beat) 
      (let* ((i1 (objc:r (gfx:get-live-frame)))
             (i2 (objc:r (gfx:apply-filter f1 i1)))
             (i3 (objc:r (gfx:get-movie-frame mov (cosr 3 3 1/2)))))
         (gfx:set-filter-param f1 &quot;inputIntensity&quot; (cosr 2 2 1))
         (gfx:image2image i3 i2 .5 (list 0 0 640 480)) 
         (gl:draw-ciimage gl i2)
         (gl:flush gl)
         (callback (*metro* (+ beat (* 1/2 1/12))) &apos;loop (+ beat 1/12)))))

(loop (*metro* &apos;get-beat 4))</string>
		</array>
		<key>long</key>
		<array>
			<string>Sets a given parameter (param name as string) of a CIFilter to a given value.  If the optional duration argument is given then an interpolation between the current value and the new value will take place over time.  This is a macro that expects a symbol &apos;beat&apos; to be bound in the current environment.</string>
		</array>
		<key>returns</key>
		<string>bool</string>
		<key>short</key>
		<string>(gfx:set-filter-param filter param value [duration])</string>
	</dict>
	<key>gfx:set-filter-param-now</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>duration</key>
			<string>an optional duration argument (i.e. time to move from current value to new value.</string>
			<key>filter</key>
			<string>CIFilter object</string>
			<key>param</key>
			<string>Param name as scheme string (&quot;inputIntensity&quot; for example)</string>
			<key>value</key>
			<string>A scheme number, string, list (cicolor), vector (civector), or ciimage</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Sets a given parameter (param name as string) of a CIFilter to a given value.  If the optional duration argument is given then an interpolation between the current value and the new value will take place over time. Uses (now) rather than a beat symbol (like gfx:set-filter-param expects). </string>
		</array>
		<key>returns</key>
		<string>bool</string>
		<key>short</key>
		<string>(gfx:set-filter-param-now filter param value [duration])</string>
	</dict>
	<key>gfx:set-image-pixels</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>colours</key>
			<string>a flat vector of rgba colours must equal length of coordinates * 2</string>
			<key>coordinates</key>
			<string>a flat vector of x y coordinates</string>
			<key>image</key>
			<string>image</string>
		</dict>
		<key>examples</key>
		<array>
			<string>; set pixels 0,0 - 0,4 to white</string>
			<string>(gfx:set-image-pixels image</string>
			<string>                     (vector 0 0 0 1 0 2 0 3 0 4)</string>
			<string>                     (vector 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1))</string>
		</array>
		<key>long</key>
		<array>
			<string>Set individual pixel colours in image. NOTE: If you are really interested in pixel level manipulations I would strongly suggest you use the ObjC-Bridge, write an objc-function that takes your image as an argument and returns a new image: or far better still write a core image filter!</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:set-image-pixels image coordinates colours)</string>
	</dict>
	<key>gfx:set-start-point</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>path</key>
			<string>path</string>
			<key>x</key>
			<string>x coordinate</string>
			<key>y</key>
			<string>y coordinate</string>
		</dict>
		<key>examples</key>
		<array>
			<string>; Create and return a square path object.</string>
			<string>; A path is made up of line segments.</string>
			<string>(define draw-square</string>
			<string>   (lambda (x y size)</string>
			<string>      (let ((path (gfx:make-path)))</string>
			<string>      	(gfx:set-start-point path x y)</string>
			<string>      	(gfx:add-line path x (+ y size))</string>
			<string>      	(gfx:add-line path (+ x size) (+ y size))</string>
			<string>      	(gfx:add-line path (+ x size) y)</string>
			<string>      	(gfx:add-line path x y)</string>
			<string>        (gfx:close-path path)</string>
			<string>      	path)))	</string>
		</array>
		<key>long</key>
		<array>
			<string>Sets the starting point for a path</string>
		</array>
		<key>related</key>
		<string>gfx:close-path gfx:make-path gfx:add-line gfx:add-oval gfx:add-text gfx:add-curve</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:set-start-point path x y)</string>
	</dict>
	<key>gfx:set-video-bounds</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>height</key>
			<string>suggested height</string>
			<key>width</key>
			<string>suggested width</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Attempts to set the bounds of the video device. This is a suggestion only and is not guaranteed to work, the video device may well ignore your choice or choose something close but not the same.  Check the log view for success of this</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>bool</string>
		<key>short</key>
		<string>(gfx:set-video-bounds width height)</string>
	</dict>
	<key>gfx:set-video-device</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>num</key>
			<string>The number of the video device</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Sets the video device num.  You can find the num of the video device by calling print-video-devices and checking the logview</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>bool</string>
		<key>short</key>
		<string>(gfx:set-video-device num)</string>
	</dict>
	<key>gfx:set-video-device-input</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>num</key>
			<string>The number of the video device input</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Sets the input of the current video device.  You can find the num of the video device input by calling print-video-devices and checking the logview</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>bool</string>
		<key>short</key>
		<string>(gfx:set-video-device-input num)</string>
	</dict>
	<key>gfx:show-menu</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>shows the OSX menu and dock if hidden using gfx:hide-menu</string>
		</array>
		<key>related</key>
		<string>gfx:show-menu</string>
		<key>returns</key>
		<string>NSData</string>
		<key>short</key>
		<string>(gfx:show-menu)</string>
	</dict>
	<key>gfx:size-of-drawn-text</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>string</key>
			<string>scheme string of nsstring</string>
			<key>text-style</key>
			<string>text style</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns the area that string would need to be drawn into.</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>rectangle</string>
		<key>short</key>
		<string>(gfx:size-of-drawn-text string text-style)</string>
	</dict>
	<key>gfx:start-live-video</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Start capturing frames from a live video source (isight for example).  You can grab a frame at any time by calling get-live-frame</string>
		</array>
		<key>related</key>
		<string>gfx:get-live-frame</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:start-live-video)</string>
	</dict>
	<key>gfx:start-movie-capture</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>canvas|opengl</key>
			<string>the canvas or opengl that you want to capture</string>
			<key>codec-quality</key>
			<string>a symbol ( &apos;low &apos;normal or &apos;high) designating the quality of image that you want the codec to achieve.  defaults to &apos;normal</string>
			<key>compressed</key>
			<string>do you want to compress the data?  default is true which gives aac audio and mpeg4 video compression.  false will give full stereo floating point audio and lossless video.  Of course compression will use more CPU</string>
			<key>file-path</key>
			<string>the fully qualified path to the new quicktime file</string>
			<key>h</key>
			<string>Optional Height to compress down to</string>
			<key>record-audio</key>
			<string>boolean specifying whether an audio track should be recorded: default is #t</string>
			<key>w</key>
			<string>Optional Width to compress down to</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define canvas (gfx:make-canvas 640 480))</string>
			<string>(define path (gfx:make-square 50 50 50))</string>
			<string>;; write a compressed movie with audio at high quality</string>
			<string>(gfx:start-movie-capture canvas &quot;/tmp/test.mov&quot; #t #t &apos;high 320 240)</string>
			<string>(gfx:draw-path (now) canvas path &apos;(0 1 0 1) &apos;(1 0 1 1))</string>
			<string>(gfx:stop-movie-capture canvas)</string>
		</array>
		<key>long</key>
		<array>
			<string>Start capturing all canvas/opengl drawing commands to a new QuickTime Movie file specified by file-path until stop-movie-capture closes the session and completes writing the file to disk. NOTE: If you are capturing an opengl window it is your responsibility to call gl:update-backing-image regularly to update the bitmap image backing the opengl canvas (usually you will do this immediately after you call gl:flush)</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:start-movie-capture canvas|opengl file-path [record-audio] [compressed?] [codec-quality] [w] [h])</string>
	</dict>
	<key>gfx:start-pdf-capture</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>canvas</key>
			<string>canvas whose vector drawing you want to capture</string>
			<key>file-path</key>
			<string>the fully qualified path to the new pdf file</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define canvas (gfx:make-canvas))</string>
			<string>(define path (gfx:make-square 50 50 50))</string>
			<string>(gfx:start-pdf-capture canvas &quot;/tmp/test.pdf&quot;)</string>
			<string>(gfx:draw-path (now) canvas path &apos;(0 1 0 1) &apos;(1 0 1 1))</string>
			<string>(gfx:stop-pdf-capture canvas)</string>
		</array>
		<key>long</key>
		<array>
			<string>Start capturing all canvas drawing commands to a new pdf file specified by file-path until stop-pdf-capture closes the file</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:start-pdf-capture canvas file-path)</string>
	</dict>
	<key>gfx:stop-movie-capture</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>canvas</key>
			<string>the canvas that you want to capture</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define canvas (gfx:make-canvas))</string>
			<string>(define path (gfx:make-square 50 50 50))</string>
			<string>(gfx:start-movie-capture canvas &quot;/tmp/test.mov&quot; #t 20 1)</string>
			<string>(gfx:draw-path (now) canvas path &apos;(0 1 0 1) &apos;(1 0 1 1))</string>
			<string>(gfx:stop-movie-capture canvas)</string>
		</array>
		<key>long</key>
		<array>
			<string>Stop capturing QuickTime Movie. Close the session and complete writing the file to disk</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:stop-movie-capture canvas)</string>
	</dict>
	<key>gfx:stop-pdf-capture</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>canvas</key>
			<string>canvas</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define canvas (gfx:make-canvas))</string>
			<string>(define path (gfx:make-square 50 50 50))</string>
			<string>(gfx:start-pdf-capture canvas &quot;/tmp/test.pdf&quot;)</string>
			<string>(gfx:draw-path (now) canvas path &apos;(0 1 0 1) &apos;(1 0 1 1))</string>
			<string>(gfx:stop-pdf-capture canvas)</string>
		</array>
		<key>long</key>
		<array>
			<string>Stop any pdf capture from canvas and close open file</string>
		</array>
		<key>related</key>
		<string>gfx:start-pdf-capture</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:stop-pdf-capture canvas)</string>
	</dict>
	<key>gfx:text2image</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>bounds</key>
			<string>bounds are either &apos;(x y) or &apos;(x y w h)</string>
			<key>font-style</key>
			<string>font style to use</string>
			<key>image</key>
			<string>image to draw to</string>
			<key>option</key>
			<string>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;
&lt;plist version=&quot;1.0&quot;&gt;
&lt;string&gt;string to draw  (scheme string or nsstring)&lt;/string&gt;
&lt;/plist&gt;
an optional argument for a style of drawing (NSStringDrawingOptions)</string>
			<key>str</key>
			<string>string to draw  (scheme string or nsstring)</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define loop</string>
			<string>   (lambda (time mtime)</string>
			<string>      (let ((image (gfx:get-movie-frame movie mtime)))</string>
			<string>         (gfx:text2image (number-&gt;string mtime) image font-style &apos;(10 0))</string>
			<string>         (gfx:draw-image time canvas image 1.0 &apos;(0 0 600 600))</string>
			<string>         (set! time (+ time frame-length))</string>
			<string>         (if (&lt; mtime mlgth)</string>
			<string>             (callback (- time 4000) &apos;loop time (+ mtime 0.041))))))</string>
		</array>
		<key>long</key>
		<array>
			<string>Draw str (scheme string or NSString) onto image using font-style at the point &apos;(x,y)</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:text2image str image font-style bounds [option])</string>
	</dict>
	<key>gl:array-element</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>index</key>
			<string>index into the vector array</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>draws a single vertex (from vertex array).  to be used between begin end pair</string>
		</array>
		<key>related</key>
		<string>gl:begin gl:end gl:vertex-pointer</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:array-element opengl index)</string>
	</dict>
	<key>gl:attach-shader</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>program</key>
			<string>the program (index integer number)</string>
			<key>shader</key>
			<string>the shader (index integer number)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Attach shader to program</string>
		</array>
		<key>related</key>
		<string>gl:create-shader gl:compile-shader gl:shader-source gl:detach-shader gl:attach-shader</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:attach-shader opengl program shader</string>
	</dict>
	<key>gl:begin</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Brackets any vertex data calls (with gl:end). the mode is an opengl enum (*gl-polygon* for example).</string>
		</array>
		<key>related</key>
		<string>gl:end</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:begin opengl mode)</string>
	</dict>
	<key>gl:bind-buffer</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>buffer</key>
			<string>buffer to bind (integer index)</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>target</key>
			<string>either *gl:array-buffer* (VBO) or *gl:element-array-buffer*</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Specify the current active buffer object</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:bind-buffer opengl target buffer)</string>
	</dict>
	<key>gl:bind-framebuffer</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>framebuffer</key>
			<string>Specifies the framebuffer object</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>target</key>
			<string>enum constant *gl:framebuffer*</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>bind a named framebuffer object</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:bind-framebuffer opengl target framebuffer)</string>
	</dict>
	<key>gl:bind-texture</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>target</key>
			<string>target texture type (*gl:texture-2d*)</string>
			<key>texture</key>
			<string>the texture number as returned by gl:gen-textures</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>sets the currently active texture</string>
		</array>
		<key>related</key>
		<string>gl:gen-textures gl:tex-image-2d</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:bind-texture opengl target texture)</string>
	</dict>
	<key>gl:blend-color</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>a</key>
			<string>real alpha</string>
			<key>b</key>
			<string>real blue</string>
			<key>g</key>
			<string>real green</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>r</key>
			<string>real red</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>set the blend color</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:blend-color opengl r g b a)</string>
	</dict>
	<key>gl:blend-equation</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>mode</key>
			<string>a constant blend function (such as *gl:func-add*)</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>set the blend equation to use</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:blend-equation opengl mode)</string>
	</dict>
	<key>gl:blend-func</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>dest-factor</key>
			<string>constant such as *gl:zero* *gl:one* etc.</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>src-factor</key>
			<string>constant such as *gl:zero* *gl:one* etc.</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>set the blending function src and dest factors</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:blend-func opengl src-factor dest-factor)</string>
	</dict>
	<key>gl:buffer-data</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data</key>
			<string>an nsdata object</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>size</key>
			<string>the size (in bytes) of the data object</string>
			<key>target</key>
			<string>either *gl:array-buffer* (VBO) or *gl:element-array-buffer*</string>
			<key>usage</key>
			<string>usage is one of *gl:stream-draw* *gl:stream-read* *gl:stream-copy* *gl:static-draw* *gl:static-copy* *gl:static-read* *gl:dynamic-draw* *gl:dyanmic-read* gl:dyanmic-copy*</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Allocates size storage units (almost always in bytes) of OpenGL server memory for storing vertex array data or indices.  Any previous memory allocated to the buffer will be deleted.</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:buffer-data opengl target size data usage)</string>
	</dict>
	<key>gl:buffer-sub-data</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data</key>
			<string>NSData object</string>
			<key>offset</key>
			<string>in bytes</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>size</key>
			<string>size of sub buffer</string>
			<key>target</key>
			<string>either *gl:array-buffer* or *gl:element-array-buffer*</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Updates size bytes starting at offset (bytes) in the currently bound buffer object associated with target using the data pointed to by data.</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:buffer-sub-data opengl target offset size data)</string>
	</dict>
	<key>gl:call-list</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>list</key>
			<string>a display list as returned by gl:gen-lists</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>calls the specified display list</string>
		</array>
		<key>related</key>
		<string>gl:gen-lists</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:call-list opengl list)</string>
	</dict>
	<key>gl:check-framebuffer-status</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>target</key>
			<string>enum constant *gl:framebuffer*</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>check and return status of FBO</string>
		</array>
		<key>returns</key>
		<string>integer return value (see opengl docs)</string>
		<key>short</key>
		<string>(gl:check-framebuffer-status opengl target)</string>
	</dict>
	<key>gl:clear</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>buffer</key>
			<string>opengl buffer (e.g. *gl-color-buffer-bit*)</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Clear the given buffer</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:clear opengl buffer)</string>
	</dict>
	<key>gl:clear-color</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>alpha</key>
			<string>real number between 0.0 and 1.0</string>
			<key>blue</key>
			<string>real number between 0.0 and 1.0</string>
			<key>green</key>
			<string>real number between 0.0 and 1.0</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>red</key>
			<string>real number between 0.0 and 1.0</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Set the opengl clear color</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:clear-color opengl red green blue alpha)</string>
	</dict>
	<key>gl:close-opengl</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>closes an opengl instances window without destroying the opengl instance. you can reopen the instances window using gl:open-opengl</string>
		</array>
		<key>related</key>
		<string>gl:make-opengl gl:open-opengl</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:close-opengl opengl</string>
	</dict>
	<key>gl:color</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>alpha</key>
			<string>real number between 0.0 and 1.0</string>
			<key>blue</key>
			<string>real number between 0.0 and 1.0</string>
			<key>green</key>
			<string>real number between 0.0 and 1.0</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>red</key>
			<string>real number between 0.0 and 1.0</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Sets color for vertexes</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:color opengl red green blue alpha)</string>
	</dict>
	<key>gl:color-material</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>face</key>
			<string>Accepted  values  are *gl:front*,  *gl:back*,  and *gl:front-and-back*</string>
			<key>mode</key>
			<string>Accepted values are *gl:emission*, *gl:ambient*, *gl:diffuse*, *gl:specular*, and *gl:ambient-and-diffuse*</string>
			<key>opengl</key>
			<string>an opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>gl:color-maetrial  specifies  which material parameters track the current
       color.  When *gl:color-material* is enabled, the  material  parameter  or
       parameters specified by mode, of the material or materials specified by
       face, track the current color at all times</string>
		</array>
		<key>related</key>
		<string>gfx:get-image-from-canvas</string>
		<key>returns</key>
		<string>image</string>
		<key>short</key>
		<string>(gl:color-material opengl face mode)</string>
	</dict>
	<key>gl:color-pointer</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data</key>
			<string>NSData object</string>
			<key>offset</key>
			<string>initial offset into data (number of bytes)</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>size</key>
			<string>the number of arguments for color</string>
			<key>stride</key>
			<string>stride between elements (number of bytes)</string>
			<key>type</key>
			<string>data type (*gl:float* *gl:short* etc.)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>set color array data</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:color-pointer opengl size type stride offset data)</string>
	</dict>
	<key>gl:compile-shader</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>shader</key>
			<string>the shader (index integer number)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Compile the source code (gl:shader-source) for shader shader</string>
		</array>
		<key>related</key>
		<string>gl:create-shader gl:compile-shader gl:shader-source gl:detach-shader gl:attach-shader</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:compile-shader opengl shader</string>
	</dict>
	<key>gl:copy-pixels</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>buffer</key>
			<string>buffer to temporarily store image data; one of *gl:color* *gl:stencil* or *gl:depth*</string>
			<key>h</key>
			<string>height</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>w</key>
			<string>width</string>
			<key>x</key>
			<string>x coordinate of lower left hand corner</string>
			<key>y</key>
			<string>y coordinate of lower left hand cornder</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Copy pixel data of x,y,w,h from the framebuffer into temporary buffer (*gl:color* *gl:stencil* or *gl:depth*) before writing to the last position spec&apos;d by gl:raster-pos or gl:window-pos</string>
		</array>
		<key>related</key>
		<string>gl:raster-pos gl:draw-pixels gl:copy-pixels</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:copy-pixels opengl x y w h buffer</string>
	</dict>
	<key>gl:create-program</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Create a new program and return it&apos;s index</string>
		</array>
		<key>related</key>
		<string>gl:delete-shader gl:create-program gl:use-program gl:link-program</string>
		<key>returns</key>
		<string>integer index of newly created shader program</string>
		<key>short</key>
		<string>(gl:create-program opengl</string>
	</dict>
	<key>gl:create-shader</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>shader-type</key>
			<string>the type of shader to create (either *gl:vertex-shader* or *gl:fragment-shader*)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Create a shader and return it&apos;s index</string>
		</array>
		<key>related</key>
		<string>gl:link-shader gl:detach-shader gl:attach-shader</string>
		<key>returns</key>
		<string>shader index value (0 if error)</string>
		<key>short</key>
		<string>(gl:create-shader opengl shader-type</string>
	</dict>
	<key>gl:delete-buffer</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>buffer</key>
			<string>buffer (integer index)</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>deletes buffer</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:delete-buffer opengl buffer)</string>
	</dict>
	<key>gl:delete-framebuffer</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>framebuffer</key>
			<string>id of framebuffer</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>deletes a framebuffer object</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:delete-framebuffer opengl framebuffer)</string>
	</dict>
	<key>gl:delete-program</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>program</key>
			<string>the number of the program to delete</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Delete the shader program</string>
		</array>
		<key>related</key>
		<string>gl:delete-shader gl:create-program gl:use-program gl:link-program</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:delete-program opengl program</string>
	</dict>
	<key>gl:delete-shader</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>shader</key>
			<string>the number of the shader to delete</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Delete the shader</string>
		</array>
		<key>related</key>
		<string>gl:delete-program gl:create-shader gl:detach-shader gl:attach-shader</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:delete-shader opengl shader</string>
	</dict>
	<key>gl:depth-mask</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>flag</key>
			<string>either *gl:false* or *gl:true*</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>turn on or off depth mask</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:depth-mask opengl flag)</string>
	</dict>
	<key>gl:depth-range</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>far</key>
			<string>real value far clipping plane</string>
			<key>near</key>
			<string>real value near clipping plane</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>sets the depth range</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:depth-range opengl near far)</string>
	</dict>
	<key>gl:detach-shader</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>program</key>
			<string>the program (index integer number)</string>
			<key>shader</key>
			<string>the shader (index integer number)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Detach shader from program</string>
		</array>
		<key>related</key>
		<string>gl:create-shader gl:compile-shader gl:shader-source gl:detach-shader gl:attach-shader</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:detach-shader opengl program shader</string>
	</dict>
	<key>gl:disable</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>capability</key>
			<string>contant capability such as *gl:lighting*</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>disables an opengl capability</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:disable opengl capability)</string>
	</dict>
	<key>gl:disable-client-state</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>capability</key>
			<string>capability constant</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>disable client state capability</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:disable-client-state opengl capability)</string>
	</dict>
	<key>gl:draw-arrays</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>count</key>
			<string>the number of indicies to be rendered</string>
			<key>first</key>
			<string>the starting index of the enabled arrays</string>
			<key>mode</key>
			<string>how to draw the primitives (i.e. *gl:quads* *gl:polygon* etc.)</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>draw geometric primitives from enabled arrays</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:draw-arrays opengl mode first count)</string>
	</dict>
	<key>gl:draw-ciimage</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>ciimage</key>
			<string>a ciimage</string>
			<key>dst-bounds</key>
			<string>bounds within the opengl canvas to draw to (defaults to size of src bounds or the whole ciimage bounds if none provided)</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>src-bounds</key>
			<string>bounds of the src ciimage to draw (defaults to the whole of the ciimage)</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define gl (gl:make-opengl))
(gl:open-opengl gl (list 0 0 640 480))

(define mov (gfx:load-movie &quot;/Volumes/Macintosh HD 2/ss-Mobile.mov&quot;))

(define f1 (gfx:make-filter &quot;CIBloom&quot;))

(define loop
   (lambda (beat) 
      (let* ((i1 (objc:r (gfx:get-live-frame)))
             (i2 (objc:r (gfx:apply-filter f1 i1)))
             (i3 (objc:r (gfx:get-movie-frame mov (cosr 3 3 1/2)))))
         (gfx:set-filter-param f1 &quot;inputIntensity&quot; (cosr 2 2 1))
         (gfx:image2image i3 i2 .5 (list 0 0 640 480)) 
         (gl:draw-ciimage gl i2)
         (gl:flush gl)
         (callback (*metro* (+ beat (* 1/2 1/12))) &apos;loop (+ beat 1/12)))))

(loop (*metro* &apos;get-beat 4))</string>
		</array>
		<key>long</key>
		<array>
			<string>Draws a CIImage directly to an opengl canvas</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:draw-ciimage opengl ciimage [dst-bounds] [src-bounds])</string>
	</dict>
	<key>gl:draw-elements</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>count</key>
			<string>number of geometric elements (of type) to draw</string>
			<key>data</key>
			<string>nsdata object containing indicies data</string>
			<key>mode</key>
			<string>how to draw the primitives (i.e. *gl:quads* *gl:polygon* etc.)</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>type</key>
			<string>the type of the indicies array data</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string></string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:draw-elements opengl mode count type data)</string>
	</dict>
	<key>gl:draw-pixels</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>format</key>
			<string>format of image data *gl:rgb* or *gl:rgba* for example</string>
			<key>h</key>
			<string>height</string>
			<key>image|nsdata</key>
			<string>an image or nsdata objecte</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>type</key>
			<string>type of image data *gl:unsigned-byte* or *gl:float* for example</string>
			<key>w</key>
			<string>width</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Draw an image or the pixel data stored in nsdata object into the opengl buffer of size w and h at the x,y coordinates set by gl:raster-pos or gl:window-pos</string>
		</array>
		<key>related</key>
		<string>gl:raster-pos gl:window-pos gl:draw-pixels gl:copy-pixels</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:draw-pixels opengl w h format type image|nsdata)</string>
	</dict>
	<key>gl:edge-flag-pointer</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data</key>
			<string>NSData object</string>
			<key>offset</key>
			<string>initial offset into data (number of bytes)</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>stride</key>
			<string>stride between elements (number of bytes)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>set the edge flag array</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:edge-flag-pointer opengl stride offset data)</string>
	</dict>
	<key>gl:enable</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>capability</key>
			<string>contant capability such as *gl:lighting*</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>enables an opengl capability</string>
		</array>
		<key>related</key>
		<string>gl:disable</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:enable opengl capability)</string>
	</dict>
	<key>gl:enable-client-state</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>capability</key>
			<string>capability constant</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>enable client capability</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:enable-client-state opengl capability)</string>
	</dict>
	<key>gl:end</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Brackets opengl vertex data calls (with gl:begin)</string>
		</array>
		<key>related</key>
		<string>gl:begin</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:end opengl)</string>
	</dict>
	<key>gl:end-list</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>end list definition</string>
		</array>
		<key>related</key>
		<string>gl:new-list gl:gen-lists gl:call-list</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:end-list opengl)</string>
	</dict>
	<key>gl:eval-coord-1</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>u</key>
			<string>Specifies a value that is the domain coordinate u to the basis function defined in a  previous  glMap1  or
          glMap2 command.</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define ctrlpoints (objc:vector-&gt;nsdata-float (vector (vector -5 -4 0) </string>
			<string>                                                      (vector -2 4 -1) </string>
			<string>                                                      (vector .5 -4 0) </string>
			<string>                                                      (vector 4 4 0))))</string>
			<string>(gl:map-1 *gl* *gl:map1-vertex-3* 0.0 1.0 3 4 ctrlpoints)</string>
			<string>(gl:enable *gl* *gl:map1-vertex-3*)</string>
			<string></string>
			<string>(define test</string>
			<string>   (lambda (val)</string>
			<string>      (gl:clear *gl* (io:binary-or *gl:color-buffer-bit* *gl:depth-buffer-bit*))</string>
			<string>      (gl:load-identity *gl*)</string>
			<string>      (gl:translate *gl* 0 0 -30)</string>
			<string>      (gl:color *gl* 1 1 0 1)</string>
			<string>      (gl:begin *gl* *gl:line-strip*)</string>
			<string>      (dotimes (i (modulo val 50))</string>
			<string>         (gl:eval-coord-1 *gl* (/ i 50)))</string>
			<string>      (gl:end *gl*)</string>
			<string>      (gl:flush *gl*)</string>
			<string>      (callback (+ (now) 500) &apos;test (+ val 1))))</string>
			<string></string>
			<string>(test 0)</string>
		</array>
		<key>long</key>
		<array>
			<string>glEvalCoord1 evaluates enabled two-dimensional maps at argument u.  glEvalCoord2 does the same for two-dimen-       sional maps using two domain values, u and v.  To define a map, call glMap1 and glMap2; to enable and disable       it, call glEnable and glDisable.
	  </string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:eval-coord-1 opengl u)</string>
	</dict>
	<key>gl:eval-coord-2</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>u</key>
			<string>Specifies a value that is the domain coordinate u to the basis function defined in a  previous  glMap1  or
          glMap2 command.</string>
			<key>v</key>
			<string>Specifies  a value that is the domain coordinate v to the basis function defined in a previous glMap2 com-
          mand.  This argument is not present in a glEvalCoord1 command.</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>glEvalCoord1 evaluates enabled two-dimensional maps at argument u.  glEvalCoord2 does the same for two-dimensional maps using two domain values, u and v.  To define a map, call glMap1 and glMap2; to enable and disable       it, call glEnable and glDisable.
	  </string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:eval-coord-2 opengl u v)</string>
	</dict>
	<key>gl:eval-mesh-1</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>mode</key>
			<string>enumeration (int)</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>p1</key>
			<string>integer number</string>
			<key>p2</key>
			<string>integer number</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>glMapGrid  and  glEvalMesh  are used in tandem to efficiently generate and evaluate a series of evenly-spacedmap domain values.  glEvalMesh steps through the integer domain of a  one-  or  two-dimensional  grid,  whoserange  is  the  domain  of  the  evaluation maps specified by glMap1 and glMap2.  mode determines whether theresulting vertices are connected as points, lines, or filled polygons.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:eval-mesh-1 opengl mode p1 p2)</string>
	</dict>
	<key>gl:eval-mesh-2</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>i1</key>
			<string>integer number</string>
			<key>i2</key>
			<string>integer number</string>
			<key>j1</key>
			<string>integer number</string>
			<key>j2</key>
			<string>integer number</string>
			<key>mode</key>
			<string>enumeration (int)</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>glMapGrid  and  glEvalMesh  are used in tandem to efficiently generate and evaluate a series of evenly-spacedmap domain values.  glEvalMesh steps through the integer domain of a  one-  or  two-dimensional  grid,  whoserange  is  the  domain  of  the  evaluation maps specified by glMap1 and glMap2.  mode determines whether theresulting vertices are connected as points, lines, or filled polygons.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:eval-mesh-2 opengl mode i1 i2 j1 j2)</string>
	</dict>
	<key>gl:flush</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Flush any opengl calls</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:flush opengl)</string>
	</dict>
	<key>gl:fog</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>type</key>
			<string>enum type for fog setting (*gl:fog-mode* or *gl:fog-color* *gl:fog-density* *gl:fog-start* *gl:fog-end* etc..)</string>
			<key>value</key>
			<string>value can be either an integer a real a vector of values or an NSData object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>set fog parameters</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:fog opengl type value)</string>
	</dict>
	<key>gl:fog-coord-pointer</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data</key>
			<string>NSData object</string>
			<key>offset</key>
			<string>initial offset into data (number of bytes)</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>stride</key>
			<string>stride between elements (number of bytes)</string>
			<key>type</key>
			<string>data type (*gl:float* *gl:short* etc.)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>set fog array data</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:fog-coord-pointer opengl type stride offset data)</string>
	</dict>
	<key>gl:framebuffer-renderbuffer</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>attachment</key>
			<string>integer enum *gl:depth-attachment* *gl:stencil-attachment* *gl:color-attachment0*</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>renderbuffer</key>
			<string>integer (see opengl docs)</string>
			<key>renderbuffertarget</key>
			<string>integer enum *gl:renderbuffer*</string>
			<key>target</key>
			<string>*gl:framebuffer*</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>attach a renderbuffer object to a framebuffer object</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:framebuffer-renderbuffer opengl target attachment renderbuffertarget renderbuffer)</string>
	</dict>
	<key>gl:framebuffer-texture2d</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>attachment</key>
			<string>integer enum *gl:depth-attachment* *gl:stencil-attachment* *gl:color-attachment0*</string>
			<key>level</key>
			<string>spec mipmap level of texture image to be attached (must be 0)</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>target</key>
			<string>*gl:framebuffer*</string>
			<key>textarget</key>
			<string>integer enum *gl:texture-2d* *gl:texture-cube-map-positive-x* etc..</string>
			<key>texture</key>
			<string>integer texture object id</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>attach a texture image to a framebuffer object</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:framebuffer-texture2d opengl target attachment textarget texture level)</string>
	</dict>
	<key>gl:frustum</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>multiply the current matrix by a perspective matrix</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:frustum opengl left right bottom top near far)</string>
	</dict>
	<key>gl:gen-buffer</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>returns a new buffer object (intenger index) </string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>integer</string>
		<key>short</key>
		<string>(gl:gen-buffer opengl)</string>
	</dict>
	<key>gl:gen-framebuffer</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>generate a framebuffer object</string>
		</array>
		<key>returns</key>
		<string>integer id for framebuffer object</string>
		<key>short</key>
		<string>(gl:gen-framebuffer opengl)</string>
	</dict>
	<key>gl:gen-lists</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string></string>
		</array>
		<key>related</key>
		<string>gl:new-list gl:call-list</string>
		<key>returns</key>
		<string>integer representing a new display list</string>
		<key>short</key>
		<string>(gl:gen-lists opengl)</string>
	</dict>
	<key>gl:gen-textures</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>returns a new texture number to bind textures to</string>
		</array>
		<key>related</key>
		<string>gl:bind-texture gl:tex-image-2d</string>
		<key>returns</key>
		<string>integer texture numbers</string>
		<key>short</key>
		<string>(gl:gen-textures opengl)</string>
	</dict>
	<key>gl:get-attrib-location</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>program-number</key>
			<string>the integer number of the shader program in which the uniform variable resides</string>
			<key>variable-name</key>
			<string>the uniform variable name as a string</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>returns a location of the attribute variable-name in the program spec&apos;d by program-number</string>
		</array>
		<key>related</key>
		<string>gl:vertex-attrib</string>
		<key>returns</key>
		<string>integer: location of the attribute varaible</string>
		<key>short</key>
		<string>(gl:get-attrib-location opengl program-number variable-name</string>
	</dict>
	<key>gl:get-boolean</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data</key>
			<string>NSData object to write data into </string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>param</key>
			<string>the opengl state param to retrieve a value for</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>see opengl documentation</string>
		</array>
		<key>related</key>
		<string>gl:get-integer gl:get-float gl:get-double</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:get-boolean opengl param data)</string>
	</dict>
	<key>gl:get-double</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data</key>
			<string>NSData object to write data into </string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>param</key>
			<string>the opengl state param to retrieve a value for</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>see opengl documentation</string>
		</array>
		<key>related</key>
		<string>gl:get-integer gl:get-float gl:get-boolean</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:get-double opengl param data)</string>
	</dict>
	<key>gl:get-error</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>returns the current (if any) opengl error number</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>integer error number</string>
		<key>short</key>
		<string>(gl:get-error opengl)</string>
	</dict>
	<key>gl:get-float</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data</key>
			<string>NSData object to write data into </string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>param</key>
			<string>the opengl state param to retrieve a value for</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Based on glGetFloatv which copies the value of simple state values to data - after returning data will contain one (or more depending on param) float value(s).</string>
		</array>
		<key>related</key>
		<string>gl:get-integer gl:get-double gl:get-boolean</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:get-float opengl param data)</string>
	</dict>
	<key>gl:get-framebuffer-attachment-param</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>attachment</key>
			<string>integer enum *gl:depth-attachment* *gl:stencil-attachment* *gl:color-attachment0*</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>pname</key>
			<string>integer enum *gl:framebuffer-attachment-object-type* *gl:framebuffer-attachment-object-name* *gl:framebuffer-attachment-texture-level* *gl:framebuffer-attachment-texture-cube-map-face*</string>
			<key>target</key>
			<string>*gl:framebuffer*</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>return attachment parameters of a framebuffer object</string>
		</array>
		<key>returns</key>
		<string>integer return value (see opengl docs)</string>
		<key>short</key>
		<string>(gl:get-framebuffer-attachment-param opengl target attachment pname)</string>
	</dict>
	<key>gl:get-image-from-opengl</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>an opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns a new bitmap image whose contents is the current state of opengl</string>
		</array>
		<key>related</key>
		<string>gfx:get-image-from-canvas</string>
		<key>returns</key>
		<string>image</string>
		<key>short</key>
		<string>(gl:get-image-from-opengl opengl)</string>
	</dict>
	<key>gl:get-integer</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data</key>
			<string>NSData object to write data into </string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>see opengl documentation</string>
		</array>
		<key>related</key>
		<string>gl:get-integer gl:get-float gl:get-boolean</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:get-integer opengl data)</string>
	</dict>
	<key>gl:get-program-info-log</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>program</key>
			<string>the number of the program</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Prints the programs info log to the log view</string>
		</array>
		<key>related</key>
		<string>gl:get-shader-info-log</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:get-program-info-log opengl program</string>
	</dict>
	<key>gl:get-shader-info-log</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>shader</key>
			<string>the number of the shader</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Prints the shaders info log to the log view</string>
		</array>
		<key>related</key>
		<string>gl:get-program-info-log</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:get-shader-info-log opengl shader</string>
	</dict>
	<key>gl:get-uniform-location</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>program-number</key>
			<string>the integer number of the shader program in which the uniform variable resides</string>
			<key>variable-name</key>
			<string>the uniform variable name as a string</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>returns a location of the unfiform variable-name in the program spec&apos;d by program-number</string>
		</array>
		<key>related</key>
		<string>gl:uniform</string>
		<key>returns</key>
		<string>integer: location of the uniform varaible</string>
		<key>short</key>
		<string>(gl:get-uniform-location opengl program-number variable-name</string>
	</dict>
	<key>gl:get-window-bounds</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>canvas or opengl</key>
			<string>the canvas or opengl window who&apos;s dimensions we want</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>returns the bounds (x y w h) of the canvas or opengl window</string>
		</array>
		<key>returns</key>
		<string>bounds (x y w h)</string>
		<key>short</key>
		<string>(gl:get-window-bounds canvas|opengl)</string>
	</dict>
	<key>gl:get-window-size</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>canvas or opengl</key>
			<string>the canvas or opengl window who&apos;s dimensions we want</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>get the width and height of this canvas or opengl window as a dotted pair</string>
		</array>
		<key>returns</key>
		<string>pair</string>
		<key>short</key>
		<string>(gl:get-window-size canvas|opengl)</string>
	</dict>
	<key>gl:hint</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>mode</key>
			<string>enum type (*gl:fastest* *gl:nicest* etc..)</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>target</key>
			<string>enum type (*gl:fog-hint* *gl:line-smooth-hint* etc..)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Certain aspects of GL behavior, when there is room for interpretation, can be  controlled  with hints.  A hint is specified with two arguments.  target is a symbolic constant indicating the behavior to be controlled, and  mode  is  another  symbolic constant  indicating  the  desired  behavior.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:hint opengl target mode)</string>
	</dict>
	<key>gl:index-pointer</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data</key>
			<string>NSData object</string>
			<key>offset</key>
			<string>initial offset into data (number of bytes)</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>stride</key>
			<string>stride between elements (number of bytes)</string>
			<key>type</key>
			<string>data type (*gl:float* *gl:short* etc.)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>set index array data</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:index-pointer opengl type stride offset data)</string>
	</dict>
	<key>gl:interleaved-arrays</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data</key>
			<string>NSData containing the data</string>
			<key>format</key>
			<string>specifies which arrays are interleaved in data (i.e. *gl:v2f* *gl:c4ub-v2f*)</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>stride</key>
			<string>the total stride between each aggregated array element</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>lets you specify multiple arrays using a single data object.  use format to specify which arrays are enalbed</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:interleaved-arrays opengl format stride data)</string>
	</dict>
	<key>gl:is-buffer</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>buffer</key>
			<string>buffer (integer index)</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>is index a bound buffer.</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:is-buffer opengl buffer)</string>
	</dict>
	<key>gl:is-framebuffer</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>framebuffer</key>
			<string>id of framebuffer</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>predicate check.  is framebuffer a framebuffer object?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:is-framebuffer opengl framebuffer)</string>
	</dict>
	<key>gl:key-down</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>char</key>
			<string>scheme character</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>The character pressed</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>bool</string>
		<key>short</key>
		<string>(gl:key-down char)</string>
	</dict>
	<key>gl:key-up</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>char</key>
			<string>scheme character</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>The character pressed</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>bool</string>
		<key>short</key>
		<string>gl:key-up char)</string>
	</dict>
	<key>gl:light</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>light</key>
			<string>a constant light value such as *gl:light0*</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>param</key>
			<string>one or more values for pname (either a vector or reals or an NSData object of floats)</string>
			<key>pname</key>
			<string>a constant param name such as *gl:diffuse*</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>set light parameters</string>
		</array>
		<key>related</key>
		<string>objc:vector-&gt;nsdata objc:nsdata-&gt;vector</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:light opengl light pname param)</string>
	</dict>
	<key>gl:light-model</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>param</key>
			<string>one or more values for pname (either a vector or reals or an NSData object of floats)</string>
			<key>pname</key>
			<string>a constant param name such as *gl:diffuse*</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>set light model parameters</string>
		</array>
		<key>related</key>
		<string>objc:vector-&gt;nsdata objc:nsdata-&gt;vector</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:light-model opengl param values)</string>
	</dict>
	<key>gl:link-program</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>program</key>
			<string>the number of the program</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Links all compiled shader objects into program</string>
		</array>
		<key>related</key>
		<string>gl:create-program gl:use-program gl:link-program</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:link-program opengl program</string>
	</dict>
	<key>gl:load-identity</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Loads the identity matrix</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:load-identity opengl)</string>
	</dict>
	<key>gl:load-matrix</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>matrix</key>
			<string>Matrix representation (NSData object  (GLfloats))</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>see opengl documentation</string>
		</array>
		<key>related</key>
		<string>gl:mult-matrix gl:mult-transpose-matrix gl:load-transpose-matrix gl:get</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:load-matrix opengl matrix)</string>
	</dict>
	<key>gl:load-transpose-matrix</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>matrix</key>
			<string>Matrix representation (NSData object  (GLfloats))</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>see opengl documentation</string>
		</array>
		<key>related</key>
		<string>gl:load-matrix gl:mult-matrix gl:mult-transpose-matrix gl:get</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:load-transpose-matrix opengl matrix)</string>
	</dict>
	<key>gl:make-opengl</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>multisample</key>
			<string>A boolean value indicating if the opengl context try to multisample? by default multisampling is off</string>
			<key>pixel-format</key>
			<string>You can specify a custom opengl format by sending a vector of intenger values as you would send to NSOpenGLPixelFormat. See the opengl example files for examples</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define gl (gl:make-opengl))
(gl:open-opengl gl (list 0 0 640 480))

(define mov (gfx:load-movie &quot;/Volumes/Macintosh HD 2/ss-Mobile.mov&quot;))

(define f1 (gfx:make-filter &quot;CIBloom&quot;))

(define loop
   (lambda (beat) 
      (let* ((i1 (objc:r (gfx:get-live-frame)))
             (i2 (objc:r (gfx:apply-filter f1 i1)))
             (i3 (objc:r (gfx:get-movie-frame mov (cosr 3 3 1/2)))))
         (gfx:set-filter-param f1 &quot;inputIntensity&quot; (cosr 2 2 1))
         (gfx:image2image i3 i2 .5 (list 0 0 640 480)) 
         (gl:draw-ciimage gl i2)
         (gl:flush gl)
         (callback (*metro* (+ beat (* 1/2 1/12))) &apos;loop (+ beat 1/12)))))

(loop (*metro* &apos;get-beat 4))</string>
		</array>
		<key>long</key>
		<array>
			<string>Make and return an opengl context.  This call does not open an opengl window.  You can do this using gl:open-opengl</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:make-opengl [multisample] [pixel-format])</string>
	</dict>
	<key>gl:map-1</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>order</key>
			<string>Specifies the number of control points.  Must be positive.</string>
			<key>points</key>
			<string>Specifies a pointer to the array of control points.</string>
			<key>stride</key>
			<string>Specifies the number of floats or doubles between the beginning of one con-
               trol  point  and the beginning of the next one in the data structure refer-
               enced in points.  This allows control points to be  embedded  in  arbitrary
               data  structures.   The only constraint is that the values for a particular
               control point must occupy contiguous memory locations.</string>
			<key>target</key>
			<string>Specifies the kind of values that are generated by the evaluator.  Symbolic
               constants      GL_MAP1_VERTEX_3,      GL_MAP1_VERTEX_4,      GL_MAP1_INDEX,
               GL_MAP1_COLOR_4,          GL_MAP1_NORMAL,          GL_MAP1_TEXTURE_COORD_1,
               GL_MAP1_TEXTURE_COORD_2,            GL_MAP1_TEXTURE_COORD_3,            and
               GL_MAP1_TEXTURE_COORD_4 are accepted.</string>
			<key>u1, u2</key>
			<string>Specify  a  linear  mapping  of u, as presented to glEvalCoord1, to uh, the
               variable that is evaluated by the equations specified by this command.
			   </string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define ctrlpoints (objc:vector-&gt;nsdata-float (vector (vector -5 -4 0) </string>
			<string>                                                      (vector -2 4 -1) </string>
			<string>                                                      (vector .5 -4 0) </string>
			<string>                                                      (vector 4 4 0))))</string>
			<string>(gl:map-1 *gl* *gl:map1-vertex-3* 0.0 1.0 3 4 ctrlpoints)</string>
			<string>(gl:enable *gl* *gl:map1-vertex-3*)</string>
			<string></string>
			<string>(define test</string>
			<string>   (lambda (val)</string>
			<string>      (gl:clear *gl* (io:binary-or *gl:color-buffer-bit* *gl:depth-buffer-bit*))</string>
			<string>      (gl:load-identity *gl*)</string>
			<string>      (gl:translate *gl* 0 0 -30)</string>
			<string>      (gl:color *gl* 1 1 0 1)</string>
			<string>      (gl:begin *gl* *gl:line-strip*)</string>
			<string>      (dotimes (i (modulo val 50))</string>
			<string>         (gl:eval-coord-1 *gl* (/ i 50)))</string>
			<string>      (gl:end *gl*)</string>
			<string>      (gl:flush *gl*)</string>
			<string>      (callback (+ (now) 500) &apos;test (+ val 1))))</string>
			<string></string>
			<string>(test 0)</string>
		</array>
		<key>long</key>
		<array>
			<string>Evaluators provide a way to use polynomial or rational polynomial mapping  to  produce vertices, normals, texture coordinates, and colors.  The values produced by an evaluator are sent to further stages of GL processing just as if they had been presented  using glVertex, glNormal, glTexCoord, and glColor commands, except that the generated values do not update the current normal, texture coordinates, or color.  All polynomial or rational polynomial splines of any  degree  (up  to  the  maximum       degree  supported  by  the  GL  implementation)  can be described using evaluators.       These include almost all splines  used  in  computer  graphics:  B-splines,  Bezier       curves, Hermite splines, and so on.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:map-1 opengl target u1 u2 stride order points)</string>
	</dict>
	<key>gl:map-2</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>points</key>
			<string>Specifies a pointer to the array of control points.</string>
			<key>target</key>
			<string>   Specifies   the   kind   of  values  that  are  generated  by  the  evaluator.   Symbolic  constants
                GL_MAP2_VERTEX_3,     GL_MAP2_VERTEX_4,     GL_MAP2_INDEX,     GL_MAP2_COLOR_4,      GL_MAP2_NORMAL,
                GL_MAP2_TEXTURE_COORD_1,         GL_MAP2_TEXTURE_COORD_2,        GL_MAP2_TEXTURE_COORD_3,        and
                GL_MAP2_TEXTURE_COORD_4 are accepted.</string>
			<key>u1, u2</key>
			<string>   Specify a linear mapping of u, as presented to glEvalCoord2, to u hat, one of the two variables that
                are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1.</string>
			<key>uorder</key>
			<string>   Specifies  the  dimension  of  the control point array in the u axis.  Must be positive. The initial
                value is 1.</string>
			<key>ustride</key>
			<string>  Specifies  the number of floats or doubles between the beginning of control point Rij and the begin-
                ning of control point R(i+1)j , where i and j are the u and v control point  indices,  respectively.
                This allows control points to be embedded in arbitrary data structures.  The only constraint is that
                the values for a particular control point must occupy contiguous memory locations. The initial value
                of ustride is 0.</string>
			<key>v1, v2</key>
			<string>   Specify a linear mapping of v, as presented to glEvalCoord2, to v hat, one of the two variables that
                are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1.</string>
			<key>vorder</key>
			<string>   Specifies  the  dimension  of  the control point array in the v axis.  Must be positive. The initial
                value is 1.</string>
			<key>vstride</key>
			<string>Specifies  the number of floats or doubles between the beginning of control point Rij and the begin-
                ning of control point Ri(j+1), where i and j are the u and v control  point  indices,  respectively.
                This allows control points to be embedded in arbitrary data structures.  The only constraint is that
                the values for a particular control point must occupy contiguous memory locations. The initial value
                of vstride is 0.</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Evaluators provide a way to use polynomial or rational polynomial mapping to produce vertices, normals,  tex-       ture  coordinates,  and colors.  The values produced by an evaluator are sent on to further stages of GL pro-       cessing just as if they had been presented using glVertex, glNormal, glTexCoord, and glColor commands, except       that the generated values do not update the current normal, texture coordinates, or color.       All  polynomial  or  rational  polynomial splines of any degree (up to the maximum degree supported by the GL       implementation) can be described using evaluators.  These include almost all surfaces used in computer graph-       ics, including B-spline surfaces, NURBS surfaces, Bezier surfaces, and so on.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gfx:map-2 opengl target u1 u2 ustride uorder v1 v2 vstride vorder points)</string>
	</dict>
	<key>gl:map-buffer</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>access</key>
			<string>either *gl:read-only* *gl:write* or *gl:read-write*</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>size</key>
			<string>the size of the NSMutableData value to return (this will be the size of the currently bound buffer in bytes)</string>
			<key>target</key>
			<string>either *gl:array-buffer* (VBO) or *gl:element-array-buffer*</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>retuns an NSMutableArray pointing to the data storage for the currently bound buffer object associated with target.</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>NSMutableData</string>
		<key>short</key>
		<string>(gl:map-buffer opengl target access size)</string>
	</dict>
	<key>gl:map-grid-1</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>n</key>
			<string>integer number</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>u1</key>
			<string>integer number</string>
			<key>u2</key>
			<string>integer number</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>glMapGrid and glEvalMesh are used together to efficiently generate and evaluate a series of evenly-spaced mapdomain values.  glEvalMesh steps through the integer domain of a one- or two-dimensional grid, whose range isthe domain of the evaluation maps specified by glMap1 and glMap2.glMapGrid1  and  glMapGrid2  specify the linear grid mappings between the i (or i and j) integer grid coordi-nates, to the u (or u and v) floating-point evaluation map coordinates.  See glMap1 and glMap2 for details ofhow u and v coordinates are evaluated.glMapGrid1  specifies  a  single  linear  mapping such that integer grid coordinate 0 maps exactly to u1, andinteger grid coordinate un maps exactly to u2.  All other integer grid coordinates i are mapped so thatglMapGrid2 specifies two such linear mappings.  One maps integer grid coordinate i=0 exactly to u1, and inte-ger  grid coordinate i=un exactly to u2.  The other maps integer grid coordinate j=0 exactly to v1, and inte-ger grid coordinate j=vn exactly to v2.  Other integer grid coordinates i and j are mapped such that</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:map-grid-1 opengl n u1 u2)</string>
	</dict>
	<key>gl:map-grid-2</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>nu</key>
			<string>integer number</string>
			<key>nv</key>
			<string>integer number</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>u1</key>
			<string>integer number</string>
			<key>u2</key>
			<string>integer number</string>
			<key>v1</key>
			<string>integer number</string>
			<key>v2</key>
			<string>integer number</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>glMapGrid and glEvalMesh are used together to efficiently generate and evaluate a series of evenly-spaced mapdomain values.  glEvalMesh steps through the integer domain of a one- or two-dimensional grid, whose range isthe domain of the evaluation maps specified by glMap1 and glMap2.glMapGrid1  and  glMapGrid2  specify the linear grid mappings between the i (or i and j) integer grid coordi-nates, to the u (or u and v) floating-point evaluation map coordinates.  See glMap1 and glMap2 for details ofhow u and v coordinates are evaluated.glMapGrid1  specifies  a  single  linear  mapping such that integer grid coordinate 0 maps exactly to u1, andinteger grid coordinate un maps exactly to u2.  All other integer grid coordinates i are mapped so thatglMapGrid2 specifies two such linear mappings.  One maps integer grid coordinate i=0 exactly to u1, and inte-ger  grid coordinate i=un exactly to u2.  The other maps integer grid coordinate j=0 exactly to v1, and inte-ger grid coordinate j=vn exactly to v2.  Other integer grid coordinates i and j are mapped such that</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:map-grid-2 opengl nu u1 u2 nv v1 v2)</string>
	</dict>
	<key>gl:material</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>face</key>
			<string>constant face value *gl:front* *gl:back* *gl:back-and-front*</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>param</key>
			<string>one or more values for pname (either a vector or reals or an NSData object of floats)</string>
			<key>pname</key>
			<string>parameter name constant *gl:shininess* for example</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>specify a surface material for lighting</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:material opengl face pname param)</string>
	</dict>
	<key>gl:matrix-mode</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>mode</key>
			<string>mode constant</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Specify the current matrix</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:matrix-mode opengl mode)</string>
	</dict>
	<key>gl:mult-matrix</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>matrix</key>
			<string>Matrix representation (NSData object  (GLfloats))</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>see opengl documentation</string>
		</array>
		<key>related</key>
		<string>gl:load-matrix gl:mult-transpose-matrix gl:load-transpose-matrix gl:get</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:mult-matrix opengl matrix)</string>
	</dict>
	<key>gl:mult-transpose-matrix</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>matrix</key>
			<string>Matrix representation (NSData object  (GLfloats))</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>see opengl documentation</string>
		</array>
		<key>related</key>
		<string>gl:load-matrix gl:mult-matrix gl:load-transpose-matrix gl:get</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:mult-transpose-matrix opengl matrix)</string>
	</dict>
	<key>gl:multi-draw-elements</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>count</key>
			<string>number of geometric elements (of type) to draw</string>
			<key>count-data</key>
			<string>nsdata object containing array of verticies per shape</string>
			<key>index-data</key>
			<string>nsdata object containing indicies data</string>
			<key>mode</key>
			<string>how to draw the primitives (i.e. *gl:quads* *gl:polygon* etc.)</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>type</key>
			<string>the type of the indicies array data</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string></string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:multi-draw-elements opengl mode count-data type index-data count)</string>
	</dict>
	<key>gl:new-list</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>list</key>
			<string>as generated by gl:gen-lists</string>
			<key>mode</key>
			<string>compilation mode (such as *gl:compile*)</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>establish new display list</string>
		</array>
		<key>related</key>
		<string>gl:gen-lists gl:call-list</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:new-list opengl list mode)</string>
	</dict>
	<key>gl:normal-pointer</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data</key>
			<string>NSData object</string>
			<key>offset</key>
			<string>initial offset into data (number of bytes)</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>stride</key>
			<string>stride between elements (number of bytes)</string>
			<key>type</key>
			<string>data type (*gl:float* *gl:short* etc.)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>set normal array data</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:normal-pointer opengl type stride offset data)</string>
	</dict>
	<key>gl:open-opengl</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>frame</key>
			<string>size</string>
			<key>fullscreen</key>
			<string>boolean #t to set fullscreen</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>screen</key>
			<string>optional integer argument to set fullscreen to a particular screen</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>reopens a new window for an existing opengl instance</string>
		</array>
		<key>related</key>
		<string>gl:make-opengl gl:close-opengl</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:open-opengl opengl frame|fullscreen [screen])</string>
	</dict>
	<key>gl:ortho</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>bottom</key>
			<string>real value</string>
			<key>far</key>
			<string>real value</string>
			<key>left</key>
			<string>real value</string>
			<key>near</key>
			<string>real value</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>right</key>
			<string>real value</string>
			<key>top</key>
			<string>real value</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string></string>
		</array>
		<key>related</key>
		<string>gl:frustum glu:look-at</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:ortho opengl left right bottom top near far)</string>
	</dict>
	<key>gl:pixel-store</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>param</key>
			<string>a single value</string>
			<key>pname</key>
			<string>constant param name</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>sets pixel storage modes</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:pixel-store opengl pname param)</string>
	</dict>
	<key>gl:pixel-transfer</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>param</key>
			<string>param name (*gl:map-color*)  *gl:map-stencil* etc.)</string>
			<key>value</key>
			<string>real value</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Sets pixel transfer mode</string>
		</array>
		<key>related</key>
		<string>gl:raster-pos gl:window-pos gl:draw-pixels gl:copy-pixels</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:pixel-transfer opengl param value)</string>
	</dict>
	<key>gl:pixel-zoom</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>x</key>
			<string>x zoom amount</string>
			<key>y</key>
			<string>y zoom amount</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Sets magnification or reduction factors for pixel writing operations (gl:draw-pixels gl:copy-pixels)</string>
		</array>
		<key>related</key>
		<string>gl:copy-pixels gl:draw-pixels</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:pixel-zoom opengl x y)</string>
	</dict>
	<key>gl:polygon-mode</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>face</key>
			<string>face of the polygon *gl:front* *gl:back* or *gl:front-and-back*</string>
			<key>mode</key>
			<string>*gl:point* *gl:line* or *gl:fill*</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Controls the drawing mode for polygons</string>
		</array>
		<key>related</key>
		<string>gl:uniform</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:polygon-mode opengl face mode)</string>
	</dict>
	<key>gl:pop-matrix</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Pops a matrix off the top of the stack</string>
		</array>
		<key>related</key>
		<string>g:push-matrix</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:pop-matrix opengl)</string>
	</dict>
	<key>gl:program-parameter-ext</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>pname</key>
			<string>an integer for the parameter we wish to set: e.g. *gl:geometry-input-type-ext*, *gl:geometry-output-type-ext* etc..</string>
			<key>program</key>
			<string>the integer value associated with the shader program we wish to set the param in</string>
			<key>value</key>
			<string>an integer value that we wish to set</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>sets the parameter in program to value</string>
		</array>
		<key>returns</key>
		<string>nsnumber</string>
		<key>short</key>
		<string>(gl:program-parameter-ext program pname value)</string>
	</dict>
	<key>gl:push-matrix</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Pushes the current matrix onto a stack</string>
		</array>
		<key>related</key>
		<string>gl:pop-matrix</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:push-matrix opengl)</string>
	</dict>
	<key>gl:raster-pos</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>w</key>
			<string>w coordinate floating point</string>
			<key>x</key>
			<string>x coordinate floating point</string>
			<key>y</key>
			<string>y coordinate floating point</string>
			<key>z</key>
			<string>z coordinate floating point</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Sets raster position</string>
		</array>
		<key>related</key>
		<string>gl:window-pos gl:draw-pixels</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:raster-pos opengl x y [z] [w])</string>
	</dict>
	<key>gl:read-pixels</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>format</key>
			<string>format of image data *gl:rgb* or *gl:rgba* for example</string>
			<key>h</key>
			<string>height</string>
			<key>nsmutabledata</key>
			<string>nsmutabledata to store data in: you are responsible for constructing a nsmutabledata object of the correct size!</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>type</key>
			<string>type of image data *gl:unsigned-byte* or *gl:float* for example</string>
			<key>w</key>
			<string>width</string>
			<key>x</key>
			<string>x coordinate of lower left hand corner</string>
			<key>y</key>
			<string>y coordinate of lower left hand cornder</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Reads pixel data of format and type from x,y,w,h of opengl buffer into nsmutabledata</string>
		</array>
		<key>related</key>
		<string>gl:raster-pos gl:draw-pixels gl:copy-pixels</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:read-pixels opengl x y w h format type nsmutabledata)</string>
	</dict>
	<key>gl:rotate</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>angle</key>
			<string>in degrees</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>x</key>
			<string>real</string>
			<key>y</key>
			<string>real</string>
			<key>z</key>
			<string>real</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>rotate by angle around x y and z</string>
		</array>
		<key>related</key>
		<string>gl:translate gl:scale</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:rotate opengl angle x y z)</string>
	</dict>
	<key>gl:scale</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>x</key>
			<string>scale factor x</string>
			<key>y</key>
			<string>scale factor y</string>
			<key>z</key>
			<string>scale factor z</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>multiply the current matrix by a scaling factor</string>
		</array>
		<key>related</key>
		<string>gl:translate gl:rotate</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:scale opengl x y z)</string>
	</dict>
	<key>gl:secondary-color-pointer</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data</key>
			<string>NSData object</string>
			<key>offset</key>
			<string>initial offset into data (number of bytes)</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>size</key>
			<string>the number of arguments for color</string>
			<key>stride</key>
			<string>stride between elements (number of bytes)</string>
			<key>type</key>
			<string>data type (*gl:float* *gl:short* etc.)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>set secondary color data</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:secondary-color-pointer opengl)</string>
	</dict>
	<key>gl:shade-model</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>value</key>
			<string>contant value *gl:flat* *gl:smooth*</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>set flat or smooth shade model *gl:flat* *gl:smooth*</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:shade-model opengl value)</string>
	</dict>
	<key>gl:shader-source</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>shader</key>
			<string>the shader (index integer number)</string>
			<key>string|nsstring</key>
			<string>a single scheme string or an nsstring</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Attach source-string to shader</string>
		</array>
		<key>related</key>
		<string>gl:create-shader gl:compile-shader gl:shader-source gl:detach-shader gl:attach-shader</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:shader-source opengl shader {string || nsstring}</string>
	</dict>
	<key>gl:tex-coord-2d</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>q</key>
			<string>real</string>
			<key>r</key>
			<string>real</string>
			<key>s</key>
			<string>real</string>
			<key>t</key>
			<string>real</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string></string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:tex-coord-2d opengl s [t] [r] [q])</string>
	</dict>
	<key>gl:tex-coord-pointer</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data</key>
			<string>NSData object</string>
			<key>offset</key>
			<string>initial offset into data (number of bytes)</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>size</key>
			<string>the number of arguments for tex-coord (1 2 3 or 4)</string>
			<key>stride</key>
			<string>stride between elements (number of bytes)</string>
			<key>type</key>
			<string>data type (*gl:float* *gl:short* etc.)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>set the tex coord array data</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:tex-coord-pointer opengl size type stride offset data)</string>
	</dict>
	<key>gl:tex-env</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>param</key>
			<string>a single real number parameter value</string>
			<key>pname</key>
			<string>constant parameter name</string>
			<key>target</key>
			<string>target texture type</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>set texture param</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:tex-env opengl target pname param)</string>
	</dict>
	<key>gl:tex-image-2d</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>border</key>
			<string>specifies the width of the border (most be 0)</string>
			<key>data | image</key>
			<string>either an NSData object or an NSBitmapImageRep</string>
			<key>format</key>
			<string>specifies the format of data</string>
			<key>h</key>
			<string>height of texture (should be power of 2)</string>
			<key>internal-format</key>
			<string>internal format such as *gl:rgb8*</string>
			<key>level</key>
			<string>detail level (0)</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>target</key>
			<string>the target texture (*gl:texture-2d*)</string>
			<key>type</key>
			<string>the data type of the pixel data (*gl:unsinged-byte* for example)</string>
			<key>w</key>
			<string>width of texture (should be power of 2)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string></string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:tex-image-2d opengl target level internal-format w h border format type data|image)</string>
	</dict>
	<key>gl:tex-parameter</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>param</key>
			<string>parameter value</string>
			<key>pname</key>
			<string>constant parameter name</string>
			<key>target</key>
			<string>the target texture (*gl:texture-2d*)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string></string>
		</array>
		<key>related</key>
		<string>gl:gen-textures gl:tex-image-2d gl:bind-texture</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:tex-parameter opengl target pname param)</string>
	</dict>
	<key>gl:translate</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>x</key>
			<string>real</string>
			<key>y</key>
			<string>real</string>
			<key>z</key>
			<string>real</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>multiply the current matrix by a translation matrix</string>
		</array>
		<key>related</key>
		<string>gl:scale gl:rotate</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:translate opengl x y z)</string>
	</dict>
	<key>gl:uniform</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>location</key>
			<string>the location of the uniform variable</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>val</key>
			<string>1-4 integer or real number variables</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Sets the value of the uniform variable</string>
		</array>
		<key>related</key>
		<string>gl:uniform</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:uniform opengl location val [val2] [val3] [val4])</string>
	</dict>
	<key>gl:unmap-buffer</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>target</key>
			<string>either *gl:array-buffer* or *gl:element-array-buffer*</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>indicates that updates to the currently bound buffer object are complete and the buffer may be released (works in tandem with gl:map-buffer)</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:unmap-buffer opengl target)</string>
	</dict>
	<key>gl:update-backing-image</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Updates a bitmap backing image which mirrors the opengl canvas. This is used by gfx:start-movie-capture when rendering out an opengl canvas.  Call this whenever you want the opengl&apos;s backing image to be updated</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:update-backing-image opengl)</string>
	</dict>
	<key>gl:use-program</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>program</key>
			<string>the number of the program</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Use program to alter opengl operation</string>
		</array>
		<key>related</key>
		<string>gl:create-program gl:use-program gl:link-program</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:use-program opengl program</string>
	</dict>
	<key>gl:vertex</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>w</key>
			<string>optional real value</string>
			<key>x</key>
			<string>real value</string>
			<key>y</key>
			<string>real value</string>
			<key>z</key>
			<string>optional real value</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Specifies a vertex at x y with optional z and optional w</string>
		</array>
		<key>related</key>
		<string>gl:begin gl:end</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:vertex opengl x y [z] [w])</string>
	</dict>
	<key>gl:vertex-attrib</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>location</key>
			<string>the location of the uniform variable</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>val</key>
			<string>1-4 integer or real number variables</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>sets the value of the vertex attribute variable</string>
		</array>
		<key>related</key>
		<string>gl:uniform</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:vertex-attrib opengl location val [val2] [val3] [val4])</string>
	</dict>
	<key>gl:vertex-pointer</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data</key>
			<string>NSData object</string>
			<key>offset</key>
			<string>initial offset into data (number of bytes)</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>size</key>
			<string>the number of arguments for vertex (2 3 or 4)</string>
			<key>stride</key>
			<string>stride between elements (number of bytes)</string>
			<key>type</key>
			<string>data type (*gl:float* *gl:short* etc.)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>set vertex array data</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:vertex-pointer opengl size type stride offset data)</string>
	</dict>
	<key>gl:viewport</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>h</key>
			<string>height int</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>w</key>
			<string>width int</string>
			<key>x</key>
			<string>lower left x</string>
			<key>y</key>
			<string>lower left y</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>set the viewport</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:viewport opengl x y w h)</string>
	</dict>
	<key>gl:window-pos</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>x</key>
			<string>x coordinate floating point</string>
			<key>y</key>
			<string>y coordinate floating point</string>
			<key>z</key>
			<string>z coordinate floating point</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Sets window position</string>
		</array>
		<key>related</key>
		<string>gl:raster-pos gl:draw-pixels</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gl:window-pos opengl x y [z])</string>
	</dict>
	<key>glu:begin-curve</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>nurb</key>
			<string>a nurb (as returned by calling glu:new-nurbs-renderer)</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>get ready to draw a curve</string>
		</array>
		<key>related</key>
		<string>glu:begin-surface glu:end-curve glu:nurbs-curve</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(glu:begin-curve opengl nurb)</string>
	</dict>
	<key>glu:begin-surface</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>nurb</key>
			<string>a nurb (as returned by calling glu:new-nurbs-renderer)</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>get ready to draw a curved surface</string>
		</array>
		<key>related</key>
		<string>glu:end-surface glu:begin-curve glu:nurbs-surface</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(glu:begin-surface opengl nurb)</string>
	</dict>
	<key>glu:delete-nurbs-renderer</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>nurb</key>
			<string>nurb instance to destroy</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>deletes a nurbs object</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(glu:delete-nurbs-renderer opengl nurb)</string>
	</dict>
	<key>glu:end-curve</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>nurb</key>
			<string>a nurb (as returned by calling glu:new-nurbs-renderer)</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>finish drawing a curve</string>
		</array>
		<key>related</key>
		<string>glu:end-surface glu:begin-curve glu:nurbs-curve</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(glu:end-curve opengl nurb)</string>
	</dict>
	<key>glu:end-surface</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>nurb</key>
			<string>a nurb (as returned by calling glu:new-nurbs-renderer)</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>get ready to draw a curved surface</string>
		</array>
		<key>related</key>
		<string>glu:begin-surface glu:end-curve glu:nurbs-surface</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(glu:end-surface opengl nurb)</string>
	</dict>
	<key>glu:error-string</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>error-number</key>
			<string>integer number as returned by gl:error</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>returns an error string of error-number (as returned by gl:error)</string>
		</array>
		<key>related</key>
		<string>gl:error</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(glu:error-string opengl error-number)</string>
	</dict>
	<key>glu:get-nurbs-property</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>id</key>
			<string>enum of property id</string>
			<key>nurb</key>
			<string>a nurb (as returned by calling glu:new-nurbs-renderer)</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns the value of the nurbs property id.</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>real</string>
		<key>short</key>
		<string>(glu:get-nurbs-property opengl nurb id)</string>
	</dict>
	<key>glu:look-at</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>centre-x</key>
			<string>x of centre point</string>
			<key>centre-y</key>
			<string>y of centre point</string>
			<key>centre-z</key>
			<string>z of centre point</string>
			<key>eye-x</key>
			<string>x of view point</string>
			<key>eye-y</key>
			<string>y of view point</string>
			<key>eye-z</key>
			<string>z of view point</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>up-x</key>
			<string>x of up point</string>
			<key>up-y</key>
			<string>y of up point</string>
			<key>up-z</key>
			<string>z of up point</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>multiply the current matrix by a viewing transformation</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(glu:look-at opengl eye-x eye-y eye-z centre-x centre-y centre-z up-x up-y up-z)</string>
	</dict>
	<key>glu:new-nurbs-renderer</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>returns a new nurbs object</string>
		</array>
		<key>related</key>
		<string>glu:begin-surface glu:end-curve glu:nurbs-curve</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(glu:new-nurbs-renderer opengl)</string>
	</dict>
	<key>glu:nurbs-curve</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>knots</key>
			<string>an NSData object of 32bit floats.  One for each knot.</string>
			<key>nknots</key>
			<string>the number of knots (in knots)</string>
			<key>nurb</key>
			<string>a nurb (as returned by calling glu:new-nurbs-renderer)</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>points</key>
			<string>an NSData object of points.  each vertex is a 32bit float.  Each point is 3 or 4 verticies. (x y z) or (x y z w)</string>
			<key>poly-order</key>
			<string>the order of the polynomial.   Usually 4 for cubic</string>
			<key>stride</key>
			<string>stride (usually 3 or 4)</string>
			<key>type</key>
			<string>The type evaluator to use - things like *gl:map1-vertex-3* *gl:map2-vertex-3* etc..</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>get ready to draw a curve</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(glu:nurbs-curve opengl nurb nknots knots stride points poly-order type)</string>
	</dict>
	<key>glu:nurbs-property</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>id</key>
			<string>enum of property id</string>
			<key>nurb</key>
			<string>a nurb (as returned by calling glu:new-nurbs-renderer)</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>value</key>
			<string>real number value</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Set a nurbs property</string>
		</array>
		<key>related</key>
		<string>glu:begin-surface glu:end-curve glu:nurbs-curve</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(glu:nurbs-property opengl nurb id value)</string>
	</dict>
	<key>glu:nurbs-surface</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>knots</key>
			<string>an NSData object of 32bit floats.  One for each knot.</string>
			<key>nknots</key>
			<string>the number of knots (in knots)</string>
			<key>nurb</key>
			<string>a nurb (as returned by calling glu:new-nurbs-renderer)</string>
			<key>nvknots</key>
			<string>the number of vertical knots (in knots)</string>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>points</key>
			<string>an NSData object of points.  each vertex is a 32bit float.  Each point is 3 or 4 verticies. (x y z) or (x y z w)</string>
			<key>poly-order</key>
			<string>the order of the polynomial.   Usually 4 for cubic</string>
			<key>stride</key>
			<string>stride (usually 3 or 4)</string>
			<key>type</key>
			<string>The type evaluator to use - things like *gl:map1-vertex-3* *gl:map2-vertex-3* etc..</string>
			<key>vknots</key>
			<string>an NSData object of 32bit floats.  One for each vertical knot.</string>
			<key>vpoly-order</key>
			<string>the order of the vertical polynomial.   Usually 4 for cubic</string>
			<key>vstride</key>
			<string>vertical stride (usually 3 or 4)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>draw a surface</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(glu:nurbs-surface opengl nurb nknots knots nvknots vknots stride vstride points poly-order vpoly-order type)</string>
	</dict>
	<key>glu:perspective</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>aspect</key>
			<string>the aspect ratio</string>
			<key>far</key>
			<string>real far value for clipping plane</string>
			<key>fovy</key>
			<string>field of view in degrees</string>
			<key>near</key>
			<string>real near value for clipping plane</string>
			<key>opengl</key>
			<string>opengl instance</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>set up a perspective projection matrix</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(glu:perspective opengl fovy aspect near far)</string>
	</dict>
	<key>glut:solid-cube</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>size</key>
			<string>real size value</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>draws a solid cube</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(glut:solid-cube opengl size)</string>
	</dict>
	<key>glut:solid-sphere</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>radius</key>
			<string>real radius of the sphere</string>
			<key>slices</key>
			<string>integer slices</string>
			<key>stacks</key>
			<string>integer stacks</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>draws a solid sphere</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(glut:solid-sphere opengl radius slices stacks)</string>
	</dict>
	<key>glut:solid-teapot</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>size</key>
			<string>real size value</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>draws the classic opengl teapot</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(glut:solid-teapot opengl size)</string>
	</dict>
	<key>glut:wire-cube</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>size</key>
			<string>real size value</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>draws a wire cube</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(glut:wire-cube opengl size)</string>
	</dict>
	<key>glut:wire-sphere</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>radius</key>
			<string>real radius of the sphere</string>
			<key>slices</key>
			<string>integer slices</string>
			<key>stacks</key>
			<string>integer stacks</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>draws a wire frame sphere</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(glut:wire-sphere opengl radius slices stacks)</string>
	</dict>
	<key>glut:wire-teapot</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>opengl</key>
			<string>opengl instance</string>
			<key>size</key>
			<string>real size value</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>draws the classic opengl teapot</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(glut:wire-teapot opengl size)</string>
	</dict>
	<key>head</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For head</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(head)</string>
	</dict>
	<key>help</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>examples-bool</key>
			<string>optional bool #t if you want to display examples</string>
			<key>name</key>
			<string>name to show help on (help is a macro so name does not need to be quoted)</string>
			<key>path</key>
			<string>optional path to a directory where a copy of the help entry will be saved as an html file.</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(help osc-send)</string>
			<string>(help osc-send #f)</string>
			<string>(help osc-send &quot;/tmp/output/&quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>Help prints out help for the givem name (help is a macro). examples-bool is an optional boolean allowing examples to be printed as well.  path is a directory path which is provided saves an html copy of the help entry with the name of sym as the filename.html</string>
		</array>
		<key>related</key>
		<string>impromptu-help</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(help name [examples-bool] [path])</string>
	</dict>
	<key>help-entries</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns a vector of all help-entries as strings</string>
		</array>
		<key>returns</key>
		<string>vector</string>
		<key>short</key>
		<string>(help-entries)</string>
	</dict>
	<key>hyg:flatten</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For hyg:flatten</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(hyg:flatten)</string>
	</dict>
	<key>hyg:rassq</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For hyg:rassq</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(hyg:rassq)</string>
	</dict>
	<key>hyg:tag</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For hyg:tag</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(hyg:tag)</string>
	</dict>
	<key>hyg:untag</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For hyg:untag</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(hyg:untag)</string>
	</dict>
	<key>hyg:untag-do</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For hyg:untag-do</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(hyg:untag-do)</string>
	</dict>
	<key>hyg:untag-lambda</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For hyg:untag-lambda</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(hyg:untag-lambda)</string>
	</dict>
	<key>hyg:untag-let</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For hyg:untag-let</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(hyg:untag-let)</string>
	</dict>
	<key>hyg:untag-let*</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For hyg:untag-let*</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(hyg:untag-let*)</string>
	</dict>
	<key>hyg:untag-letrec</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For hyg:untag-letrec</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(hyg:untag-letrec)</string>
	</dict>
	<key>hyg:untag-list</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For hyg:untag-list</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(hyg:untag-list)</string>
	</dict>
	<key>hyg:untag-list*</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For hyg:untag-list*</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(hyg:untag-list*)</string>
	</dict>
	<key>hyg:untag-named-let</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For hyg:untag-named-let</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(hyg:untag-named-let)</string>
	</dict>
	<key>hyg:untag-no-tags</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For hyg:untag-no-tags</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(hyg:untag-no-tags)</string>
	</dict>
	<key>hyg:untag-quasiquote</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For hyg:untag-quasiquote</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(hyg:untag-quasiquote)</string>
	</dict>
	<key>hyg:untag-vanilla</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For hyg:untag-vanilla</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(hyg:untag-vanilla)</string>
	</dict>
	<key>if</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array>
			<string>(if (&gt; 3 2) &apos;yes &apos;no)        =&gt;  yes</string>
			<string>(if (&gt; 2 3) &apos;yes &apos;no)        =&gt;  no</string>
			<string>(if (&gt; 3 2)</string>
			<string>    (- 3 2)</string>
			<string>    (+ 3 2))                    =&gt;  1</string>
		</array>
		<key>long</key>
		<array>
			<string>Syntax: &lt;Test&gt;, &lt;consequent&gt;, and &lt;alternate&gt; may be arbitrary</string>
			<string>expressions.</string>
			<string></string>
			<string>Semantics: An if expression is evaluated as follows: first, &lt;test&gt; is</string>
			<string>evaluated.  If it yields a true value (see section 6.3.1), then</string>
			<string>&lt;consequent&gt; is evaluated and its value(s) is(are) returned.  Otherwise</string>
			<string>&lt;alternate&gt; is evaluated and its value(s) is(are) returned.  If &lt;test&gt;</string>
			<string>yields a false value and no &lt;alternate&gt; is specified, then the result</string>
			<string>of the expression is unspecified.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(if &lt;test&gt; &lt;consequent&gt; &lt;alternate&gt;)</string>
	</dict>
	<key>imp-rem</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>num1</key>
			<string>numerator</string>
			<key>num2</key>
			<string>denominator</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(imp-rem 100 24) =&gt; 4</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns the remainder of num1/num2</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(imp-rem num1 num2)</string>
	</dict>
	<key>impromptu-help</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>examples-bool</key>
			<string>optional bool #t if you want to display examples</string>
			<key>path</key>
			<string>optional path to a directory where a copy of the help entry will be saved as an html file.</string>
			<key>symbol</key>
			<string>symbol to show help on</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(impromptu-help &apos;play-note #t)</string>
		</array>
		<key>long</key>
		<array>
			<string>Function calling help on symbol</string>
		</array>
		<key>related</key>
		<string>help</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(impromptu-help symbol [bool] [path])</string>
	</dict>
	<key>impromptu_envs</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>For internal impromptu use only</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(impromptu_envs)</string>
	</dict>
	<key>inexact-&gt;exact</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>From inexact to exact</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(inexact-&gt;exact number)</string>
	</dict>
	<key>inexact?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For inexact?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(inexact? obj)</string>
	</dict>
	<key>input-output-port?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For input-output-port?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(input-output-port? obj)</string>
	</dict>
	<key>input-port?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For input-port?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(input-port? obj)</string>
	</dict>
	<key>integer-&gt;char</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>integer</key>
			<string>integer</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(char? (integer-&gt;char 99)) =&gt; #t</string>
		</array>
		<key>long</key>
		<array>
			<string>Coerce integer into char</string>
		</array>
		<key>returns</key>
		<string>char</string>
		<key>short</key>
		<string>(integer-&gt;char integer)</string>
	</dict>
	<key>integer?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>any scheme object</string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Predicate check for integer?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(integer? obj)</string>
	</dict>
	<key>interaction-environment</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns the top-level environment as if in a REPL</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(interaction-environment)</string>
	</dict>
	<key>io:alt-key-down</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array>
			<string>; print all keypresses</string>
			<string>(define alt-key-down</string>
			<string>   (lambda (key)</string>
			<string>      (print key)))</string>
		</array>
		<key>long</key>
		<array>
			<string>when alt-key-down is bound to a function accepting
	  one argument it will begin receiving all alt keystrokes. Impromptu
	  will then call this function whenever an alt-key is pressed
	  sending the key pressed as an argument to the
	  function.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(define io:alt-key-down (lambda (key) (print key)))</string>
	</dict>
	<key>io:alt-key-up</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array>
			<string>; print all keypresses</string>
			<string>(define alt-key-up</string>
			<string>   (lambda (key)</string>
			<string>      (print key)))</string>
		</array>
		<key>long</key>
		<array>
			<string>when alt-key-up is bound to a function accepting one
	  argument it will begin to recieve alt keystrokes. Impromptu
	  will then call this function whenever an alt-key is pressed
	  sending the key pressed as an argument to the
	  function.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(define io:alt-key-up (lambda (key) (print key)))</string>
	</dict>
	<key>io:binary-or</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>int</key>
			<string>integers to be and&apos;d together</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>binary and together &apos;n&apos; integer arguments</string>
		</array>
		<key>returns</key>
		<string>integer</string>
		<key>short</key>
		<string>(io:binary-and int1 int2 ...)</string>
	</dict>
	<key>io:caps-key-down</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>key</key>
			<string>the ascii key value of the caps key pressed</string>
		</dict>
		<key>examples</key>
		<array>
			<string>; engage caps-lock to receive caps key strokes</string>
			<string>; caps key down message</string>
			<string>(define io:caps-key-down</string>
			<string>   (lambda (key)</string>
			<string>      (if (assoc key key-map)</string>
			<string>          (start-note (now) inst (cdr (assoc key key-map)) 80)</string>
			<string>          (print &quot;BAD KEY PRESS&quot;))))</string>
			<string></string>
			<string>; engage caps-lock to receive caps key strokes</string>
			<string>; caps key up message</string>
			<string>(define io:caps-key-up</string>
			<string>   (lambda (key)</string>
			<string>      (if (assoc key key-map)</string>
			<string>          (stop-sound (now) inst (cdr (assoc key key-map)))</string>
			<string>          (print &quot;BAD KEY PRESS&quot;))))</string>
		</array>
		<key>long</key>
		<array>
			<string>Defining the function caps-key-down taking a single argument (key) will capture all caps lock key presses</string>
		</array>
		<key>related</key>
		<string>io:caps-key-up io:alt-key-up io:alt-key-down</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:caps-key-down key)</string>
	</dict>
	<key>io:caps-key-up</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>key</key>
			<string>ascii char key</string>
		</dict>
		<key>examples</key>
		<array>
			<string>; engage caps-lock to receive caps key strokes</string>
			<string>; caps key down message</string>
			<string>(define io:caps-key-down</string>
			<string>   (lambda (key)</string>
			<string>      (if (assoc key key-map)</string>
			<string>          (start-note (now) inst (cdr (assoc key key-map)) 80)</string>
			<string>          (print &quot;BAD KEY PRESS&quot;))))</string>
			<string></string>
			<string>; engage caps-lock to receive caps key strokes</string>
			<string>; caps key up message</string>
			<string>(define io:caps-key-up</string>
			<string>   (lambda (key)</string>
			<string>      (if (assoc key key-map)</string>
			<string>          (stop-sound (now) inst (cdr (assoc key key-map)))</string>
			<string>          (print &quot;BAD KEY PRESS&quot;))))</string>
		</array>
		<key>long</key>
		<array>
			<string>Defining the function caps-key-up taking a single argument (key) will capture all caps lock key depresses</string>
		</array>
		<key>related</key>
		<string>io:caps-key-down io:alt-key-down io:alt-key-up</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:caps-key-up key)</string>
	</dict>
	<key>io:delete-file</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>path</key>
			<string>posix path as a string</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>delete file at path</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(delete-file path)</string>
	</dict>
	<key>io:deregister-mouse-events</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>canvas</key>
			<string>canvas to stop receiving mouse events from</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(register-mouse-events *canvas*)	</string>
			<string></string>
			<string>(define (mouse-down x y)</string>
			<string>   (if (point-in-path? *path* x y)</string>
			<string>       (play-note (now) synth 74 80 1000)</string>
			<string>       (play-note (now) synth 50 80 1000)))	</string>
			<string></string>
			<string>(deregister-mouse-events *canvas*)</string>
		</array>
		<key>long</key>
		<array>
			<string>Stops the current process from receiving mouse events from canvas</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(deregister-mouse-events canvas)</string>
	</dict>
	<key>io:directory-list</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>path</key>
			<string>posix path as string</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns a directory listing of path</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:directory-list path)</string>
	</dict>
	<key>io:file-exists?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>path</key>
			<string>posix path to check (string)</string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>check that file exists at path</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:file-exists path)</string>
	</dict>
	<key>io:get-mouse-position</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>canvas</key>
			<string>optional canvas argument. if provided the mouse coordinate will be presented in relation to the canvas</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Return the mouse location as a coordinate of either (a) the current screen or (b) a [canvas] if supplied</string>
		</array>
		<key>related</key>
		<string>gfx:get-screen-size</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:get-mouse-position [canvas])</string>
	</dict>
	<key>io:log</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>string</key>
			<string>string to log</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Logs string to system console (not the log view)</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:log string)</string>
	</dict>
	<key>io:make-directory</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>path</key>
			<string>posix path of new directory</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Make directory</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:make-directory path)</string>
	</dict>
	<key>io:midi-destination</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>midi-device-number</key>
			<string>The number of the midi-devices output port</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns a midi destination port required for use in io:midi-out</string>
		</array>
		<key>related</key>
		<string>io:midi-out io:midi-in io:midi-source io:print-midi-devices io:print-midi-sources</string>
		<key>returns</key>
		<string>midi destination port</string>
		<key>short</key>
		<string>(io:midi-destination midi-device-number)</string>
	</dict>
	<key>io:midi-in</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>a</key>
			<string>byte 1</string>
			<key>b</key>
			<string>byte 2</string>
			<key>channel</key>
			<string>channel number</string>
			<key>device-id</key>
			<string>a unique id for the device that sent this message</string>
			<key>type</key>
			<string>the type of the midi message (i.e. #x9 for note-on).</string>
		</dict>
		<key>examples</key>
		<array>
			<string>; recieve midi events</string>
			<string>(define io:midi-in </string>
			<string>   (lambda (device-id type channel a b)</string>
			<string>      (cond ((= type *io:midi-on*) (my-note-on a b))</string>
			<string>            ((= type *io:midi-off*) (my-note-off a b)))))</string>
		</array>
		<key>long</key>
		<array>
			<string>define io:midi-in in the process that you specified when calling io:midi-register-events to start recieving midi messages.  Some constants are available for event types *io:midi-on* (note one) *io:midi-off* (note off) *io:midi-pc* (program change) *io:midi-cc* (control change)</string>
		</array>
		<key>related</key>
		<string>io:midi-register-events</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:midi-in device-id type channel a b)</string>
	</dict>
	<key>io:midi-out</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>a</key>
			<string>byte 1</string>
			<key>b</key>
			<string>bypte 2 is optional (a program change for example does not require byte 2)</string>
			<key>time</key>
			<string>time in samples to send midi message</string>
			<key>type</key>
			<string>the type of the midi message (i.e. #x9 for note-on).</string>
		</dict>
		<key>examples</key>
		<array>
			<string>; connect to output destination</string>
			<string>(define output-destination (io:midi-destination 0))</string>
			<string>; send midi program change 19 to channel 0</string>
			<string>(io:midi-out (now) output-destination *io:midi-pc* 0 19)</string>
			<string>; send value 22 to control change 16 on channel 2</string>
			<string>(io:midi-out (now) output-destination *io:midi-cc* 2 16 22)</string>
		</array>
		<key>long</key>
		<array>
			<string>Send midi to device (returned by the function connect-midi-destination or you can use *io:midi-virtual-device*).  Some constants are available for event types *io:midi-on* (note one) *io:midi-off* (note off) *io:midi-pc* (program change) *io:midi-cc* (control change).  You can use *io:midi-virtual-device* as a virtual device source</string>
		</array>
		<key>related</key>
		<string>io:midi-destination</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:midi-out time device type channel a [b])</string>
	</dict>
	<key>io:midi-register-events</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>process-name</key>
			<string>the name of the process you want to define io:midi-in in (defaults to &quot;primary process&quot;)</string>
		</dict>
		<key>examples</key>
		<array>
			<string>; recieve midi events</string>
			<string>(define io:midi-in </string>
			<string>   (lambda (device-id type channel a b)</string>
			<string>      (cond ((= type *io:midi-on*) (my-note-on a b))</string>
			<string>            ((= type *io:midi-off*) (my-note-off a b)))))</string>
		</array>
		<key>long</key>
		<array>
			<string>register a certain process (defaults to &quot;primary process&quot; to start receiving midi messages.  Impromptu will then start both real and virtual midi ports to start listening on.  You must also define the function io:midi-in in whatever process you specified with process-name.</string>
		</array>
		<key>related</key>
		<string>io:midi-in</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:midi-register-events [process-name])</string>
	</dict>
	<key>io:midi-source</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>midi-source-number</key>
			<string>The number of the midi source</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Register to receive midi data from source. returns an id number identifying the src.  this is the same id number is sent to midi-in</string>
		</array>
		<key>related</key>
		<string>io:midi-out io:midi-in io:midi-destination io:print-midi-devices io:print-midi-sources</string>
		<key>returns</key>
		<string>src id number</string>
		<key>short</key>
		<string>(io:midi-source midi-source-number)</string>
	</dict>
	<key>io:midi-sysex-out</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>device</key>
			<string>midi device to send sysex message to</string>
			<key>nsdata</key>
			<string>sysex data as uint8 nsdata object</string>
			<key>time</key>
			<string>time in samples to send sysex message</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(io:midi-sysex-out (now) device (objc:vector-&gt;nsdata-uint8 (vector #\xF0 #\x7F #\x7F #\x04 #\x01 #\xLL #\xMM #\xF7)))</string>
		</array>
		<key>long</key>
		<array>
			<string>Sends a midi sysex message of nsdata to device</string>
		</array>
		<key>related</key>
		<string>io:midi-out io:midi-in io:midi-destination io:print-midi-devices io:print-midi-sources</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:midi-source time device nsdata)</string>
	</dict>
	<key>io:mouse-down</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>canvas</key>
			<string>Pointer address of canvas that this event was sent from (you can check against objc:get-address)</string>
			<key>x</key>
			<string>x coordinate of mouse down</string>
			<key>y</key>
			<string>y coordinate of mouse down</string>
		</dict>
		<key>examples</key>
		<array>
			<string>; override mouse-down function to receive</string>
			<string>; mouse down events.  play pitch 80 when</string>
			<string>; click is inside the bounds of the *square*</string>
			<string>; otherwise play pitch 50.</string>
			<string>(define (io:mouse-down x y canvas)</string>
			<string>   (if (gfx:point-in-path? *square* x y)</string>
			<string>       (play-note (now) synth 74 80 5000 1)</string>
			<string>       (play-note (now) synth 50 80 5000)))	</string>
		</array>
		<key>long</key>
		<array>
			<string>Define mouse-down in order to start receiving mouse events. The default io:mouse-down updates the global variables *io:x* and *io:y*</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:mouse-down x y [canvas])</string>
	</dict>
	<key>io:mouse-drag</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>canvas</key>
			<string>Pointer address of canvas that this event was sent from (you can check against objc:get-address)</string>
			<key>x</key>
			<string>x coordinate of mouse drag</string>
			<key>y</key>
			<string>y coordinate of mouse drag</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define io:mouse-drag</string>
			<string>   (lambda (x y canvas)</string>
			<string>      (circles (now) (gfx:make-circle x y 10) 0)))	</string>
		</array>
		<key>long</key>
		<array>
			<string>Define mouse-drag to start receiving mouse-drag messages.  The default io:mouse-down updates the global variables *io:x* and *io:y*</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:mouse-drag x y [canvas])</string>
	</dict>
	<key>io:mouse-dropped</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>canvas</key>
			<string>Pointer address of canvas that this event was sent from (you can check against objc:get-address)</string>
			<key>pasteboard-name</key>
			<string>the name of the pasteboard which contains the data being dropped.  You can retreive the pasteboard by calling (objc:call &quot;NSPasteboard&quot; &quot;pasteboardWithName:&quot; pasteboard-name). See NSPasteboard for details.</string>
			<key>x</key>
			<string>x coordinate of mouse drag</string>
			<key>y</key>
			<string>y coordinate of mouse drag</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Define mouse-dropped to start receiving mouse-dropped messages.  You will also need to call (objc:call canvas &quot;registerForDraggedTypes:&quot; (objc:list-&gt;nsarray (list &quot;NSFilenamesPboardType&quot;))) to register to recieve filenames. For other types lookup NSPasteboard documentation.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:mouse-dropped x y pasteboard-name canvas)</string>
	</dict>
	<key>io:mouse-up</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>canvas</key>
			<string>Pointer address of canvas that this event was sent from (you can check against objc:get-address)</string>
			<key>x</key>
			<string>x coordinate</string>
			<key>y</key>
			<string>y coordinate</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;; Receives all mouse-up events</string>
			<string>;; set *current* to null when mouse button released</string>
			<string>(define (io:mouse-up x y)</string>
			<string>   (set! *current* &apos;()))</string>
		</array>
		<key>long</key>
		<array>
			<string>Define mouse up to start receiving mouse up messages</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:mouse-up x y [canvas])</string>
	</dict>
	<key>io:move-file</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>from-path</key>
			<string>posix path of file to move</string>
			<key>to-path</key>
			<string>posix path of destination</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Move directory from path to path</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:move-file from-path to-path)</string>
	</dict>
	<key>io:osc:receive</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>address</key>
			<string>osc address string</string>
			<key>args</key>
			<string>a list of osc arguments</string>
			<key>time</key>
			<string>a double value representing the time in seconds since 2001-01-01 (the reference time for NSDate)  -  if the message was sent without a time (i.e. not in a bundle) of the time is &apos;now&apos; then the message time is 0.0 (i.e. 2001-01-01)</string>
			<key>timestamp</key>
			<string>an osc timestamp which you can pass to objc:make-date</string>
		</dict>
		<key>examples</key>
		<array>
			<string>; setup simple au graph
(define buz (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))
(au:connect-node buz 0 *au:output-node* 0)
(au:update-graph)
(au:midi-out (now) buz *io:midi-pc* 0 57 0)

; Register this process to receive OSC events
(io:osc:start-server 7009)

; Receives &quot;/buz/start&quot; and &quot;/buz/stop&quot; messages
; Prints all other messages to the log
(define (io:osc:receive time address . args)
   (print &apos;secondary-process)
   (cond ((string=? address &quot;/buz/start&quot;)
          (start-note (now) buz (car args) (cadr args)))
         ((string=? address &quot;/buz/stop&quot;)
          (stop-note (now) buz (car args)))
         (else (print address &apos;-&gt; args))))

; Some test messages to send
(define addy (cons &quot;localhost&quot; 7009))
(io:osc:send (now) addy &quot;/buz/start&quot; 60 80)
(io:osc:send (now) addy &quot;/buz/stop&quot; 60)
;; by default reals and integers as sent in 32bits
(io:osc:send (+ (now) (* *second* 4)) addy &quot;/test/msg&quot; &quot;Hello&quot; 500 6.6 &quot;World&quot;)

;; if you want to send reals as doubles rather than floats call io:osc-set-real-64bit?
(io:osc:set-real-64bit? #t)
(io:osc:send (now) addy &quot;/test/msg&quot; (clock))

;; if you want to send integers as 64bit rather than 32bit call io:osc-set-integer-64bit?
(io:osc:send (now) addy &quot;/test/msg&quot; 12345678987654321)
(io:osc:set-integer-64bit? #t)
(io:osc:send (now) addy &quot;/test/msg&quot; 12345678987654321)

;; you can send an array of values by using a list
(io:osc:send (now) addy &quot;/test/array&quot; &quot;start&quot; (list 1 2 3 4 5) &quot;end&quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>Implement to start receiving OSC events after starting a server by calling io:osc:start-server</string>
		</array>
		<key>related</key>
		<string>io:osc:send io:osc:start-server</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:osc:receive timestamp address . args)</string>
	</dict>
	<key>io:osc:send</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>address</key>
			<string>OSC message address</string>
			<key>host</key>
			<string>cons of hostname and port number (cons &quot;localhost&quot; 7009)</string>
			<key>time</key>
			<string>time in samples</string>
		</dict>
		<key>examples</key>
		<array>
			<string>; setup simple au graph
(define buz (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))
(au:connect-node buz 0 *au:output-node* 0)
(au:update-graph)
(au:midi-out (now) buz *io:midi-pc* 0 57 0)

; Register this process to receive OSC events
(io:osc:start-server 7009)

; Receives &quot;/buz/start&quot; and &quot;/buz/stop&quot; messages
; Prints all other messages to the log
(define (io:osc:receive time address . args)
   (print &apos;secondary-process)
   (cond ((string=? address &quot;/buz/start&quot;)
          (start-note (now) buz (car args) (cadr args)))
         ((string=? address &quot;/buz/stop&quot;)
          (stop-note (now) buz (car args)))
         (else (print address &apos;-&gt; args))))

; Some test messages to send
(define addy (cons &quot;localhost&quot; 7009))
(io:osc:send (now) addy &quot;/buz/start&quot; 60 80)
(io:osc:send (now) addy &quot;/buz/stop&quot; 60)
;; by default reals and integers as sent in 32bits
(io:osc:send (+ (now) (* *second* 4)) addy &quot;/test/msg&quot; &quot;Hello&quot; 500 6.6 &quot;World&quot;)

;; if you want to send reals as doubles rather than floats call io:osc-set-real-64bit?
(io:osc:set-real-64bit? #t)
(io:osc:send (now) addy &quot;/test/msg&quot; (clock))

;; if you want to send integers as 64bit rather than 32bit call io:osc-set-integer-64bit?
(io:osc:send (now) addy &quot;/test/msg&quot; 12345678987654321)
(io:osc:set-integer-64bit? #t)
(io:osc:send (now) addy &quot;/test/msg&quot; 12345678987654321)

;; you can send an array of values by using a list
(io:osc:send (now) addy &quot;/test/array&quot; &quot;start&quot; (list 1 2 3 4 5) &quot;end&quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>Sends an OSC mssage to host (where host is a cons&apos;d pair of hostname -string- and port number -integer-).  You can send integers (defaults 32bit) , reals (defaults 32bit), strings, lists of a given type (as arrays), NSData objects (of less than 7k bytes).  If you wish to send 64bit reals or 64bit ints you can call io:osc:set-real-64bit? or io:osc:set-integer-64bit? </string>
		</array>
		<key>related</key>
		<string>io:osc:receive io:osc:start-server</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:osc:send time host address . args)</string>
	</dict>
	<key>io:osc:set-integer-64bit?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>bool</key>
			<string>true to send reals as 64bit values, false to send reals as 32bit values</string>
		</dict>
		<key>examples</key>
		<array>
			<string>; setup simple au graph
(define buz (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))
(au:connect-node buz 0 *au:output-node* 0)
(au:update-graph)
(au:midi-out (now) buz *io:midi-pc* 0 57 0)

; Register this process to receive OSC events
(osc:start-server 7099)

; Receives &quot;/buz/start&quot; and &quot;/buz/stop&quot; messages
; Prints all other messages to the log
(define (io:osc:receive time address . args)
   (print &apos;secondary-process)
   (cond ((string=? address &quot;/buz/start&quot;)
          (start-note (now) buz (car args) (cadr args)))
         ((string=? address &quot;/buz/stop&quot;)
          (stop-note (now) buz (car args)))
         (else (print address &apos;-&gt; args))))

; Some test messages to send
(define primary (cons &quot;localhost&quot; 7009))
(define secondary (cons &quot;localhost&quot; 7099))
(io:osc:send (now) addy &quot;/buz/start&quot; 60 80)
(io:osc:send (now) addy &quot;/buz/stop&quot; 60)
;; by default reals and integers as sent in 32bits
(io:osc:send (+ (now) (* *second* 4)) addy &quot;/test/msg&quot; &quot;Hello&quot; 500 6.6 &quot;World&quot;)

;; if you want to send reals as doubles rather than floats call io:osc-set-real-64bit?
(io:osc:set-real-64bit? #t)
(io:osc:send (now) primary &quot;/test/msg&quot; (clock))

;; if you want to send integers as 64bit rather than 32bit call io:osc-set-integer-64bit?
(io:osc:set-integer-64bit? #f)
(io:osc:send (now) secondary &quot;/test/msg&quot; 12345678987654321)

;; you can send an array of values by using a list
(io:osc:send (now) addy &quot;/test/array&quot; &quot;start&quot; (list 1 2 3 4 5) &quot;end&quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>Set to #t to send 64bit values else set to #f to send 32bit values (default is 32bit)</string>
		</array>
		<key>related</key>
		<string>io:osc:receive io:osc:start-server</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:osc:set-integer-64bit? bool)</string>
	</dict>
	<key>io:osc:set-real-64bit?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>bool</key>
			<string>true to send reals as 64bit values, false to send reals as 32bit values</string>
		</dict>
		<key>examples</key>
		<array>
			<string>; setup simple au graph
(define buz (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))
(au:connect-node buz 0 *au:output-node* 0)
(au:update-graph)
(au:midi-out (now) buz *io:midi-pc* 0 57 0)

; Register this process to receive OSC events
(io:osc:start-server 7009)

; Receives &quot;/buz/start&quot; and &quot;/buz/stop&quot; messages
; Prints all other messages to the log
(define (io:osc:receive time address . args)
   (print &apos;secondary-process)
   (cond ((string=? address &quot;/buz/start&quot;)
          (start-note (now) buz (car args) (cadr args)))
         ((string=? address &quot;/buz/stop&quot;)
          (stop-note (now) buz (car args)))
         (else (print address &apos;-&gt; args))))

; Some test messages to send
(define addy (cons &quot;localhost&quot; 7009))
(io:osc:send (now) addy &quot;/buz/start&quot; 60 80)
(io:osc:send (now) addy &quot;/buz/stop&quot; 60)
;; by default reals and integers as sent in 32bits
(io:osc:send (+ (now) (* *second* 4)) addy &quot;/test/msg&quot; &quot;Hello&quot; 500 6.6 &quot;World&quot;)

;; if you want to send reals as doubles rather than floats call io:osc-set-real-64bit?
(io:osc:set-real-64bit? #t)
(io:osc:send (now) addy &quot;/test/msg&quot; (clock))

;; if you want to send integers as 64bit rather than 32bit call io:osc-set-integer-64bit?
(io:osc:send (now) addy &quot;/test/msg&quot; 12345678987654321)
(io:osc:set-integer-64bit? #t)
(io:osc:send (now) addy &quot;/test/msg&quot; 12345678987654321)

;; you can send an array of values by using a list
(io:osc:send (now) addy &quot;/test/array&quot; &quot;start&quot; (list 1 2 3 4 5) &quot;end&quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>Set to #t to send 64bit values else set to #f to send 32bit values (default is 32bit)</string>
		</array>
		<key>related</key>
		<string>io:osc:receive io:osc:start-server</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:osc:set-real-64bit? bool)</string>
	</dict>
	<key>io:osc:start-server</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>port</key>
			<string>Port number to listen for OSC UDP messages</string>
		</dict>
		<key>examples</key>
		<array>
			<string>; setup simple au graph
(define buz (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))
(au:connect-node buz 0 *au:output-node* 0)
(au:update-graph)
(au:midi-out (now) buz *io:midi-pc* 0 57 0)

; Register this process to receive OSC events
(io:osc:start-server 7009)

; Receives &quot;/buz/start&quot; and &quot;/buz/stop&quot; messages
; Prints all other messages to the log
(define (io:osc:receive time address . args)
   (print &apos;secondary-process)
   (cond ((string=? address &quot;/buz/start&quot;)
          (start-note (now) buz (car args) (cadr args)))
         ((string=? address &quot;/buz/stop&quot;)
          (stop-note (now) buz (car args)))
         (else (print address &apos;-&gt; args))))

; Some test messages to send
(define addy (cons &quot;localhost&quot; 7009))
(io:osc:send (now) addy &quot;/buz/start&quot; 60 80)
(io:osc:send (now) addy &quot;/buz/stop&quot; 60)
;; by default reals and integers as sent in 32bits
(io:osc:send (+ (now) (* *second* 4)) addy &quot;/test/msg&quot; &quot;Hello&quot; 500 6.6 &quot;World&quot;)

;; if you want to send reals as doubles rather than floats call io:osc-set-real-64bit?
(io:osc:set-real-64bit? #t)
(io:osc:send (now) addy &quot;/test/msg&quot; (clock))

;; if you want to send integers as 64bit rather than 32bit call io:osc-set-integer-64bit?
(io:osc:send (now) addy &quot;/test/msg&quot; 12345678987654321)
(io:osc:set-integer-64bit? #t)
(io:osc:send (now) addy &quot;/test/msg&quot; 12345678987654321)

;; you can send an array of values by using a list
(io:osc:send (now) addy &quot;/test/array&quot; &quot;start&quot; (list 1 2 3 4 5) &quot;end&quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>Starts an OSC server running on a given port number.  You may start one OSC server per impromptu process.  Each server must have a unique port.  You must implement io:osc:receive to start receiving messages from the server.</string>
		</array>
		<key>related</key>
		<string>io:osc:send io:osc:receive</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:osc:start-server port)</string>
	</dict>
	<key>io:print-midi-devices</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>print midi devices to the log view</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:print-midi-devices)</string>
	</dict>
	<key>io:print-midi-id</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>id</key>
			<string>midi device id</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>print midi id to the log view. this is the id sent to midi-in as the first argument</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:print-midi-id id)</string>
	</dict>
	<key>io:print-midi-sources</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>print a list of midi sources to the log view</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:print-midi-sources)</string>
	</dict>
	<key>io:read-midi-file</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string>;; setup audio unit graph</string>
			<string>(define synth (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))</string>
			<string>(au:connect-node synth 0 *au:output-node* 0)</string>
			<string>(au:update-graph)</string>
			<string>;; send program change to dls audio units</string>
			<string>(au:midi-out (now) synth *midi-pc* 68 0) ; oboe</string>
			<string>(au:midi-out (now) synth *midi-pc* 71 1) ; clarinet</string>
			<string>(au:midi-out (now) synth *midi-pc* 60 2) ; horn</string>
			<string>(au:midi-out (now) synth *midi-pc* 70 3) ; bassoon</string>
			<string>;; read midi file</string>
			<string>(define chorale (io:read-midi-file &quot;/tmp/bach.mid&quot;))</string>
			<string>;; marker</string>
			<string>; Events can have a marker number attached to them</string>
			<string>; to allow us to mute/ignore them even after they have been</string>
			<string>; scheduled. (See below).</string>
			<string>(define marker 100)</string>
			<string>;; Play a MIDI track</string>
			<string>; The list-ref function is an Impromptu function that </string>
			<string>; allows the acceesing of elements within a list by index.</string>
			<string>; The consing of the play-note time and marker attaches</string>
			<string>; the marker number of the note events (start and stop).</string>
			<string>(define (play-seq time inst midi-track chan)</string>
			<string>   (map (lambda (t p v r)</string>
			<string>           (play-note (cons (+ time (* t *second*)) marker) inst p v (* r *second*) chan))</string>
			<string>        (list-ref midi-track 0)</string>
			<string>        (list-ref midi-track 1)</string>
			<string>        (list-ref midi-track 2)</string>
			<string>        (list-ref midi-track 3)))</string>
			<string>;; Play the first four tracks</string>
			<string>(define (chorale-player time score)</string>
			<string>   (play-seq time synth (list-ref score 3) 0)</string>
			<string>   (play-seq time synth (list-ref score 2) 1)</string>
			<string>   (play-seq time synth (list-ref score 1) 2)</string>
			<string>   (play-seq time synth (list-ref score 0) 3))</string>
			<string>;; Start - give play-seq 2 seconds to load the file.</string>
			<string>(chorale-player (+ (now) (* *second* 2)) chorale)</string>
		</array>
		<key>long</key>
		<array>
			<string>Reads a midi file and returns a list structure represeting that midi-file.  the stucture is one list per track.  each track list is seperated into lists of start-times pitches volumes and durations(in beats).  trying reading a simple midi-file and printing the result to the log.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:read-midi-file file-path)</string>
	</dict>
	<key>io:register-mouse-events</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>view</key>
			<string>canvas or opengl</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Lets a particular canvas or opengl view know that this scheme interpreter wants to receive mouse events</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:register-mouse-events view)</string>
	</dict>
	<key>io:right-mouse-down</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>x</key>
			<string>x coordinate</string>
			<key>y</key>
			<string>y coordinate</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>see mouse-down</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:right-mouse-down x y)</string>
	</dict>
	<key>io:right-mouse-drag</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>x</key>
			<string>x coordinate</string>
			<key>y</key>
			<string>y coordinate</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>see mouse-drag</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:right-mouse-drag x y)</string>
	</dict>
	<key>io:right-mouse-up</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>x</key>
			<string>x coordinate</string>
			<key>y</key>
			<string>y coordinate</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>see mouse-up</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(right-mouse-up x y)</string>
	</dict>
	<key>io:send-port-message</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>function-name</key>
			<string>the name of the function (as a string) taking one argument that should be sent nsdata</string>
			<key>hostname</key>
			<string>hostname string - IP address or hostname</string>
			<key>nsdata</key>
			<string>an objc NSData object to be sent to function-name in process-name on hostname</string>
			<key>process-name</key>
			<string>optional process-name string - defaults to &quot;primary process&quot;</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Sends an nsdata object to hostname&apos;s process-name&apos;s function-name</string>
		</array>
		<key>related</key>
		<string>objc:call objc:make</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:send-port-message hostname [process-name] function-name nsdata)</string>
	</dict>
	<key>io:set-caps-through</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Allow all caps key strokes to be captured by caps-key-down and up but also sent to the editor screen. allows you to do things like trigger sounds while adding text to the editor</string>
		</array>
		<key>related</key>
		<string>io:caps-key-down io:caps-key-up</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:set-caps-through)</string>
	</dict>
	<key>io:tcp:connect-to-server</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>hostname</key>
			<string>the host to connect to</string>
			<key>port</key>
			<string>the integer port number to connect to</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;; server side
;;
;; collect all client connections in *server-connections*
(define *server-connections* &apos;())

;; connection listener will be called for each new client connection
;; you are responsible for maintaining the list of client connections
;; the listener function accepts one integer argument specifying the 
;; socket that the client is connected on
;; You can call io:tcp:get-streams-from-socket to retrieve streams
;; that you can read from and write to.
(define connection-listener
   (lambda (socket)
      (print &apos;connection-on-socket socket)
      (let ((streams (io:tcp:get-streams-from-socket socket)))
         (set! *server-connections* (cons streams *server-connections*)))))


;; start server listening on port 9696 (or choose your own)
;; pass the process that you&apos;re running the server on 
;; and the name listener function to call back to
(io:tcp:start-server 9696 (ipc:get-process-name) &quot;connection-listener&quot;)


;; start a server polling to check for incoming client data
;; this is where you do your thing!
(define server-data-polling
   (lambda ()
      (dotimes (i (length *server-connections*))
         (if (io:tcp:data-available? (list-ref *server-connections* i))
             (let ((new-data (io:tcp:read-from-stream (list-ref *server-connections* i) 256)))
                (print (objc:make &quot;NSString&quot; &quot;initWithData:encoding:&quot; new-data 4)))))
      (callback (+ (now) 5000) &apos;server-data-polling)))

(server-data-polling)


;;
;; client side
;;
;; establish a connection to a server 
(define streams-to-server (io:tcp:connect-to-server &quot;localhost&quot; 9696))

;; send some data to the server
(io:tcp:write-to-stream streams-to-server 
                        (objc:call (objc:string-&gt;nsstring &quot;hello world&quot;) 
                                   &quot;dataUsingEncoding:&quot; 4))</string>
		</array>
		<key>long</key>
		<array>
			<string>returns a pair of streams (read and write) for reading and writing from and to the specified host:port (see example code for more detail)</string>
		</array>
		<key>returns</key>
		<string>objc streams object (NSArray containing one NSInputStream and one NSOutputStream)</string>
		<key>short</key>
		<string>(io:tcp:connect-to-server hostname port)</string>
	</dict>
	<key>io:tcp:data-available?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>streams</key>
			<string>a streams object (as returned by io:tcp:get-streams-from-socket or io:tcp:connect-to-server) or an NSInputStream</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;; server side
;;
;; collect all client connections in *server-connections*
(define *server-connections* &apos;())

;; connection listener will be called for each new client connection
;; you are responsible for maintaining the list of client connections
;; the listener function accepts one integer argument specifying the 
;; socket that the client is connected on
;; You can call io:tcp:get-streams-from-socket to retrieve streams
;; that you can read from and write to.
(define connection-listener
   (lambda (socket)
      (print &apos;connection-on-socket socket)
      (let ((streams (io:tcp:get-streams-from-socket socket)))
         (set! *server-connections* (cons streams *server-connections*)))))


;; start server listening on port 9696 (or choose your own)
;; pass the process that you&apos;re running the server on 
;; and the name listener function to call back to
(io:tcp:start-server 9696 (ipc:get-process-name) &quot;connection-listener&quot;)


;; start a server polling to check for incoming client data
;; this is where you do your thing!
(define server-data-polling
   (lambda ()
      (dotimes (i (length *server-connections*))
         (if (io:tcp:data-available? (list-ref *server-connections* i))
             (let ((new-data (io:tcp:read-from-stream (list-ref *server-connections* i) 256)))
                (print (objc:make &quot;NSString&quot; &quot;initWithData:encoding:&quot; new-data 4)))))
      (callback (+ (now) 5000) &apos;server-data-polling)))

(server-data-polling)


;;
;; client side
;;
;; establish a connection to a server 
(define streams-to-server (io:tcp:connect-to-server &quot;localhost&quot; 9696))

;; send some data to the server
(io:tcp:write-to-stream streams-to-server 
                        (objc:call (objc:string-&gt;nsstring &quot;hello world&quot;) 
                                   &quot;dataUsingEncoding:&quot; 4))</string>
		</array>
		<key>long</key>
		<array>
			<string>reports on whether input data is avaialble for reading</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:tcp:data-available? streams)</string>
	</dict>
	<key>io:tcp:get-streams-from-socket</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>socket</key>
			<string>integer socket number</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;; server side
;;
;; collect all client connections in *server-connections*
(define *server-connections* &apos;())

;; connection listener will be called for each new client connection
;; you are responsible for maintaining the list of client connections
;; the listener function accepts one integer argument specifying the 
;; socket that the client is connected on
;; You can call io:tcp:get-streams-from-socket to retrieve streams
;; that you can read from and write to.
(define connection-listener
   (lambda (socket)
      (print &apos;connection-on-socket socket)
      (let ((streams (io:tcp:get-streams-from-socket socket)))
         (set! *server-connections* (cons streams *server-connections*)))))


;; start server listening on port 9696 (or choose your own)
;; pass the process that you&apos;re running the server on 
;; and the name listener function to call back to
(io:tcp:start-server 9696 (ipc:get-process-name) &quot;connection-listener&quot;)


;; start a server polling to check for incoming client data
;; this is where you do your thing!
(define server-data-polling
   (lambda ()
      (dotimes (i (length *server-connections*))
         (if (io:tcp:data-available? (list-ref *server-connections* i))
             (let ((new-data (io:tcp:read-from-stream (list-ref *server-connections* i) 256)))
                (print (objc:make &quot;NSString&quot; &quot;initWithData:encoding:&quot; new-data 4)))))
      (callback (+ (now) 5000) &apos;server-data-polling)))

(server-data-polling)


;;
;; client side
;;
;; establish a connection to a server 
(define streams-to-server (io:tcp:connect-to-server &quot;localhost&quot; 9696))

;; send some data to the server
(io:tcp:write-to-stream streams-to-server 
                        (objc:call (objc:string-&gt;nsstring &quot;hello world&quot;) 
                                   &quot;dataUsingEncoding:&quot; 4))</string>
		</array>
		<key>long</key>
		<array>
			<string>returns a pair of streams (read and write) for reading and writing from and to the socket (see example code for more detail)</string>
		</array>
		<key>returns</key>
		<string>objc streams object (NSArray containing one NSInputStream and one NSOutputStream)</string>
		<key>short</key>
		<string>(io:tcp:get-streams-from-socket socket)</string>
	</dict>
	<key>io:tcp:read-from-stream</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>max-bytes-to-read</key>
			<string>the maxiumum number of bytes to read from stream</string>
			<key>stream</key>
			<string>a streams object (as returned by io:tcp:get-streams-from-socket or io:tcp:connect-to-server) or an NSInputStream</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;; server side
;;
;; collect all client connections in *server-connections*
(define *server-connections* &apos;())

;; connection listener will be called for each new client connection
;; you are responsible for maintaining the list of client connections
;; the listener function accepts one integer argument specifying the 
;; socket that the client is connected on
;; You can call io:tcp:get-streams-from-socket to retrieve streams
;; that you can read from and write to.
(define connection-listener
   (lambda (socket)
      (print &apos;connection-on-socket socket)
      (let ((streams (io:tcp:get-streams-from-socket socket)))
         (set! *server-connections* (cons streams *server-connections*)))))


;; start server listening on port 9696 (or choose your own)
;; pass the process that you&apos;re running the server on 
;; and the name listener function to call back to
(io:tcp:start-server 9696 (ipc:get-process-name) &quot;connection-listener&quot;)


;; start a server polling to check for incoming client data
;; this is where you do your thing!
(define server-data-polling
   (lambda ()
      (dotimes (i (length *server-connections*))
         (if (io:tcp:data-available? (list-ref *server-connections* i))
             (let ((new-data (io:tcp:read-from-stream (list-ref *server-connections* i) 256)))
                (print (objc:make &quot;NSString&quot; &quot;initWithData:encoding:&quot; new-data 4)))))
      (callback (+ (now) 5000) &apos;server-data-polling)))

(server-data-polling)


;;
;; client side
;;
;; establish a connection to a server 
(define streams-to-server (io:tcp:connect-to-server &quot;localhost&quot; 9696))

;; send some data to the server
(io:tcp:write-to-stream streams-to-server 
                        (objc:call (objc:string-&gt;nsstring &quot;hello world&quot;) 
                                   &quot;dataUsingEncoding:&quot; 4))</string>
		</array>
		<key>long</key>
		<array>
			<string>returns any available data from streams. this call will block the entire process if no data is available so ensure to call io:tcp:data-avilable? before calling io:tcp:read-from-stream</string>
		</array>
		<key>returns</key>
		<string>NSData object (read data)</string>
		<key>short</key>
		<string>(io:tcp:read-from-stream stream max-bytes-to-read)</string>
	</dict>
	<key>io:tcp:start-server</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>function-name</key>
			<string>the name of the function to callback into</string>
			<key>port</key>
			<string>port to listen on (integer)</string>
			<key>process-name</key>
			<string>which process will receive connection notifications (can call (ipc:get-process-name))</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;; server side
;;
;; collect all client connections in *server-connections*
(define *server-connections* &apos;())

;; connection listener will be called for each new client connection
;; you are responsible for maintaining the list of client connections
;; the listener function accepts one integer argument specifying the 
;; socket that the client is connected on
;; You can call io:tcp:get-streams-from-socket to retrieve streams
;; that you can read from and write to.
(define connection-listener
   (lambda (socket)
      (print &apos;connection-on-socket socket)
      (let ((streams (io:tcp:get-streams-from-socket socket)))
         (set! *server-connections* (cons streams *server-connections*)))))


;; start server listening on port 9696 (or choose your own)
;; pass the process that you&apos;re running the server on 
;; and the name listener function to call back to
(io:tcp:start-server 9696 (ipc:get-process-name) &quot;connection-listener&quot;)


;; start a server polling to check for incoming client data
;; this is where you do your thing!
(define server-data-polling
   (lambda ()
      (dotimes (i (length *server-connections*))
         (if (io:tcp:data-available? (list-ref *server-connections* i))
             (let ((new-data (io:tcp:read-from-stream (list-ref *server-connections* i) 256)))
                (print (objc:make &quot;NSString&quot; &quot;initWithData:encoding:&quot; new-data 4)))))
      (callback (+ (now) 5000) &apos;server-data-polling)))

(server-data-polling)


;;
;; client side
;;
;; establish a connection to a server 
(define streams-to-server (io:tcp:connect-to-server &quot;localhost&quot; 9696))

;; send some data to the server
(io:tcp:write-to-stream streams-to-server 
                        (objc:call (objc:string-&gt;nsstring &quot;hello world&quot;) 
                                   &quot;dataUsingEncoding:&quot; 4))</string>
		</array>
		<key>long</key>
		<array>
			<string>starts a TCP server listening on &lt;port&gt;.  Incoming client connections will call &lt;function-name&gt; in &lt;process-name&gt; passing a single socket (integer) argument.  io:tcp:get-streams-from-socket will return a pair of read/write streams that you can then use to communicate through.  See example code for an example server/client.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:tcp:start-server port process-name function-name)</string>
	</dict>
	<key>io:tcp:writable</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>streams</key>
			<string>a streams object (as returned by io:tcp:get-streams-from-socket or io:tcp:connect-to-server) or an NSOutputStream</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;; server side
;;
;; collect all client connections in *server-connections*
(define *server-connections* &apos;())

;; connection listener will be called for each new client connection
;; you are responsible for maintaining the list of client connections
;; the listener function accepts one integer argument specifying the 
;; socket that the client is connected on
;; You can call io:tcp:get-streams-from-socket to retrieve streams
;; that you can read from and write to.
(define connection-listener
   (lambda (socket)
      (print &apos;connection-on-socket socket)
      (let ((streams (io:tcp:get-streams-from-socket socket)))
         (set! *server-connections* (cons streams *server-connections*)))))


;; start server listening on port 9696 (or choose your own)
;; pass the process that you&apos;re running the server on 
;; and the name listener function to call back to
(io:tcp:start-server 9696 (ipc:get-process-name) &quot;connection-listener&quot;)


;; start a server polling to check for incoming client data
;; this is where you do your thing!
(define server-data-polling
   (lambda ()
      (dotimes (i (length *server-connections*))
         (if (io:tcp:data-available? (list-ref *server-connections* i))
             (let ((new-data (io:tcp:read-from-stream (list-ref *server-connections* i) 256)))
                (print (objc:make &quot;NSString&quot; &quot;initWithData:encoding:&quot; new-data 4)))))
      (callback (+ (now) 5000) &apos;server-data-polling)))

(server-data-polling)


;;
;; client side
;;
;; establish a connection to a server 
(define streams-to-server (io:tcp:connect-to-server &quot;localhost&quot; 9696))

;; send some data to the server
(io:tcp:write-to-stream streams-to-server 
                        (objc:call (objc:string-&gt;nsstring &quot;hello world&quot;) 
                                   &quot;dataUsingEncoding:&quot; 4))</string>
		</array>
		<key>long</key>
		<array>
			<string>reports on whether an output stream is ready for writing</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(io:tcp:writable? streams)</string>
	</dict>
	<key>io:tcp:write-to-stream</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data</key>
			<string>nsdata object to write to stream</string>
			<key>stream</key>
			<string>a streams object (as returned by io:tcp:get-streams-from-socket or io:tcp:connect-to-server) or an NSOutputStream</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;; server side
;;
;; collect all client connections in *server-connections*
(define *server-connections* &apos;())

;; connection listener will be called for each new client connection
;; you are responsible for maintaining the list of client connections
;; the listener function accepts one integer argument specifying the 
;; socket that the client is connected on
;; You can call io:tcp:get-streams-from-socket to retrieve streams
;; that you can read from and write to.
(define connection-listener
   (lambda (socket)
      (print &apos;connection-on-socket socket)
      (let ((streams (io:tcp:get-streams-from-socket socket)))
         (set! *server-connections* (cons streams *server-connections*)))))


;; start server listening on port 9696 (or choose your own)
;; pass the process that you&apos;re running the server on 
;; and the name listener function to call back to
(io:tcp:start-server 9696 (ipc:get-process-name) &quot;connection-listener&quot;)


;; start a server polling to check for incoming client data
;; this is where you do your thing!
(define server-data-polling
   (lambda ()
      (dotimes (i (length *server-connections*))
         (if (io:tcp:data-available? (list-ref *server-connections* i))
             (let ((new-data (io:tcp:read-from-stream (list-ref *server-connections* i) 256)))
                (print (objc:make &quot;NSString&quot; &quot;initWithData:encoding:&quot; new-data 4)))))
      (callback (+ (now) 5000) &apos;server-data-polling)))

(server-data-polling)


;;
;; client side
;;
;; establish a connection to a server 
(define streams-to-server (io:tcp:connect-to-server &quot;localhost&quot; 9696))

;; send some data to the server
(io:tcp:write-to-stream streams-to-server 
                        (objc:call (objc:string-&gt;nsstring &quot;hello world&quot;) 
                                   &quot;dataUsingEncoding:&quot; 4))</string>
		</array>
		<key>long</key>
		<array>
			<string>writes data to output stream</string>
		</array>
		<key>returns</key>
		<string>NSData object (read data)</string>
		<key>short</key>
		<string>(io:tcp:write-from-stream stream data)</string>
	</dict>
	<key>ipc:call</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>args</key>
			<string>any arguments required by the function being called</string>
			<key>func-symbol</key>
			<string>symbol bound to function to call</string>
			<key>process-name</key>
			<string>string name of process to call into</string>
			<key>remote-proc-name</key>
			<string>This is an optional argument which needs to be used when using ipc:call between remote hosts.  Remote-proc-name gives the name that the remote hosts uses to call the local host.  In other words the remote-proc-name specifies the name given to the connection to the current process from the remove host.  It is needed so that the result can be sent back from the remote host to the local host.</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define pp &quot;primary process&quot;)
(define up &quot;utility process&quot;)

;; mutiply 2 * 3 in the primary process
(define result (ipc:call pp &apos;* 2 3))
(print result)

;; if you don&apos;t need to wait for a return
;; result you can use ipc:call-async instead
(print (ipc:call-async np &apos;* 2 3))
;; note that print prints #t not 6
;; because ipc:call-async does not return
;; the result of calling (* 2 3)

;; mutiple 2 * 4 in the utility process
(define result (ipc:call up &apos;* 2 4))
(print result)

;; create a new process on port 33333
(define np &quot;new process&quot;)
(ipc:new-process np 33333)

;; divide 15 / 3 in new process and print result
(print (ipc:call np &apos;/ 15 3))

;; define a closure called my-sqr
;; in new process
(ipc:define np &apos;my-sqr (lambda (x) (* x x)))
;; try calling my-sqr in current process
;; doesn&apos;t work huh :)
(print (my-sqr 5))
;; now called my-sqr in new process 
(print (ipc:call np &apos;my-sqr 5))

;; connect to a process running on a remote host
(define rp &quot;remote process&quot;)
;; ideally replace &quot;127.0.0.1&quot; with a 
;; hostname or ip address on your network
(ipc:connect-to-process rp &quot;127.0.0.1&quot; 33333)
;; if you used 127.0.0.1 you will now
;; have two names pointing to the process
;; running on port 33333 on you localhost
;; if you used a remote ip you should have
;; first started a process on port 33333
;; in an impromptu session running on that host
;; and make sure there&apos;s no firewall blocking
;; that port number.

;; create an nsarray
(define myarray (objc:list-&gt;nsarray &apos;(1 2 3 4 5)))
(print myarray)
;; you can only pass objective-c objects
;; to a remote process over ipc
;; if you first encode them as strings
;; you encode using objc:string-encode
;; you decode using objc:string-decode
;;
;; like this
(ipc:define rp &apos;my-objc-object (lambda (str) (print (objc:string-decode str))))
(ipc:call rp &apos;my-objc-object (objc:string-encode myarray))

;; you can send most scheme primitives to ipc calls
;; you cannot send ports or environments
(ipc:call rp &apos;print 
          #t #f &apos;() &apos;symbol
          (vector 1 2 3) (list 1 2 (list 3 4 5)) (cons &quot;a&quot; &quot;b&quot;) 
          &quot;string&quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>A synchronous call to the function bound to func-symbol in process-name.  ipc:call returns the result of evaluating the remote function.  If you are using ipc:call to call a remote host you will need to supply the optional remote-proc-name.  The remote-proc-name argument is not required for local interprocess communicaton </string>
		</array>
		<key>related</key>
		<string>ipc:define ipc:new-process</string>
		<key>returns</key>
		<string>result of remote call</string>
		<key>short</key>
		<string>(ipc:call process-name [remote-proc-name] func-symbol . args)</string>
	</dict>
	<key>ipc:call-async</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>args</key>
			<string>any arguments required by the function being called</string>
			<key>func-symbol</key>
			<string>symbol bound to function to call</string>
			<key>process-name</key>
			<string>string name of process to call into</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define pp &quot;primary process&quot;)
(define up &quot;utility process&quot;)

;; mutiply 2 * 3 in the primary process
(define result (ipc:call pp &apos;* 2 3))
(print result)

;; if you don&apos;t need to wait for a return
;; result you can use ipc:call-async instead
(print (ipc:call-async np &apos;* 2 3))
;; note that print prints #t not 6
;; because ipc:call-async does not return
;; the result of calling (* 2 3)

;; mutiple 2 * 4 in the utility process
(define result (ipc:call up &apos;* 2 4))
(print result)

;; create a new process on port 33333
(define np &quot;new process&quot;)
(ipc:new-process np 33333)

;; divide 15 / 3 in new process and print result
(print (ipc:call np &apos;/ 15 3))

;; define a closure called my-sqr
;; in new process
(ipc:define np &apos;my-sqr (lambda (x) (* x x)))
;; try calling my-sqr in current process
;; doesn&apos;t work huh :)
(print (my-sqr 5))
;; now called my-sqr in new process 
(print (ipc:call np &apos;my-sqr 5))

;; connect to a process running on a remote host
(define rp &quot;remote process&quot;)
;; ideally replace &quot;127.0.0.1&quot; with a 
;; hostname or ip address on your network
(ipc:connect-to-process rp &quot;127.0.0.1&quot; 33333)
;; if you used 127.0.0.1 you will now
;; have two names pointing to the process
;; running on port 33333 on you localhost
;; if you used a remote ip you should have
;; first started a process on port 33333
;; in an impromptu session running on that host
;; and make sure there&apos;s no firewall blocking
;; that port number.

;; create an nsarray
(define myarray (objc:list-&gt;nsarray &apos;(1 2 3 4 5)))
(print myarray)
;; you can only pass objective-c objects
;; to a remote process over ipc
;; if you first encode them as strings
;; you encode using objc:string-encode
;; you decode using objc:string-decode
;;
;; like this
(ipc:define rp &apos;my-objc-object (lambda (str) (print (objc:string-decode str))))
(ipc:call rp &apos;my-objc-object (objc:string-encode myarray))

;; you can send most scheme primitives to ipc calls
;; you cannot send ports or environments
(ipc:call rp &apos;print 
          #t #f &apos;() &apos;symbol
          (vector 1 2 3) (list 1 2 (list 3 4 5)) (cons &quot;a&quot; &quot;b&quot;) 
          &quot;string&quot; (lambda (x) (* x x)))</string>
		</array>
		<key>long</key>
		<array>
			<string>Calls the function bound to func-symbol in process-name.  This is an asynchrous call and does not return a value.</string>
		</array>
		<key>related</key>
		<string>ipc:define ipc:new-process</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(ipc:call-async process-name func-symbol . args)</string>
	</dict>
	<key>ipc:connect-to-process</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>hsot</key>
			<string>the host to connect to</string>
			<key>name</key>
			<string>the name that you wish to label the process you are connecting to</string>
			<key>port</key>
			<string>port number to connect to</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(ipc:connect-to-process &quot;my process label&quot; &quot;192.168.1.20&quot; 7012)</string>
		</array>
		<key>long</key>
		<array>
			<string>Programatically connects to a remote scheme process</string>
		</array>
		<key>related</key>
		<string>ipc:define ipc:call ipc:new-process</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(ipc:connect-to-process name host port)</string>
	</dict>
	<key>ipc:def</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>For internal use only</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(ipc:def)</string>
	</dict>
	<key>ipc:define</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>process-name</key>
			<string>a string naming the process</string>
			<key>symbol</key>
			<string>the symbol to bind value to in process-name</string>
			<key>value</key>
			<string>value to bind to symbol</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define pp &quot;primary process&quot;)
(define up &quot;utility process&quot;)

;; mutiply 2 * 3 in the primary process
(define result (ipc:call pp &apos;* 2 3))
(print result)

;; if you don&apos;t need to wait for a return
;; result you can use ipc:call-async instead
(print (ipc:call-async np &apos;* 2 3))
;; note that print prints #t not 6
;; because ipc:call-async does not return
;; the result of calling (* 2 3)

;; mutiple 2 * 4 in the utility process
(define result (ipc:call up &apos;* 2 4))
(print result)

;; create a new process on port 33333
(define np &quot;new process&quot;)
(ipc:new-process np 33333)

;; divide 15 / 3 in new process and print result
(print (ipc:call np &apos;/ 15 3))

;; define a closure called my-sqr
;; in new process
(ipc:define np &apos;my-sqr (lambda (x) (* x x)))
;; try calling my-sqr in current process
;; doesn&apos;t work huh :)
(print (my-sqr 5))
;; now called my-sqr in new process 
(print (ipc:call np &apos;my-sqr 5))

;; connect to a process running on a remote host
(define rp &quot;remote process&quot;)
;; ideally replace &quot;127.0.0.1&quot; with a 
;; hostname or ip address on your network
(ipc:connect-to-process rp &quot;127.0.0.1&quot; 33333)
;; if you used 127.0.0.1 you will now
;; have two names pointing to the process
;; running on port 33333 on you localhost
;; if you used a remote ip you should have
;; first started a process on port 33333
;; in an impromptu session running on that host
;; and make sure there&apos;s no firewall blocking
;; that port number.

;; create an nsarray
(define myarray (objc:list-&gt;nsarray &apos;(1 2 3 4 5)))
(print myarray)
;; you can only pass objective-c objects
;; to a remote process over ipc
;; if you first encode them as strings
;; you encode using objc:string-encode
;; you decode using objc:string-decode
;;
;; like this
(ipc:define rp &apos;my-objc-object (lambda (str) (print (objc:string-decode str))))
(ipc:call rp &apos;my-objc-object (objc:string-encode myarray))

;; you can send most scheme primitives to ipc calls
;; you cannot send ports or environments
(ipc:call rp &apos;print 
          #t #f &apos;() &apos;symbol
          (vector 1 2 3) (list 1 2 (list 3 4 5)) (cons &quot;a&quot; &quot;b&quot;) 
          &quot;string&quot; (lambda (x) (* x x)))</string>
		</array>
		<key>long</key>
		<array>
			<string>Define sym in process named by process-name string</string>
		</array>
		<key>related</key>
		<string>ipc:call ipc:new-process</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(ipc:define process-name symbol value)</string>
	</dict>
	<key>ipc:eval-string</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>process</key>
			<string>a scheme process to evaluate in</string>
			<key>string</key>
			<string>a scheme string containing a valid scheme expression</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Evaluates the given string in a particular process</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>bool</string>
		<key>short</key>
		<string>(ipc:eval-string process string)</string>
	</dict>
	<key>ipc:load</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>path</key>
			<string>the fully qualified path to the file</string>
			<key>proc-name</key>
			<string>the process name</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Loads the scm file at path into the process named proc-name</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>bool</string>
		<key>short</key>
		<string>(ipc:load proc-name path)</string>
	</dict>
	<key>ipc:new-process</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>proc-name</key>
			<string>string name to name the new process</string>
			<key>proc-port</key>
			<string>port number for new process repl</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(ipc:new-process &quot;my process&quot; 7012)</string>
		</array>
		<key>long</key>
		<array>
			<string>Programatically creates a new impromptu process named proc-name bound to proc-port</string>
		</array>
		<key>related</key>
		<string>ipc:define ipc:call ipc:call-async</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(ipc:new-process proc-name proc-port)</string>
	</dict>
	<key>lambda</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array>
			<string>((lambda x x) 3 4 5 6)          =&gt;  (3 4 5 6)</string>
			<string>((lambda (x y . z) z) 3 4 5 6)  =&gt;  (5 6)</string>
		</array>
		<key>long</key>
		<array>
			<string>Syntax: &lt;Formals&gt; should be a formal arguments list as described below,
and &lt;body&gt; should be a sequence of one or more expressions.

Semantics: A lambda expression evaluates to a procedure.  The
environment in effect when the lambda expression was evaluated is
remembered as part of the procedure.  When the procedure is later
called with some actual arguments, the environment in which the lambda
expression was evaluated will be extended by binding the variables in
the formal argument list to fresh locations, the corresponding actual
argument values will be stored in those locations, and the expressions
in the body of the lambda expression will be evaluated sequentially in
the extended environment.  The result(s) of the last expression in the
body will be returned as the result(s) of the procedure call.

       (lambda (x) (+ x x))      =&gt;  a procedure
       ((lambda (x) (+ x x)) 4)  =&gt;  8

       (define reverse-subtract
         (lambda (x y) (- y x)))
       (reverse-subtract 7 10)         =&gt;  3

       (define add4
         (let ((x 4))
           (lambda (y) (+ x y))))
       (add4 6)                        =&gt;  10

&lt;Formals&gt; should have one of the following forms:

(&lt;variable1&gt; ...)
     The procedure takes a fixed number of arguments; when the
     procedure is called, the arguments will be stored in the bindings
     of the corresponding variables.

&lt;variable&gt;
     The procedure takes any number of arguments; when the procedure is
     called, the sequence of actual arguments is converted into a newly
     allocated list, and the list is stored in the binding of the
     &lt;variable&gt;.

(&lt;variable1&gt; ... &lt;variablen&gt; . &lt;variablen+1&gt;)
     If a space-delimited period precedes the last variable, then the
     procedure takes n or more arguments, where n is the number of
     formal arguments before the period (there must be at least one).
     The value stored in the binding of the last variable will be a
     newly allocated list of the actual arguments left over after all
     the other actual arguments have been matched up against the other
     formal arguments.
</string>
		</array>
		<key>returns</key>
		<string>The created function/closure</string>
		<key>short</key>
		<string>(lambda &lt;formals&gt; &lt;body&gt;)</string>
	</dict>
	<key>last-pair</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>lst</key>
			<string>a scheme list</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(last-pair &apos;(1 2 3 4 5)) =&gt; (5)</string>
		</array>
		<key>long</key>
		<array>
			<string>Return the last pair of list lst</string>
		</array>
		<key>returns</key>
		<string>pair</string>
		<key>short</key>
		<string>(last-pair lst)</string>
	</dict>
	<key>lcm</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>int1</key>
			<string>integer</string>
			<key>int2</key>
			<string>integer</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(lcm 4 5) =&gt; 20</string>
		</array>
		<key>long</key>
		<array>
			<string>Find the lowest common multiple for two integers</string>
		</array>
		<key>returns</key>
		<string>integer</string>
		<key>short</key>
		<string>(lcm int1 int2)</string>
	</dict>
	<key>length</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>lst</key>
			<string>list</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(length &apos;(1 2 3 4 5)) =&gt; 5</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns the number of elements in lst</string>
		</array>
		<key>returns</key>
		<string>integer</string>
		<key>short</key>
		<string>(length lst)</string>
	</dict>
	<key>let</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array>
			<string>(let ((x 2) (y 3))</string>
			<string>   (* x y))                      =&gt;  6</string>
			<string></string>
			<string>(let ((x 2) (y 3))</string>
			<string>   (let ((x 7)</string>
			<string>         (z (+ x y)))</string>
			<string>     (* z x)))                   =&gt;  35</string>
		</array>
		<key>long</key>
		<array>
			<string>Syntax: &lt;Bindings&gt; should have the form</string>
			<string></string>
			<string>         ((&lt;variable1&gt; &lt;init1&gt;) ...)</string>
			<string></string>
			<string>where each &lt;init&gt; is an expression, and &lt;body&gt; should be a sequence of</string>
			<string>one or more expressions.  It is an error for a &lt;variable&gt; to appear</string>
			<string>more than once in the list of variables being bound.</string>
			<string></string>
			<string>Semantics: The &lt;init&gt;s are evaluated in the current environment (in some</string>
			<string>unspecified order), the &lt;variable&gt;s are bound to fresh locations</string>
			<string>holding the results, the &lt;body&gt; is evaluated in the extended</string>
			<string>environment, and the value(s) of the last expression of &lt;body&gt; is(are)</string>
			<string>returned.  Each binding of a &lt;variable&gt; has &lt;body&gt; as its region.</string>
		</array>
		<key>returns</key>
		<string>the result of evaluating the last expression in the body</string>
		<key>short</key>
		<string>(let &lt;bindings&gt; &lt;body&gt;)</string>
	</dict>
	<key>let*</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string>(let ((x 2) (y 3))</string>
			<string>   (let* ((x 7)</string>
			<string>          (z (+ x y)))</string>
			<string>      (* z x)))             =&gt;  70</string>
		</array>
		<key>long</key>
		<array>
			<string>Syntax: &lt;Bindings&gt; should have the form</string>
			<string></string>
			<string>         ((&lt;variable1&gt; &lt;init1&gt;) ...),</string>
			<string></string>
			<string>and &lt;body&gt; should be a sequence of one or more expressions.</string>
			<string></string>
			<string>Semantics: Let* is similar to let, but the bindings are performed</string>
			<string>sequentially from left to right, and the region of a binding indicated</string>
			<string>by (&lt;variable&gt; &lt;init&gt;) is that part of the let* expression to the right</string>
			<string>of the binding.  Thus the second binding is done in an environment in</string>
			<string>which the first binding is visible, and so on.</string>
		</array>
		<key>returns</key>
		<string>the result of evaluating the last expression in the body</string>
		<key>short</key>
		<string>(let* &lt;bindings&gt; &lt;body&gt;)</string>
	</dict>
	<key>letrec</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array>
			<string>(letrec ((even?</string>
			<string>         (lambda (n)</string>
			<string>            (if (zero? n)</string>
			<string>                #t</string>
			<string>                (odd? (- n 1)))))</string>
			<string>         (odd?</string>
			<string>          (lambda (n)</string>
			<string>             (if (zero? n)</string>
			<string>                 #f</string>
			<string>                 (even? (- n 1))))))</string>
			<string>         (even? 88))</string>
			<string>                       =&gt;  #t</string>
		</array>
		<key>long</key>
		<array>
			<string>Syntax: &lt;Bindings&gt; should have the form</string>
			<string></string>
			<string>         ((&lt;variable1&gt; &lt;init1&gt;) ...),</string>
			<string></string>
			<string>and &lt;body&gt; should be a sequence of one or more expressions. It is an</string>
			<string>error for a &lt;variable&gt; to appear more than once in the list of</string>
			<string>variables being bound.</string>
			<string></string>
			<string>Semantics: The &lt;variable&gt;s are bound to fresh locations holding</string>
			<string>undefined values, the &lt;init&gt;s are evaluated in the resulting</string>
			<string>environment (in some unspecified order), each &lt;variable&gt; is assigned to</string>
			<string>the result of the corresponding &lt;init&gt;, the &lt;body&gt; is evaluated in the</string>
			<string>resulting environment, and the value(s) of the last expression in</string>
			<string>&lt;body&gt; is(are) returned.  Each binding of a &lt;variable&gt; has the entire</string>
			<string>letrec expression as its region, making it possible to define mutually</string>
			<string>recursive procedures.</string>
			<string></string>
			<string></string>
			<string>One restriction on letrec is very important: it must be possible to</string>
			<string>evaluate each &lt;init&gt; without assigning or referring to the value of any</string>
			<string>&lt;variable&gt;.  If this restriction is violated, then it is an error.  The</string>
			<string>restriction is necessary because Scheme passes arguments by value</string>
			<string>rather than by name.  In the most common uses of letrec, all the</string>
			<string>&lt;init&gt;s are lambda expressions and the restriction is satisfied</string>
			<string>automatically.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(letrec &lt;bindings&gt; &lt;body&gt;)</string>
	</dict>
	<key>list</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj1</key>
			<string>scheme objects</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(list &apos;fred 1 &quot;fred&quot;) =&gt; (fred 1 &quot;fred&quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>Creates a list from the supplied objects</string>
		</array>
		<key>returns</key>
		<string>list</string>
		<key>short</key>
		<string>(list obj1 obj2 ... objn)</string>
	</dict>
	<key>list*</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For list*</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(list*)</string>
	</dict>
	<key>list-&gt;string</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>char-list</key>
			<string>a list of characters</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(list-&gt;string &apos;(#\h #\e #\l #\l #\o)) =&gt; &quot;hello&quot;</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns a string made from the characters in char-list</string>
		</array>
		<key>returns</key>
		<string>string</string>
		<key>short</key>
		<string>(list-&gt;string char-list)</string>
	</dict>
	<key>list-&gt;vector</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>lst</key>
			<string>a scheme list</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(list-&gt;vector &apos;(a b c d)) =&gt; #(a b c d)</string>
		</array>
		<key>long</key>
		<array>
			<string>Return vector made from elements of list</string>
		</array>
		<key>returns</key>
		<string>vector</string>
		<key>short</key>
		<string>(list-&gt;vector lst)</string>
	</dict>
	<key>list-ref</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>k</key>
			<string>index into list</string>
			<key>lst</key>
			<string>a scheme list</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(list-ref &apos;(a b c d) 2) =&gt; c</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns the kth element of list</string>
		</array>
		<key>returns</key>
		<string>object</string>
		<key>short</key>
		<string>(list-ref lst k)</string>
	</dict>
	<key>list-tail</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>k</key>
			<string>index into scheme list</string>
			<key>lst</key>
			<string>a scheme list</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(list-tail &apos;(a b c d) 2) =&gt; (c d)</string>
		</array>
		<key>long</key>
		<array>
			<string>Obtains the sublist of lst by ignoring the first k elements</string>
		</array>
		<key>returns</key>
		<string>list</string>
		<key>short</key>
		<string>(list-tail lst k)</string>
	</dict>
	<key>list?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>any scheme object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Predicate check for list</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(list? obj)</string>
	</dict>
	<key>load</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>path</key>
			<string>a fully qualified path string</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(load &quot;/tmp/myfile.scm&quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>Reads and evaluates the scheme file located at path</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(load path-string)</string>
	</dict>
	<key>log</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>num</key>
			<string>number</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(log 50) =&gt; 3.91202</string>
			<string>(log 5.5) =&gt; 1.70475</string>
		</array>
		<key>long</key>
		<array>
			<string>Computes the natural logarithm of num</string>
		</array>
		<key>returns</key>
		<string>number</string>
		<key>short</key>
		<string>(log num)</string>
	</dict>
	<key>macro</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string>(macro (myprint form)</string>
			<string>    `(print ,@(cdr form)))</string>
			<string></string>
			<string>(macro-expand &apos;(myprint &apos;me &apos;you &apos;us &apos;them))</string>
			<string>(myprint &apos;me &apos;you &apos;us &apos;them)</string>
		</array>
		<key>long</key>
		<array>
			<string>Creates a non-hygenic macro.  Form is the whole form includeing the macro name.  See example below.</string>
		</array>
		<key>related</key>
		<string>define-macro macro-expand</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(macro (symbol form) body)</string>
	</dict>
	<key>macro-expand</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>expr</key>
			<string>a list containing a expression</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define-macro (myprint a b . rest)</string>
			<string>    `(print ,a ,b ,@rest))</string>
			<string></string>
			<string>(macro-expand &apos;(myprint &apos;me &apos;you &apos;us &apos;them))</string>
		</array>
		<key>long</key>
		<array>
			<string>Expand expr where expr is a list containing a macro expression</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(macro-expand expr)</string>
	</dict>
	<key>macro?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>a valid scheme object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Predicate check for macro</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(macro? obj)</string>
	</dict>
	<key>make-closure</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Create a closure from code and env</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(make-closure code env)</string>
	</dict>
	<key>make-envelope</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>points</key>
			<string>either a list of pairs ((x . y) (x . y)) or a flat vector #(x y x y)</string>
			<key>whole-num?</key>
			<string>should we round all results to whole integer value?. this is an optional argument and defaults to #f.</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;; load instrument</string>
			<string>(define inst (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))</string>
			<string>(au:connect-node inst 0 *au:output-node* 0)</string>
			<string>(au:update-graph)</string>
			<string></string>
			<string>; program change</string>
			<string>(au:midi-out (now) inst *io:midi-pc* 0 8 0)</string>
			<string></string>
			<string>;; x is time and is spread at one beat intervals (i.e. 1.0 2.0 3.0 4.0 etc.)</string>
			<string>;; y is random between 0 - 127</string>
			<string>(define x (make-vector-with-proc 60 (lambda (i) i)))</string>
			<string>(define y (make-vector-with-proc 60 (lambda (i) (random 40 100))))</string>
			<string></string>
			<string>;; create a combined vector of 60 points</string>
			<string>(define points (make-vector 120))</string>
			<string>(vector= points x &apos;(0 60 2))</string>
			<string>(vector= points y &apos;(1 60 2))</string>
			<string>(print points)</string>
			<string></string>
			<string>;; createv envelope from points</string>
			<string>(define env (make-envelope points #t))</string>
			<string></string>
			<string>;; play for length of envelope (60.0 beats) choosing pitches and volumes from env</string>
			<string>;; note: values retured from envelope may not be whole numbers and may need rounding</string>
			<string>(define loop</string>
			<string>   (lambda (time beats)</string>
			<string>      (play-note time inst </string>
			<string>                 (quantize-pc (env beats) &apos;(0 2 4 7 9)) </string>
			<string>                 (- 127 (round (env beats)))</string>
			<string>                 22050)</string>
			<string>      (if (&lt; beats 60) </string>
			<string>          (callback (+ time 2000) loop </string>
			<string>                    (+ time 2756) </string>
			<string>                    (+ 0.125 beats))</string>
			<string>          (print &quot;DONE&quot;))))</string>
			<string></string>
			<string>;; start</string>
			<string>(loop (now) 0.0)	</string>
		</array>
		<key>long</key>
		<array>
			<string>Creates an evelope using points which can be either a list of pairs ((x . y) (x . y)) or a flat vector #(x y x y)</string>
		</array>
		<key>returns</key>
		<string>closure</string>
		<key>short</key>
		<string>(make-envelope points [whole-num?])</string>
	</dict>
	<key>make-list</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>k</key>
			<string>number of elements</string>
			<key>obj</key>
			<string>the object to fill each element</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(make-list 5 &apos;a)  =&gt; (a a a a a)</string>
		</array>
		<key>long</key>
		<array>
			<string>Creates a list of k elements setting each element to obj</string>
		</array>
		<key>returns</key>
		<string>list</string>
		<key>short</key>
		<string>(make-list k obj)</string>
	</dict>
	<key>make-list-with-proc</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>func</key>
			<string>any function taking one argument</string>
			<key>k</key>
			<string>number of elements</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(make-list-with-proc 5 (lambda (i) (* i 2))) =&gt; (0 2 4 6 8)</string>
		</array>
		<key>long</key>
		<array>
			<string>Creates a list of k elements setting each element to the result of applying the function with an index argument</string>
		</array>
		<key>returns</key>
		<string>list</string>
		<key>short</key>
		<string>(make-list-with-proc k func)</string>
	</dict>
	<key>make-metro</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>tempo</key>
			<string>the tempo to start the metronome at</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Creates and returns a metronome to the user.  The user can then use the metronome to work in beats rather than samples.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(make-metro tempo)</string>
	</dict>
	<key>make-string</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>char</key>
			<string>optional char to put in each element of string</string>
			<key>k</key>
			<string>number of chars in string</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(make-string 5 &apos;#\i) =&gt; &quot;iiiii&quot;</string>
		</array>
		<key>long</key>
		<array>
			<string>Create a mutable string of length k filled with char.  This is the way to create a mutable string.</string>
		</array>
		<key>returns</key>
		<string>string</string>
		<key>short</key>
		<string>(make-string k [char])</string>
	</dict>
	<key>make-vector</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>k</key>
			<string>number of elements in vector</string>
			<key>obj</key>
			<string>sheme object to put in each element</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(make-vector 5 &apos;a) =&gt; #(a a a a a)</string>
		</array>
		<key>long</key>
		<array>
			<string>Make a vector of k elements each filled with obj</string>
		</array>
		<key>related</key>
		<string>make-vector-with-proc make-list</string>
		<key>returns</key>
		<string>vector</string>
		<key>short</key>
		<string>(make-vector k [obj])</string>
	</dict>
	<key>make-vector-with-proc</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>func</key>
			<string>a function taking one index argument</string>
			<key>k</key>
			<string>elements in vector</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(make-vector-with-proc k (lambda (i) (* i 2))) =&gt; #(0 2 4 6 8)</string>
		</array>
		<key>long</key>
		<array>
			<string>Make a vector of k elements where each element is the result of applying func</string>
		</array>
		<key>related</key>
		<string>make-vector make-list-with-proc</string>
		<key>returns</key>
		<string>vector</string>
		<key>short</key>
		<string>(make-vector-with-proc k func)</string>
	</dict>
	<key>map</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>list1</key>
			<string>a scheme list</string>
			<key>lists</key>
			<string>any number of additional lists</string>
			<key>proc</key>
			<string>a function taking as many arguments as lists</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(map (lambda (a b) (* a b)) &apos;(1 2 3) &apos;(2 2 2)) =&gt; (2 4 6)</string>
		</array>
		<key>long</key>
		<array>
			<string>The lists must be lists, and proc must be a procedure taking as many arguments as there are lists and returning a single value. If more than one list is given, then they must all be the same length. Map applies proc element-wise to the elements of the lists and returns a list of the results, in order. The dynamic order in which proc is applied to the elements of the lists is unspecified.</string>
		</array>
		<key>returns</key>
		<string>list</string>
		<key>short</key>
		<string>(map proc list1 . lists)</string>
	</dict>
	<key>mappend</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For mappend</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(mappend)</string>
	</dict>
	<key>math:matrix*</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>&apos;transpose_a</key>
			<string>if this symbol is provided transpose the first matrix before computing the result</string>
			<key>&apos;transpose_b</key>
			<string>if this symbol is provided transpose the second matrix before computing the result</string>
			<key>join-dimension</key>
			<string>the dimension shared by the two matricies</string>
			<key>v1</key>
			<string>first matrix represented as a flat vector</string>
			<key>v2</key>
			<string>second matrix represented as a flat vector</string>
			<key>v3</key>
			<string>optional 3rd vector which if supplied will have the output written to it</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(math:matrix* (vector 1 2 3 4 5 6 7 8) (vector 1 2 3 4 5 6 7 8 9 10 11 12) 4)    =&gt; #(70 80 90 158 184 210)</string>
			<string></string>
			<string>(define v3 (make-vector 6))</string>
			<string>(math:matrix* (vector 1 2 3 4 5 6 7 8) (vector 1 2 3 4 5 6 7 8 9 10 11 12) 4 v3)</string>
			<string>(print v3)</string>
		</array>
		<key>long</key>
		<array>
			<string>Matrix multiplcation</string>
		</array>
		<key>returns</key>
		<string>vector or boolean</string>
		<key>short</key>
		<string>(math:matrix* v1 v2 joint-dimension [v3] [&apos;transpose_a] [&apos;transpose_b])</string>
	</dict>
	<key>math:std-deviation</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>lst</key>
			<string>list of numbers</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(math:std-deviation &apos;(5 6 8 9))	=&gt; 1.58114</string>
		</array>
		<key>long</key>
		<array>
			<string>find the standard deviation of a list of numbers</string>
		</array>
		<key>returns</key>
		<string>real</string>
		<key>short</key>
		<string>(math:std-deviation lst)</string>
	</dict>
	<key>math:variance</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>lst</key>
			<string>list of numbers</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(math:variance &apos;(5 6 9 0))	=&gt; 2.5</string>
		</array>
		<key>long</key>
		<array>
			<string>returns the variance of a list of numbers</string>
		</array>
		<key>returns</key>
		<string>real</string>
		<key>short</key>
		<string>(math:variance lst)</string>
	</dict>
	<key>math:vector%</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>v1</key>
			<string>vector</string>
			<key>v2 | val</key>
			<string>vector of equal length to v1 or a single value to use for each vector position</string>
			<key>v3</key>
			<string>optional vector to place result. must be at least equal in length to the expected result</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define v1 (vector 1.0 2.0 3.0 4.0 -5.0 6.0 7.0 8.0 9.0 10.0))</string>
			<string>(define v2 (make-vector 10 2.0))</string>
			<string>(define v3 (make-vector 10))</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v3</string>
			<string>(math:vector% v1 v2 v3)</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v1</string>
			<string>(math:vector% v1 3.0)</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v3</string>
			<string>(math:vector% v1 -1.0 v3)</string>
			<string>(print v1 v2 v3)	</string>
		</array>
		<key>long</key>
		<array>
			<string>Find modulus for all v1 using either v2 or a static value.  If v3 is supplied copy result to v3 otherwise overwrite v1. Any vectors must contain real numbers only</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(math:vector% v1 [v2 | val] [v3])</string>
	</dict>
	<key>math:vector*</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>slice</key>
			<string>slice v1 into segments.  slice is a list of (startpos size increment) or a list containing a single mask.  a mask is a vector of 0.0 or 1.0 values.</string>
			<key>v1</key>
			<string>vector</string>
			<key>v2 | val</key>
			<string>vector of equal length to v1 or a single value to use for each vector position</string>
			<key>v3</key>
			<string>optional vector to place result. must be at least equal in length to the expected result</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define v1 (vector 1.0 2.0 3.0 4.0 -5.0 6.0 7.0 8.0 9.0 10.0))</string>
			<string>(define v2 (make-vector 10 2.0))</string>
			<string>(define v3 (make-vector 10))</string>
			<string>(define v4 (make-vector 5 2.2))</string>
			<string>(define v5 (make-vector 10))</string>
			<string>(define mask (vector 0 1 1 0 1 0 1 1 0 0))</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v3</string>
			<string>(math:vector* v1 v2 v3 v4 v5)</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v1</string>
			<string>(math:vector* v1 3.0)</string>
			<string>(print v1 v2 v3 v4 v5)</string>
			<string>; put result in v3</string>
			<string>(math:vector* v1 -1.0 v3)</string>
			<string>(print v1 v2 v3 v4 v5)</string>
			<string>; put result v1</string>
			<string>(math:vector* v1 v4 &apos;(0 5 2))</string>
			<string>(print v1 v2 v3 v4 v5)</string>
			<string>; put result in v5</string>
			<string>(math:vector* v1 v4 v5 (list mask))</string>
			<string>(print v1 v2 v3 v4 v5)</string>
		</array>
		<key>long</key>
		<array>
			<string>Multiplication of v1 by v2 or a static val.  Result will be placed in v3 if supplied else v1. If a slice is provided v2 must equal the length of the slice. a slice is a list of (startpos size increment) or a list containing a single mask.  a mask is a vector of 0.0 or 1.0 values.  Any vectors must contain real numbers only</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(math:vector* v1 [v2 | val] [v3] [slice])</string>
	</dict>
	<key>math:vector+</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>slice</key>
			<string>slice v1 into segments.  slice is a list of (startpos size increment) or a list containing a single mask.  a mask is a vector of 0.0 or 1.0 values.</string>
			<key>v1</key>
			<string>vector</string>
			<key>v2 | val</key>
			<string>vector of equal length to v1 or a single value to use for each vector position</string>
			<key>v3</key>
			<string>optional vector to place result. must be at least equal in length to the expected result</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define v1 (vector 1.0 2.0 3.0 4.0 -5.0 6.0 7.0 8.0 9.0 10.0))</string>
			<string>(define v2 (make-vector 10 2.0))</string>
			<string>(define v3 (make-vector 10))</string>
			<string>(define v4 (make-vector 5 2.2))</string>
			<string>(define v5 (make-vector 10))</string>
			<string>(define mask (vector 0 1 1 0 1 0 1 1 0 0))</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v3</string>
			<string>(math:vector+ v1 v2 v3 v4 v5)</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v1</string>
			<string>(math:vector+ v1 3.0)</string>
			<string>(print v1 v2 v3 v4 v5)</string>
			<string>; put result in v3</string>
			<string>(math:vector+ v1 -1.0 v3)</string>
			<string>(print v1 v2 v3 v4 v5)</string>
			<string>; put result v1</string>
			<string>(math:vector+ v1 v4 &apos;(0 5 2))</string>
			<string>(print v1 v2 v3 v4 v5)</string>
			<string>; put result in v5</string>
			<string>(math:vector+ v1 v4 v5 (list mask))</string>
			<string>(print v1 v2 v3 v4 v5)</string>
		</array>
		<key>long</key>
		<array>
			<string>Addition of v1 by v2 or a static val.  Result will be placed in v3 if supplied else v1. If a slice is provided v2 must equal the length of the slice. a slice is a list of (startpos size increment) or a list containing a single mask.  a mask is a vector of 0.0 or 1.0 values. Any vectors must contain real numbers only</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(math:vector+ v1 [v2 | val] [v3] [slice])</string>
	</dict>
	<key>math:vector-</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>slice</key>
			<string>slice v1 into segments.  slice is a list of (startpos size increment) or a list containing a single mask.  a mask is a vector of 0.0 or 1.0 values.</string>
			<key>v1</key>
			<string>vector</string>
			<key>v2 | val</key>
			<string>vector of equal length to v1 or a single value to use for each vector position</string>
			<key>v3</key>
			<string>optional vector to place result. must be at least equal in length to the expected result</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define v1 (vector 1.0 2.0 3.0 4.0 -5.0 6.0 7.0 8.0 9.0 10.0))</string>
			<string>(define v2 (make-vector 10 2.0))</string>
			<string>(define v3 (make-vector 10))</string>
			<string>(define v4 (make-vector 5 2.2))</string>
			<string>(define v5 (make-vector 10))</string>
			<string>(define mask (vector 0 1 1 0 1 0 1 1 0 0))</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v3</string>
			<string>(math:vector- v1 v2 v3 v4 v5)</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v1</string>
			<string>(math:vector- v1 3.0)</string>
			<string>(print v1 v2 v3 v4 v5)</string>
			<string>; put result in v3</string>
			<string>(math:vector- v1 -1.0 v3)</string>
			<string>(print v1 v2 v3 v4 v5)</string>
			<string>; put result v1</string>
			<string>(math:vector- v1 v4 &apos;(0 5 2))</string>
			<string>(print v1 v2 v3 v4 v5)</string>
			<string>; put result in v5</string>
			<string>(math:vector- v1 v4 v5 (list mask))</string>
			<string>(print v1 v2 v3 v4 v5)</string>
		</array>
		<key>long</key>
		<array>
			<string>Subtraction of v2 or a static val from v1.  Result will be placed in v3 if supplied else v1. If a slice is provided v2 must equal the length of the slice. a slice is a list of (startpos size increment) or a list containing a single mask.  a mask is a vector of 0.0 or 1.0 values. Any vectors must contain real numbers only</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(math:vector- v1 [v2 | val] [v3] [slice])</string>
	</dict>
	<key>math:vector-max</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>slice</key>
			<string>slice v1 into segments.  slice is a list of (startpos size increment) or a list containing a single mask.  a mask is a vector of 0.0 or 1.0 values.  Any vectors must contain real numbers only</string>
			<key>v1</key>
			<string>vector</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(math:vector-max (vector 1 2 3 4 5) &apos;(0 3 1)) =&gt; 3</string>
		</array>
		<key>long</key>
		<array>
			<string>Return the maximum element in v1. can use an optional slice.</string>
		</array>
		<key>returns</key>
		<string>real</string>
		<key>short</key>
		<string>(math:vector-max v1 [slice])</string>
	</dict>
	<key>math:vector-min</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>slice</key>
			<string>slice v1 into segments.  slice is a list of (startpos size increment) or a list containing a single mask.  a mask is a vector of 0.0 or 1.0 values.  Any vectors must contain real numbers only</string>
			<key>v1</key>
			<string>vector</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(math:vector-min (vector 1 2 3 4 5) &apos;(2 3 1)) =&gt; 3</string>
		</array>
		<key>long</key>
		<array>
			<string>Return the minimum element in v1. can use an optional slice.</string>
		</array>
		<key>returns</key>
		<string>real</string>
		<key>short</key>
		<string>(math:vector-min v1 [slice])</string>
	</dict>
	<key>math:vector-rand</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>v1</key>
			<string>vector</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Insert a new random number between 0.0 and 1.0 into each element of v1</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(math:vector-rand v1)</string>
	</dict>
	<key>math:vector-rotate</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>int</key>
			<string>amount of rotation</string>
			<key>v</key>
			<string>vector</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define v1 (vector 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0))</string>
			<string>(math:vector-rotate v1 -2)</string>
			<string>(print v1)</string>
		</array>
		<key>long</key>
		<array>
			<string>Rotate vector by int.  where int can be positive or negative for a forwards or backwards rotation.  the rotate affects v directly.  Any vectors must contain real numbers only</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(math:vector-rotate v int)</string>
	</dict>
	<key>math:vector-sum</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>slice</key>
			<string>slice v1 into segments.  slice is a list of (startpos size increment) or a list containing a single mask.  a mask is a vector of 0.0 or 1.0 values.</string>
			<key>v1</key>
			<string>vector</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(math:vector-sum (vector 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0))          =&gt; 45.0</string>
			<string>(math:vector-sum (vector 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0) &apos;(0 3 2)) =&gt; 9.0</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns the sum of elements in v.  can use a slice which wil return the sum of the slice. Any vectors must contain real numbers only</string>
		</array>
		<key>returns</key>
		<string>real</string>
		<key>short</key>
		<string>(math:vector-sum v [slice])</string>
	</dict>
	<key>math:vector-sum-and-rotate</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>mask</key>
			<string>mask to rotate through all vector position</string>
			<key>v</key>
			<string>vector</string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Sum mask into each vector position rotating mask for each position.  place result back into v1 or v2 if supplied. Any vectors must contain real numbers only</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(math:vector-sum-and-rotate v1 mask [v2])</string>
	</dict>
	<key>math:vector/</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>slice</key>
			<string>slice v1 into segments.  slice is a list of (startpos size increment) or a list containing a single mask.  a mask is a vector of 0.0 or 1.0 values.</string>
			<key>v1</key>
			<string>vector</string>
			<key>v2 | val</key>
			<string>vector of equal length to v1 or a single value to use for each vector position</string>
			<key>v3</key>
			<string>optional vector to place result. must be at least equal in length to the expected result</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define v1 (vector 1.0 2.0 3.0 4.0 -5.0 6.0 7.0 8.0 9.0 10.0))</string>
			<string>(define v2 (make-vector 10 2.0))</string>
			<string>(define v3 (make-vector 10))</string>
			<string>(define v4 (make-vector 5 2.2))</string>
			<string>(define v5 (make-vector 10))</string>
			<string>(define mask (vector 0 1 1 0 1 0 1 1 0 0))</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v3</string>
			<string>(math:vector/ v1 v2 v3 v4 v5)</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v1</string>
			<string>(math:vector/ v1 3.0)</string>
			<string>(print v1 v2 v3 v4 v5)</string>
			<string>; put result in v3</string>
			<string>(math:vector/ v1 -1.0 v3)</string>
			<string>(print v1 v2 v3 v4 v5)</string>
			<string>; put result v1</string>
			<string>(math:vector/ v1 v4 &apos;(0 5 2))</string>
			<string>(print v1 v2 v3 v4 v5)</string>
			<string>; put result in v5</string>
			<string>(math:ector/ v1 v4 v5 (list mask))</string>
			<string>(print v1 v2 v3 v4 v5)</string>
		</array>
		<key>long</key>
		<array>
			<string>Division of v1 by v2 or a static val.  Result will be placed in v3 if supplied else v1. If a slice is provided v2 must equal the length of the slice. a slice is a list of (startpos size increment) or a list containing a single mask.  a mask is a vector of 0.0 or 1.0 values.  Any vectors must contain real numbers only</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(math:vector/ v1 [v2 | val] [v3] [slice])</string>
	</dict>
	<key>math:vector&lt;</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>v1</key>
			<string>vector</string>
			<key>v2 | val</key>
			<string>vector of equal length to v1 or a single value to use for each vector position</string>
			<key>v3</key>
			<string>optional vector to place result. must be at least equal in length to the expected result</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define v1 (vector 1.0 2.0 3.0 4.0 -5.0 6.0 7.0 8.0 9.0 10.0))</string>
			<string>(define v2 (vector 1.0 3.0 2.0 4.0 5.0  7.5 7.6 8.5 9.0 10.0))</string>
			<string>(define v3 (make-vector 10))</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v3</string>
			<string>(math:vector&lt; v1 v2 v3)</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v1</string>
			<string>(math:vector&lt; v1 3.0)</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v3</string>
			<string>(math:vector&lt; v1 -1.0 v3)</string>
			<string>(print v1 v2 v3)</string>
		</array>
		<key>long</key>
		<array>
			<string>Check if v1 is smaller than v2 for all values of v1.  If v3 is supplied copy result to v3 otherwise overwrite v1.  Any vectors must contain real numbers only</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(math:vector&lt; v1 [v2 | val] [v3])</string>
	</dict>
	<key>math:vector&lt;=</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>v1</key>
			<string>vector</string>
			<key>v2 | val</key>
			<string>vector of equal length to v1 or a single value to use for each vector position</string>
			<key>v3</key>
			<string>optional vector to place result. must be at least equal in length to the expected result</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define v1 (vector 1.0 2.0 3.0 4.0 -5.0 6.0 7.0 8.0 9.0 10.0))</string>
			<string>(define v2 (vector 1.0 3.0 2.0 4.0 5.0  7.5 7.6 8.5 9.0 10.0))</string>
			<string>(define v3 (make-vector 10))</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v3</string>
			<string>(math:vector&lt;= v1 v2 v3)</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v1</string>
			<string>(math:vector&lt;= v1 3.0)</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v3</string>
			<string>(math:vector&lt;= v1 -1.0 v3)</string>
			<string>(print v1 v2 v3)</string>
		</array>
		<key>long</key>
		<array>
			<string>Check if v1 is smaller or equal to v2 for all values of v1.  If v3 is supplied copy result to v3 otherwise overwrite v1.  Any vectors must contain real numbers only</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(math:vector&lt;= v1 [v2 | val] [v3])</string>
	</dict>
	<key>math:vector=</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>slice</key>
			<string>slice v1 into segments.  slice is a list of (startpos size increment) or a list containing a single mask.  a mask is a vector of 0.0 or 1.0 values.</string>
			<key>v1</key>
			<string>vector</string>
			<key>v2 | val</key>
			<string>vector of equal length to v1 or a single value to use for each vector position</string>
			<key>v3</key>
			<string>optional vector to place result. must be at least equal in length to the expected result</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define v1 (vector 1.0 2.0 3.0 4.0 -5.0 6.0 7.0 8.0 9.0 10.0))</string>
			<string>(define v2 (vector 11 11 11 11 11))</string>
			<string>(define v3 (make-vector 10))</string>
			<string>(print v1 v2 v3)</string>
			<string>(math:vector= v1 v2 v3 &apos;(0 5 2))</string>
			<string>(print v1 v2 v3)</string>
			<string>(math:vector= v1 12)</string>
			<string>(print v1 v2 v3)</string>
		</array>
		<key>long</key>
		<array>
			<string>Assignment to v1 by v2 or a static val.  Result will be placed in v3 if supplied else v1. If a slice is provided v2 must equal the length of the slice. a slice is a list of (startpos size increment) or a list containing a single mask.  a mask is a vector of 0.0 or 1.0 values.  Any vectors must contain real numbers only</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(math:vector= v1 [v2 | val] [v3] [slice])</string>
	</dict>
	<key>math:vector==</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>v1</key>
			<string>vector</string>
			<key>v2 | val</key>
			<string>vector of equal length to v1 or a single value to use for each vector position</string>
			<key>v3</key>
			<string>optional vector to place result. must be at least equal in length to the expected result</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define v1 (vector 1.0 2.0 3.0 4.0 -5.0 6.0 7.0 8.0 9.0 10.0))</string>
			<string>(define v2 (vector 1.0 3.0 2.0 4.0 5.0  7.5 7.6 8.5 9.0 10.0))</string>
			<string>(define v3 (make-vector 10))</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v3</string>
			<string>(math:vector== v1 v2 v3)</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v1</string>
			<string>(math:vector== v1 3.0)</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v3</string>
			<string>(math:vector== v1 -1.0 v3)</string>
			<string>(print v1 v2 v3)</string>
		</array>
		<key>long</key>
		<array>
			<string>Check if v1 is equal to v2 for all values of v1.  If v3 is supplied copy result to v3 otherwise overwrite v1.  Any vectors must contain real numbers only</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(math:vector== v1 [v2 | val] [v3])</string>
	</dict>
	<key>math:vector&gt;</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>v1</key>
			<string>vector</string>
			<key>v2 | val</key>
			<string>vector of equal length to v1 or a single value to use for each vector position</string>
			<key>v3</key>
			<string>optional vector to place result. must be at least equal in length to the expected result</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define v1 (vector 1.0 2.0 3.0 4.0 -5.0 6.0 7.0 8.0 9.0 10.0))</string>
			<string>(define v2 (vector 1.0 3.0 2.0 4.0 5.0  7.5 7.6 8.5 9.0 10.0))</string>
			<string>(define v3 (make-vector 10))</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v3</string>
			<string>(math:vector&gt; v1 v2 v3)</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v1</string>
			<string>(math:vector&gt; v1 3.0)</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v3</string>
			<string>(math:vector&gt; v1 -1.0 v3)</string>
			<string>(print v1 v2 v3)</string>
		</array>
		<key>long</key>
		<array>
			<string>Check if v1 is greater than v2 for all values of v1.  If v3 is supplied copy result to v3 otherwise overwrite v1.  Any vectors must contain real numbers only</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(math:vector&gt; v1 [v2 | val] [v3])</string>
	</dict>
	<key>math:vector&gt;=</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>v1</key>
			<string>vector</string>
			<key>v2 | val</key>
			<string>vector of equal length to v1 or a single value to use for each vector position</string>
			<key>v3</key>
			<string>optional vector to place result. must be at least equal in length to the expected result</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define v1 (vector 1.0 2.0 3.0 4.0 -5.0 6.0 7.0 8.0 9.0 10.0))</string>
			<string>(define v2 (vector 1.0 3.0 2.0 4.0 5.0  7.5 7.6 8.5 9.0 10.0))</string>
			<string>(define v3 (make-vector 10))</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v3</string>
			<string>(math:vector&gt;= v1 v2 v3)</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v1</string>
			<string>(math:vector&gt;= v1 3.0)</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v3</string>
			<string>(math:vector&gt;= v1 -1.0 v3)</string>
			<string>(print v1 v2 v3)</string>
		</array>
		<key>long</key>
		<array>
			<string>Check if v1 is greater than or equal to v2 for all values of v1.  If v3 is supplied copy result to v3 otherwise overwrite v1.  Any vectors must contain real numbers only</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(math:vector&gt;= v1 [v2 | val] [v3])</string>
	</dict>
	<key>math:vector@</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>v</key>
			<string>vector</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Set all values of v to absolute values.  Any vectors must contain real numbers only</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(math:vector@ v)</string>
	</dict>
	<key>math:vector^</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>v1</key>
			<string>vector</string>
			<key>v2 | val</key>
			<string>vector of equal length to v1 or a single value to use for each vector position</string>
			<key>v3</key>
			<string>optional vector to place result. must be at least equal in length to the expected result</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define v1 (vector 1.0 2.0 3.0 4.0 -5.0 6.0 7.0 8.0 9.0 10.0))</string>
			<string>(define v2 (make-vector 10 2.0))</string>
			<string>(define v3 (make-vector 10))</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v3</string>
			<string>(math:vector^ v1 v2 v3)</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v1</string>
			<string>(math:vector^ v1 3.0)</string>
			<string>(print v1 v2 v3)</string>
			<string>; put result in v3</string>
			<string>(math:vector^ v1 -1.0 v3)</string>
			<string>(print v1 v2 v3)	</string>
		</array>
		<key>long</key>
		<array>
			<string>Find power for all v1 using either v2 or a static value as the power.  If v3 is supplied copy result to v3 otherwise overwrite v1.  Any vectors must contain real numbers only</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(math:vector^ v1 [v2 | val] [v3])</string>
	</dict>
	<key>max</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>numbers</key>
			<string>any number of numbers</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(max 1 2 3.3 4.4 4)  =&gt; 4.4</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns the maximum of its numbers</string>
		</array>
		<key>returns</key>
		<string>obj</string>
		<key>short</key>
		<string>(max . numbers)</string>
	</dict>
	<key>mbe:append-map</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For mbe:append-map</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(mbe:append-map)</string>
	</dict>
	<key>mbe:contained-in?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For mbe:contained-in?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(mbe:contained-in?)</string>
	</dict>
	<key>mbe:ellipsis-sub-envs</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For mbe:ellipsis-sub-envs</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(mbe:ellipsis-sub-envs)</string>
	</dict>
	<key>mbe:ellipsis?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For mbe:ellipsis?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(mbe:ellipsis?)</string>
	</dict>
	<key>mbe:expand-pattern</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For mbe:expand-pattern</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(mbe:expand-pattern)</string>
	</dict>
	<key>mbe:get-bindings</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For mbe:get-bindings</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(mbe:get-bindings)</string>
	</dict>
	<key>mbe:get-ellipsis-nestings</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For mbe:get-ellipsis-nestings</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(mbe:get-ellipsis-nestings)</string>
	</dict>
	<key>mbe:matches-pattern?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For mbe:matches-pattern?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(mbe:matches-pattern?)</string>
	</dict>
	<key>mbe:position</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For mbe:position</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(mbe:position)</string>
	</dict>
	<key>mbe:split-at-ellipsis</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For mbe:split-at-ellipsis</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(mbe:split-at-ellipsis)</string>
	</dict>
	<key>mcons</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For mcons</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(mcons)</string>
	</dict>
	<key>mean</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>lst</key>
			<string>a list of numeric values</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(math:mean &apos;(5 6 8 9)) =&gt; 7</string>
		</array>
		<key>long</key>
		<array>
			<string>returns the mean value of the list lst</string>
		</array>
		<key>returns</key>
		<string>real</string>
		<key>short</key>
		<string>(math:mean lst)</string>
	</dict>
	<key>member</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>lst</key>
			<string>any scheme list</string>
			<key>obj</key>
			<string>any scheme object</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(member &apos;c &apos;(a b c d)) =&gt; (c d)</string>
			<string>(member &apos;e &apos;(a b c d)) =&gt; #f</string>
		</array>
		<key>long</key>
		<array>
			<string>These procedures return the first sublist of list whose car is obj, where the sublists of list are the non-empty lists returned by (list-tail list k) for k less than the length of list. If obj does not occur in list, then #f (not the empty list) is returned. Memq uses eq? to compare obj with the elements of list, while memv uses eqv? and member uses equal?.</string>
		</array>
		<key>related</key>
		<string>memv memq</string>
		<key>returns</key>
		<string>list or #f</string>
		<key>short</key>
		<string>(member obj lst)</string>
	</dict>
	<key>memq</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>lst</key>
			<string>list</string>
			<key>obj</key>
			<string>object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>These procedures return the first sublist of list whose car is obj, where the sublists of list are the non-empty lists returned by (list-tail list k) for k less than the length of list. If obj does not occur in list, then #f (not the empty list) is returned. Memq uses eq? to compare obj with the elements of list, while memv uses eqv? and member uses equal?.</string>
		</array>
		<key>related</key>
		<string>member memv</string>
		<key>returns</key>
		<string>list or #f</string>
		<key>short</key>
		<string>(memq obj lst)</string>
	</dict>
	<key>memv</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>lst</key>
			<string>list</string>
			<key>obj</key>
			<string>object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>These procedures return the first sublist of list whose car is obj, where the sublists of list are the non-empty lists returned by (list-tail list k) for k less than the length of list. If obj does not occur in list, then #f (not the empty list) is returned. Memq uses eq? to compare obj with the elements of list, while memv uses eqv? and member uses equal?.</string>
		</array>
		<key>related</key>
		<string>member memq</string>
		<key>returns</key>
		<string>list of #f</string>
		<key>short</key>
		<string>(memv obj lst)</string>
	</dict>
	<key>min</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>numbers</key>
			<string>any number of scheme numbers</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(min 1 5.5 3.3 0.5)  =&gt; 0.5</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns the minimum of its arguments</string>
		</array>
		<key>returns</key>
		<string>number</string>
		<key>short</key>
		<string>(min . numbers)</string>
	</dict>
	<key>modulo</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>num1</key>
			<string>numerator</string>
			<key>num2</key>
			<string>denominator</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(modulo 12 4)  =&gt; 0</string>
		</array>
		<key>long</key>
		<array>
			<string>Modulus</string>
		</array>
		<key>returns</key>
		<string>number</string>
		<key>short</key>
		<string>(modulo num1 num2)</string>
	</dict>
	<key>more-handlers?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For more-handlers?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(more-handlers?)</string>
	</dict>
	<key>negative?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>num</key>
			<string>number</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Is num a negative value</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(negative? num)</string>
	</dict>
	<key>new-segment</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>num</key>
			<string>integer</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Allocates num new segments of memory</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>bool</string>
		<key>short</key>
		<string>(new-segment num)</string>
	</dict>
	<key>newline</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>port</key>
			<string>optional port argument</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Writes an end of line to port. Exactly how this is done differs from one operating system to another. Returns an unspecified value. The port argument may be omitted, in which case it defaults to the value returned by current-output-port.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(newline [port])</string>
	</dict>
	<key>not</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns #t if obj is false</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(not obj)</string>
	</dict>
	<key>now</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array>
			<string>(play-note (now) inst 60 80 (* 1.0 *second*))</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns the time in samples since impromptu was started.</string>
		</array>
		<key>returns</key>
		<string>integer</string>
		<key>short</key>
		<string>(now)</string>
	</dict>
	<key>null?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>object</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(null? &apos;())  =&gt; #t</string>
		</array>
		<key>long</key>
		<array>
			<string>Predicate for the empty list</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(null? obj)</string>
	</dict>
	<key>number-&gt;string</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>num</key>
			<string>number</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(number-&gt;string 5.5) =&gt; &quot;5.5&quot;</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns a string representation of num</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(number-&gt;string num)</string>
	</dict>
	<key>number?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Predicate for numbers</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(number? obj)</string>
	</dict>
	<key>numerator</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>rational</key>
			<string>a rational number</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns the numberator of a rational number</string>
		</array>
		<key>returns</key>
		<string>integer</string>
		<key>short</key>
		<string>(numerator rational)</string>
	</dict>
	<key>objc:call</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>arguments</key>
			<string>optional arguments to pass to init-signature.  args can be either objc-objects, reals, integers, strings (which get converted to NSString), #t or #f, or a list of 2 (NSSize,NSRange,NSPoint) or 4 (NSRect) elements.</string>
			<key>method-signature</key>
			<string>string representation of method signature</string>
			<key>object||class</key>
			<string>obj-c object to call method on or a class (string) to call</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define nsstring (objc:call &quot;NSString&quot; &quot;stringWithString:&quot; &quot;Hello World&quot;))</string>
			<string>(objc:call nsarray &quot;addObject:&quot; nsstring)</string>
		</array>
		<key>long</key>
		<array>
			<string>Call obj-c method-signature on object with optional arguments as required by signature</string>
		</array>
		<key>related</key>
		<string>objc:make string-&gt;objc objc-&gt;string</string>
		<key>returns</key>
		<string>obj-c object or false on fail</string>
		<key>short</key>
		<string>(objc:call object||class method-signature [arguments])</string>
	</dict>
	<key>objc:cicolor-&gt;list</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>cicolor</key>
			<string>objc cicolor object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>returns a list with cicolor components</string>
		</array>
		<key>returns</key>
		<string>list</string>
		<key>short</key>
		<string>(objc:cicolor-&gt;list cicolor)</string>
	</dict>
	<key>objc:civector-&gt;vector</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>civector</key>
			<string>objc civector object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>returns a list with contents of civector</string>
		</array>
		<key>returns</key>
		<string>vector</string>
		<key>short</key>
		<string>(objc:civector-&gt;vector civector)</string>
	</dict>
	<key>objc:data-to-image</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data</key>
			<string>NSData or NSMutableData object</string>
			<key>image</key>
			<string>bitmap image</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Set bitmap image data to data from NSData</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(objc:data-to-image data image)</string>
	</dict>
	<key>objc:data:char-&gt;float</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Set uint64 value at index in data-obj</string>
		</array>
		<key>returns</key>
		<string>NSMutableData object</string>
		<key>short</key>
		<string>(objc:data:char-&gt;float data-obj [scaling-factor])</string>
	</dict>
	<key>objc:data:double-&gt;float</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Set uint64 value at index in data-obj</string>
		</array>
		<key>returns</key>
		<string>NSMutableData object</string>
		<key>short</key>
		<string>(objc:data:double-&gt;float data-obj [scaling-factor])</string>
	</dict>
	<key>objc:data:double-&gt;sint64</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Set uint64 value at index in data-obj</string>
		</array>
		<key>returns</key>
		<string>NSMutableData object</string>
		<key>short</key>
		<string>(objc:data:double-&gt;sint64 data-obj [scaling-factor])</string>
	</dict>
	<key>objc:data:double-&gt;uint64</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Set uint64 value at index in data-obj</string>
		</array>
		<key>returns</key>
		<string>NSMutableData object</string>
		<key>short</key>
		<string>(objc:data:double-&gt;uint64 data-obj [scaling-factor])</string>
	</dict>
	<key>objc:data:float-&gt;char</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Set uint64 value at index in data-obj</string>
		</array>
		<key>returns</key>
		<string>NSMutableData object</string>
		<key>short</key>
		<string>(objc:data:float-&gt;char data-obj [scaling-factor])</string>
	</dict>
	<key>objc:data:float-&gt;double</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Set uint64 value at index in data-obj</string>
		</array>
		<key>returns</key>
		<string>NSMutableData object</string>
		<key>short</key>
		<string>(objc:data:float-&gt;double data-obj [scaling-factor])</string>
	</dict>
	<key>objc:data:float-&gt;sint32</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Set uint64 value at index in data-obj</string>
		</array>
		<key>returns</key>
		<string>NSMutableData object</string>
		<key>short</key>
		<string>(objc:data:float-&gt;sint32 data-obj [scaling-factor])</string>
	</dict>
	<key>objc:data:float-&gt;uint32</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Set uint64 value at index in data-obj</string>
		</array>
		<key>returns</key>
		<string>NSMutableData object</string>
		<key>short</key>
		<string>(objc:data:float-&gt;uint32 data-obj [scaling-factor])</string>
	</dict>
	<key>objc:data:float-&gt;uint8</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Set uint64 value at index in data-obj</string>
		</array>
		<key>returns</key>
		<string>NSMutableData object</string>
		<key>short</key>
		<string>(objc:data:float-&gt;uint8 data-obj [scaling-factor])</string>
	</dict>
	<key>objc:data:get-char</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
			<key>index</key>
			<string>index into data-object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Return char value at index from data-obj</string>
		</array>
		<key>returns</key>
		<string>integer</string>
		<key>short</key>
		<string>(objc:data:get-char data-obj index)</string>
	</dict>
	<key>objc:data:get-double</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
			<key>index</key>
			<string>index into data-object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Return double value at index from data-obj</string>
		</array>
		<key>returns</key>
		<string>real</string>
		<key>short</key>
		<string>(objc:data:get-double data-obj index)</string>
	</dict>
	<key>objc:data:get-float</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
			<key>index</key>
			<string>index into data-object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Return float value at index from data-obj</string>
		</array>
		<key>returns</key>
		<string>real</string>
		<key>short</key>
		<string>(objc:data:get-float data-obj index)</string>
	</dict>
	<key>objc:data:get-sint32</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Return sint32 value at index from data-obj</string>
		</array>
		<key>returns</key>
		<string>integer</string>
		<key>short</key>
		<string>(objc:data:get-sint32 data-obj index)</string>
	</dict>
	<key>objc:data:get-sint64</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Return sint64 value at index from data-obj</string>
		</array>
		<key>returns</key>
		<string>integer</string>
		<key>short</key>
		<string>(objc:data:get-sint64 data-obj index)</string>
	</dict>
	<key>objc:data:get-uint16</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
			<key>index</key>
			<string>index into data-object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Return char value at index from data-obj</string>
		</array>
		<key>returns</key>
		<string>integer</string>
		<key>short</key>
		<string>(objc:data:get-uint16 data-obj index)</string>
	</dict>
	<key>objc:data:get-uint32</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Return uint32 value at index from data-obj</string>
		</array>
		<key>returns</key>
		<string>integer</string>
		<key>short</key>
		<string>(objc:data:get-uint32 data-obj index)</string>
	</dict>
	<key>objc:data:get-uint64</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Return uint64 value at index from data-obj</string>
		</array>
		<key>returns</key>
		<string>integer</string>
		<key>short</key>
		<string>(objc:data:get-uint64 data-obj index)</string>
	</dict>
	<key>objc:data:get-uint8</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
			<key>index</key>
			<string>index into data-object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Return char value at index from data-obj</string>
		</array>
		<key>returns</key>
		<string>integer</string>
		<key>short</key>
		<string>(objc:data:get-uint8 data-obj index)</string>
	</dict>
	<key>objc:data:make</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>number-of-bytes</key>
			<string>size in bytes of new data object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Creates an NSMutableData object of size &apos;number-of-bytes&apos; all data is zero&apos;d out.</string>
		</array>
		<key>returns</key>
		<string>NSMutableData</string>
		<key>short</key>
		<string>(objc:data:make number-of-bytes)</string>
	</dict>
	<key>objc:data:set-char</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
			<key>index</key>
			<string>index into data</string>
			<key>value</key>
			<string>integer</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Set char value at index in data-obj</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(objc:data:set-char data-obj index value)</string>
	</dict>
	<key>objc:data:set-double</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
			<key>index</key>
			<string>index into data</string>
			<key>value</key>
			<string>real</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Set real value at index in data-obj</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(objc:data:set-double data-obj index value)</string>
	</dict>
	<key>objc:data:set-float</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
			<key>index</key>
			<string>index into data</string>
			<key>value</key>
			<string>real</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Set float value at index in data-obj</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(objc:data:set-float data-obj index value)</string>
	</dict>
	<key>objc:data:set-sint32</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
			<key>index</key>
			<string>index into data</string>
			<key>value</key>
			<string>integer</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Set sint32 value at index in data-obj</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(objc:data:set-sint32 data-obj index value)</string>
	</dict>
	<key>objc:data:set-sint64</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
			<key>index</key>
			<string>index into data</string>
			<key>value</key>
			<string>integer</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Set sint64 value at index in data-obj</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(objc:data:set-sint64 data-obj index value)</string>
	</dict>
	<key>objc:data:set-uint16</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
			<key>index</key>
			<string>index into data</string>
			<key>value</key>
			<string>integer</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Set char value at index in data-obj</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(objc:data:set-uint16 data-obj index value)</string>
	</dict>
	<key>objc:data:set-uint32</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
			<key>index</key>
			<string>index into data</string>
			<key>value</key>
			<string>positive integer</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Set uint32 value at index in data-obj</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(objc:data:set-uint32 data-obj index value)</string>
	</dict>
	<key>objc:data:set-uint64</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
			<key>index</key>
			<string>index into data</string>
			<key>value</key>
			<string>positive integer</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Set uint64 value at index in data-obj</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(objc:data:set-uint64 data-obj index value)</string>
	</dict>
	<key>objc:data:set-uint8</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
			<key>index</key>
			<string>index into data</string>
			<key>value</key>
			<string>integer</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Set char value at index in data-obj</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(objc:data:set-uint8 data-obj index value)</string>
	</dict>
	<key>objc:data:sint32-&gt;float</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Set uint64 value at index in data-obj</string>
		</array>
		<key>returns</key>
		<string>NSMutableData object</string>
		<key>short</key>
		<string>(objc:data:sint32-&gt;float data-obj [scaling-factor])</string>
	</dict>
	<key>objc:data:subref</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data</key>
			<string>NSData or NSMutableData object</string>
			<key>length</key>
			<string>length in bytes from the offset in the data object</string>
			<key>offset</key>
			<string>offset in bytes into the data object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Creates a new NSData object with a reference (i.e. not a copy) to the data object&apos;s byte buffer.  an offset and length (both in bytes) allows a subrange to be selected.</string>
		</array>
		<key>returns</key>
		<string>nsdata</string>
		<key>short</key>
		<string>(objc:data:subref data offset length)</string>
	</dict>
	<key>objc:data:uint32-&gt;float</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Set uint64 value at index in data-obj</string>
		</array>
		<key>returns</key>
		<string>NSMutableData object</string>
		<key>short</key>
		<string>(objc:data:uint32-&gt;float data-obj [scaling-factor])</string>
	</dict>
	<key>objc:data:uint8-&gt;float</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data-obj</key>
			<string>NSData or NSMutableData object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Set uint64 value at index in data-obj</string>
		</array>
		<key>returns</key>
		<string>NSMutableData object</string>
		<key>short</key>
		<string>(objc:data:uint8-&gt;float data-obj [scaling-factor])</string>
	</dict>
	<key>objc:destroy</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>object</key>
			<string>obj-c object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Destroy objective-c object. Please see the reference to objc:gc first!. By default you should never need to call this!.  By default objc objects are automatically released on gc</string>
		</array>
		<key>related</key>
		<string>objc:make objc:call</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(objc:destroy object)</string>
	</dict>
	<key>objc:from-address</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>string</key>
			<string>hexidecimal memory address defined as a string (i.e. as returned by sprintf for example)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns the objc object located at address. where address is a hexedicmal memory location represented in string.  (hex strings can be used to pass objc objects between threads for example).</string>
		</array>
		<key>related</key>
		<string>objc:get-address</string>
		<key>returns</key>
		<string>objc</string>
		<key>short</key>
		<string>(objc:from-address string)</string>
	</dict>
	<key>objc:gc</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>bool</key>
			<string>turs on or off objc garbage collection</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>turns on or off automatic memory management of objc-objects. if on (as it is be default) objc-objects will be released during the usual scheme gc cycle (objc-objects are always retained before being passed into scheme world). if you turn off gc you will need to destroy objc-objects manually by calling objc:destroy, image-destroy etc.  Providing no argument returns the current setting</string>
		</array>
		<key>related</key>
		<string>objc:call objc:make objc:destroy image-destroy is-objc?</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(objc:gc [bool])</string>
	</dict>
	<key>objc:get-address</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>objc</key>
			<string>objc object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns the address of an objc object located at address. the address is returned as a string hexidecimal representation. You can retrieve an object using the objc:from-address function</string>
		</array>
		<key>related</key>
		<string>objc:from-address</string>
		<key>returns</key>
		<string>objc</string>
		<key>short</key>
		<string>(objc:get-address objc)</string>
	</dict>
	<key>objc:get-object-for-key</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>dictionary</key>
			<string>an nsdictionary</string>
			<key>key</key>
			<string>a scheme value OR objc object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>retrieves the object key in dictionary. if the value returned is a number, string or nsarray it will be returned as a scheme number, string or list. otherwise returns an objc object</string>
		</array>
		<key>returns</key>
		<string>object for key in dictionary. if possible returns object as a scheme object.  (nsstring-&gt;string, nsarray-&gt;array, nsnumber-&gt;number, nsdictionary-&gt;alist etc..). If you need an objc object returned and not translated to scheme call (objc:call obj &quot;objectForKey:&quot; key) directly</string>
		<key>short</key>
		<string>(objc:get-object-for-key dictionary key)</string>
	</dict>
	<key>objc:get-value-for-key</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>key</key>
			<string>an objc string or scheme string</string>
			<key>obj</key>
			<string>objc object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>objc key value coding. retrieves the value of key in obj. if the value returned is a number, string or nsarray it will be returned as a scheme number, string or list. otherwise returns an objc object.  If you need an objc object returned and not translated to scheme call (objc:call obj &quot;valueForKey:&quot; key) directly. </string>
		</array>
		<key>returns</key>
		<string>value of key in obj. value returned is a number, string or nsarray it will be returned as a scheme number, string or list. otherwise returns an objc object</string>
		<key>short</key>
		<string>(objc:get-value-for-key obj key)</string>
	</dict>
	<key>objc:image-to-data</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data</key>
			<string>NSData or NSMutableData object</string>
			<key>image</key>
			<string>bitmap image</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Set NSData to bitmap image data</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(objc:image-to-data image data)</string>
	</dict>
	<key>objc:iskind?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>class</key>
			<string>an objc class represented as a string &quot;NSString&quot;</string>
			<key>obj</key>
			<string>a scheme object</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define num (objc:call &quot;NSNumber&quot; &quot;numberWithFloat:&quot; 0.5))</string>
			<string>(define str (objc:call &quot;NSString&quot; &quot;stringWithString:&quot; &quot;hello&quot;))</string>
			<string>(objc:iskind? &quot;NSNumber&quot; num)</string>
			<string>(objc:iskind? &quot;NSNumber&quot; str)</string>
			<string>(objc:iskind? &quot;NSNumber&quot; (objc:nsstring-&gt;string num))</string>
		</array>
		<key>long</key>
		<array>
			<string>predicate check to see if objc is of type class</string>
		</array>
		<key>related</key>
		<string>objc:call objc:make is_objc?</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(objc:iskind? class obj)</string>
	</dict>
	<key>objc:list-&gt;cicolor</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>list</key>
			<string>a list of 3 or 4 color componenets (i.e. red gree blue [alpha])</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>returns a cicolor with contents of list (red green blue [alpha])</string>
		</array>
		<key>returns</key>
		<string>cicolor</string>
		<key>short</key>
		<string>(objc:list-&gt;cicolor list)</string>
	</dict>
	<key>objc:list-&gt;nsarray</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>lst</key>
			<string>lst containing strings numbers and objc-objects</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(objc:list-&gt;nsarray &apos;(&quot;hello&quot; 9.9 &quot;world&quot;))</string>
		</array>
		<key>long</key>
		<array>
			<string>returns an nsarray with the contents of lst.  lst must contains strings numbers and objc-objects only</string>
		</array>
		<key>returns</key>
		<string>objc nsarray</string>
		<key>short</key>
		<string>(objc:list-&gt;nsarray lst)</string>
	</dict>
	<key>objc:list-&gt;nsdictionary</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>lst</key>
			<string>lst containing strings numbers, lists, alists and objc-objects</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(objc:list-&gt;nsdictionary &apos;((&quot;firstname&quot; . &quot;andrew&quot;) (&quot;secondname&quot; . &quot;sorensen&quot;)))</string>
		</array>
		<key>long</key>
		<array>
			<string>returns an nsmutabledictionary with the contents of lst (which must be an associative list).  lst must contains strings numbers, lists, alists and objc-objects only</string>
		</array>
		<key>returns</key>
		<string>objc nsmutabledictionary</string>
		<key>short</key>
		<string>(objc:list-&gt;nsdictionary lst)</string>
	</dict>
	<key>objc:make</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>args</key>
			<string>optional argument to pass to init-signature.  args can be either objc-objects, reals, integers, strings (which get converted to NSString), #t or #f, or a list of 2 (NSSize,NSRange,NSPoint) or 4 (NSRect) elements.</string>
			<key>init-signature</key>
			<string>initialization signature (&quot;init&quot; or &quot;initWithString&quot; etc.)</string>
			<key>objc-class-name</key>
			<string>string name of obj-c class</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define nsarray (objc:make &quot;NSMutableArray&quot; &quot;init&quot;))</string>
			<string>(define nsstring (string-&gt;objc &quot;string1&quot;))</string>
			<string>(define nsnumber (number-&gt;objc 1.0))</string>
			<string>(objc:call nsarray &quot;addObject:&quot; nsstring)</string>
			<string>(objc:call nsarray &quot;addObject:&quot; nsnumber)</string>
			<string>(print nsstring nsnumber nsarray)</string>
		</array>
		<key>long</key>
		<array>
			<string>Create and return a new objective C object initialized using the init-signature and an optional obj-c argument. Make sure you only call init methods!!  To call methods on an existing objc-object or to return a new objc-object from a class method use objc:call.</string>
		</array>
		<key>related</key>
		<string>objc:call string-&gt;objc objc-&gt;string number-&gt;objc objc-&gt;number objc:print</string>
		<key>returns</key>
		<string>obj-c object or #f on fail</string>
		<key>short</key>
		<string>(objc:make objc-class-name init-signature . args)</string>
	</dict>
	<key>objc:make-array</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns an empty NSMutableArray</string>
		</array>
		<key>returns</key>
		<string>NSMutableArray</string>
		<key>short</key>
		<string>(objc:make-array)</string>
	</dict>
	<key>objc:make-date</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>time</key>
			<string>an optional argument to set the date - a double value in seconds since 2001-01-01</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns an NSDate object. The date is either &apos;now&apos; if no time is given or a given time where time is a double value in seconds from 2001-01-01</string>
		</array>
		<key>returns</key>
		<string>NSDate</string>
		<key>short</key>
		<string>(objc:make-date [time])</string>
	</dict>
	<key>objc:make-dictionary</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns an empty NSMutableDictionary</string>
		</array>
		<key>returns</key>
		<string>NSMutableDictionary</string>
		<key>short</key>
		<string>(objc:make-dictionary)</string>
	</dict>
	<key>objc:make-number</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>number</key>
			<string>a scheme number either a real, rational or integer</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>returns number as an nsnumber</string>
		</array>
		<key>returns</key>
		<string>nsnumber</string>
		<key>short</key>
		<string>(objc:make-number number)</string>
	</dict>
	<key>objc:nsarray-&gt;list</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>nsarray</key>
			<string>nsarray</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>converts an nsarray object into a list of numbers strings and objc-objects</string>
		</array>
		<key>related</key>
		<string>objc:list&gt;nsarray objc:objc-&gt;string objc:number-&gt;nsnumber</string>
		<key>returns</key>
		<string>list</string>
		<key>short</key>
		<string>(objc:nsarray-&gt;list nsarray)</string>
	</dict>
	<key>objc:nsarray-&gt;vector</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>nsarray</key>
			<string>nsarray</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>converts an nsarray object into a scheme vector</string>
		</array>
		<key>related</key>
		<string>objc:list&gt;nsarray objc:objc-&gt;string objc:number-&gt;nsnumber</string>
		<key>returns</key>
		<string>vector</string>
		<key>short</key>
		<string>(objc:nsarray-&gt;vector nsarray)</string>
	</dict>
	<key>objc:nsdata-&gt;vector</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>nsdata</key>
			<string>nsdata object (whose data must be floats)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns a vector containing real values from nsdata whose data must be floating point</string>
		</array>
		<key>returns</key>
		<string>vector</string>
		<key>short</key>
		<string>(objc:nsdata-&gt;vector nsdata)</string>
	</dict>
	<key>objc:nsdictionary-&gt;list</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>nsdictionary</key>
			<string>objc nsdictionary object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>returns an associative list with contents of nsdictionary</string>
		</array>
		<key>returns</key>
		<string>list</string>
		<key>short</key>
		<string>(objc:nsdictionary-&gt;list nsdictionary)</string>
	</dict>
	<key>objc:nsnumber-&gt;number</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>nsnumber</key>
			<string>nsnumber</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>convert an objc nsnumber into  number.</string>
		</array>
		<key>related</key>
		<string>objc:objc-&gt;string objc:number-&gt;nsnumber</string>
		<key>returns</key>
		<string>number</string>
		<key>short</key>
		<string>(objc:nsnumber-&gt;number nsnumber)</string>
	</dict>
	<key>objc:nsstring-&gt;string</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>nsstring</key>
			<string>nsstring</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>convert obj-c object into string. obj-c object should be an nsstring</string>
		</array>
		<key>related</key>
		<string>objc:nsnumber-&gt;number objc:string-&gt;nsstring objc:make</string>
		<key>returns</key>
		<string>number</string>
		<key>short</key>
		<string>(objc:nsstring-&gt;string nsstring)</string>
	</dict>
	<key>objc:null?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>a scheme object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>predicate check. returns #t if objc is nil or if not objc object</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(objc:null? obj)</string>
	</dict>
	<key>objc:number-&gt;nsnumber</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>num</key>
			<string>a scheme real or integer number</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns an nsnumber</string>
		</array>
		<key>related</key>
		<string>objc:nsnumber-&gt;number objc:make</string>
		<key>returns</key>
		<string>obj-c</string>
		<key>short</key>
		<string>(objc:number-&gt;nsnumber num)</string>
	</dict>
	<key>objc:objc-&gt;string</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>objc</key>
			<string>Any objective-C object with a description method</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>convert obj-c object into string by calling its description method</string>
		</array>
		<key>related</key>
		<string>objc:nsnumber-&gt;number objc:string-&gt;nsstring objc:make</string>
		<key>returns</key>
		<string>nsstring</string>
		<key>short</key>
		<string>(objc:objc-&gt;string objc)</string>
	</dict>
	<key>objc:print</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>object</key>
			<string>an obj-c object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Prints an objc-object to the log view</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(objc:print objc)</string>
	</dict>
	<key>objc:r</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>objects</key>
			<string>one or more objective-c objects to release at time</string>
			<key>time</key>
			<string>an optional time argument in samples to release args at (default is to release in 40000 samples from now)</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;; release both img and img2 in 10000 samples
(let ((img (gfx:get-code-image))
      (img2 (gfx:get-movie-frame movie 22.0)))   
   (gfx:draw-image (now) canvas img 1)
   (gfx:draw-image (now) canvas img2 .5)      
   (objc:r (+ (now) 10000) img img2))

;; release object returned from objc:release in 10000
(let ((img (objc:r (+ (now) 10000) (gfx:get-code-image))))
   (gfx:draw-image (now) canvas img 1))

;; release object returned from objc:release
;; in the default time of 40000 samples
(let ((img (objc:r (gfx:get-code-image))))
   (gfx:draw-image (now) canvas img 1))</string>
		</array>
		<key>long</key>
		<array>
			<string>objc:r is a shortcut for objc:release Forced release of objective-c objects at a given time.  This can be important as the GC often doesn&apos;t release objects for sometime (i.e. not quickly enough).  Usually you will only need to call this if working with very lage objective-c objects (like images) that need to be released quickly.</string>
		</array>
		<key>returns</key>
		<string>the first object is returned</string>
		<key>short</key>
		<string>(objc:r [time] . objects)</string>
	</dict>
	<key>objc:release</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>objects</key>
			<string>one or more objective-c objects to release at time</string>
			<key>time</key>
			<string>an optional time argument in samples to release args at (default is to release in 40000 samples from now)</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;; release both img and img2 in 10000 samples
(let ((img (gfx:get-code-image))
      (img2 (gfx:get-movie-frame movie 22.0)))   
   (gfx:draw-image (now) canvas img 1)
   (gfx:draw-image (now) canvas img2 .5)      
   (objc:release (+ (now) 10000) img img2))

;; release object returned from objc:release in 10000
(let ((img (objc:release (+ (now) 10000) (gfx:get-code-image))))
   (gfx:draw-image (now) canvas img 1))

;; release object returned from objc:release
;; in the default time of 40000 samples
(let ((img (objc:release (gfx:get-code-image))))
   (gfx:draw-image (now) canvas img 1))</string>
		</array>
		<key>long</key>
		<array>
			<string>Forced release of objective-c objects at a given time.  This can be important as the GC often doesn&apos;t release objects for sometime (i.e. not quickly enough).  Usually you will only need to call this if working with very lage objective-c objects (like images) that need to be released quickly.</string>
		</array>
		<key>returns</key>
		<string>the first object is returned</string>
		<key>short</key>
		<string>(objc:release [time] . objects)</string>
	</dict>
	<key>objc:scale-floatdata-to-uchardata</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data</key>
			<string>NSData or NSMutableData object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Scales float data to unsigned char data. (i.e. 1.0 = 255,  0.5 = 127 etc..). Returns NSMutableData holding uchar data.</string>
		</array>
		<key>returns</key>
		<string>uchar data (NSMutableData)</string>
		<key>short</key>
		<string>(objc:scale-floatdata-to-uchardata data)</string>
	</dict>
	<key>objc:scale-uchardata-to-floatdata</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>data</key>
			<string>NSData or NSMutableData object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Scales unsigned char data to floating point data. (i.e. 255 = 1.0, 127 = 0.5 etc..). Returns NSMutableData holding floating point data</string>
		</array>
		<key>returns</key>
		<string>floating point data (NSMutableData)</string>
		<key>short</key>
		<string>(objc:scale-uchardata-to-floatdata data)</string>
	</dict>
	<key>objc:set-object-for-key</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>key</key>
			<string>a scheme value OR an objc object</string>
			<key>obj</key>
			<string>an objc object</string>
			<key>value</key>
			<string>a scheme number,string or list OR an objc object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>objc key value coding. sets the value of key in obj. if value is a scheme number, string or list it will set an nsnumber, nsstring or nsarray otherwise value must be an objc object</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(objc:set-object-for-key obj key value)</string>
	</dict>
	<key>objc:set-value-for-key</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>key</key>
			<string>a scheme string for the key</string>
			<key>obj</key>
			<string>objc object</string>
			<key>value</key>
			<string>a scheme number,string or list OR an objc object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>objc key value coding. sets the value of key in obj. if value is a scheme number, string or list it will set an nsnumber, nsstring or nsarray otherwise value must be an objc object</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(objc:set-value-for-key obj key value)</string>
	</dict>
	<key>objc:string-&gt;nsdata</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>string</key>
			<string>a scheme string object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>returns string as an NSData object</string>
		</array>
		<key>returns</key>
		<string>NSData</string>
		<key>short</key>
		<string>(objc:string-&gt;nsdata string)</string>
	</dict>
	<key>objc:string-&gt;nsstring</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>str</key>
			<string>a scheme string</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>returns an nsstring</string>
		</array>
		<key>returns</key>
		<string>objc nsstring</string>
		<key>short</key>
		<string>(objc:string-&gt;nsstring str)</string>
	</dict>
	<key>objc:string-decode</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>string</key>
			<string>a string encoding of an objc object  (from objc:string-encode)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Decodes (turns back into an objc object) a string encoding of an objc object (object must be of type nsstring, nsnumber, nsdate, nsdictionary, nsarray or nsdata).  Useful for parsing across IPC for example.  String is encoded using objc:string-encode</string>
		</array>
		<key>returns</key>
		<string>objc object</string>
		<key>short</key>
		<string>(objc:string-decode string)</string>
	</dict>
	<key>objc:string-encode</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>objc</key>
			<string>an objective-c object to encode into a string format (must be nsstring, nsnumber, nsdate, nsdictionary, nsarray or nsdata</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Encodes an objective-c object into a string format (objc object must be of type nsstring, nsnumber, nsdate, nsdictionary, nsarray or nsdata).  Useful for parsing across IPC for example.  Can be decoded back into an objc object using objc:string-decode</string>
		</array>
		<key>related</key>
		<string>objc:string-decode ipc:call</string>
		<key>returns</key>
		<string>a string representation of an objective-c object.</string>
		<key>short</key>
		<string>(objc:string-encode objc)</string>
	</dict>
	<key>objc:string:with-format</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>format-string</key>
			<string>A format string similar to printf (man sprintf)</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define dict (objc:list-&gt;nsdictionary &apos;((&quot;a&quot; . 1) (&quot;b&quot; . 2) (&quot;c&quot; . 3))))</string>
			<string>(define str (objc:string:with-format &quot;hello %s %lld-%.2f,,,\n\n%@&quot; &quot;world&quot; 123 .123 dict))</string>
		</array>
		<key>long</key>
		<array>
			<string>Effectively calls sprintf with a format-string and a list of arguments - returns and nsstring.  The arguments must be of type objc, integer, rational, real or string.  As far as the format string is concerned all reals and rationals are 64bit floats (i.e. %f) and all integers are signed 64bit integers (i.e. %lld) objc objects are as expected (i.e. %@) and strings also as expected (i.e. %s).  Giving incrorrect format specifiers will result in unspecified behaviour (i.e. system crashes!)</string>
		</array>
		<key>returns</key>
		<string>NSString</string>
		<key>short</key>
		<string>(objc:string:with-format format-string . args)</string>
	</dict>
	<key>objc:vector-&gt;civector</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>vector</key>
			<string>a vector of up to four elements</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>returns a civector with contents of vector (1 2 3 or 4 elements)</string>
		</array>
		<key>returns</key>
		<string>civector</string>
		<key>short</key>
		<string>(objc:vector-&gt;civector vector)</string>
	</dict>
	<key>objc:vector-&gt;nsarray</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>vector</key>
			<string>vector</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(objc:vector-&gt;nsarray &apos;#(&quot;hello&quot; 9.9 &quot;world&quot;))</string>
		</array>
		<key>long</key>
		<array>
			<string>returns an nsarray with the contents of vector</string>
		</array>
		<key>returns</key>
		<string>objc nsarray</string>
		<key>short</key>
		<string>(objc:vector-&gt;nsarray vector)</string>
	</dict>
	<key>objc:vector-&gt;nsdata-float</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>v</key>
			<string>vector of real values</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>creates an NSData object of type float* built from real values of v</string>
		</array>
		<key>returns</key>
		<string>NSData</string>
		<key>short</key>
		<string>(objc:vector-&gt;nsdata-float v)</string>
	</dict>
	<key>objc:vector-&gt;nsdata-int</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>v</key>
			<string>vector of integer values</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>creates an NSData object of type int* built from integer values of v</string>
		</array>
		<key>returns</key>
		<string>NSData</string>
		<key>short</key>
		<string>(objc:vector-&gt;nsdata-int v)</string>
	</dict>
	<key>objc:vector-&gt;nsdata-uint8</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>v</key>
			<string>vector of integer values</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>creates an NSData object of type uint8* built from integer values of v</string>
		</array>
		<key>returns</key>
		<string>NSData</string>
		<key>short</key>
		<string>(objc:vector-&gt;nsdata-uint8 v)</string>
	</dict>
	<key>objc?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>a scheme object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>predicate check. is obj and objc object</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(objc? obj)</string>
	</dict>
	<key>oblist</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>For internal use only</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(oblist)</string>
	</dict>
	<key>odd?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>num</key>
			<string>number</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Is num odd?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(odd? num)</string>
	</dict>
	<key>open-input-file</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>file-path</key>
			<string>fully qualified path to input file</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Takes a string naming an existing file and returns an input port capable of delivering characters from the file. If the file cannot be opened, an error is signalled.</string>
		</array>
		<key>returns</key>
		<string>path</string>
		<key>short</key>
		<string>(open-input-file file-path)</string>
	</dict>
	<key>open-input-output-file</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>file-path</key>
			<string>fully qualified path to file</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Takes a string naming an existing file and returns an input-output port capable of delivering characters from the file and to the file. If the file cannot be opened, an error is signalled.</string>
		</array>
		<key>returns</key>
		<string>path</string>
		<key>short</key>
		<string>(open-input-output-file file-path)</string>
	</dict>
	<key>open-input-output-string</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>str</key>
			<string>string</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Creates an input output port using the supplied string</string>
		</array>
		<key>returns</key>
		<string>path</string>
		<key>short</key>
		<string>(open-input-output-string str)</string>
	</dict>
	<key>open-input-string</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>str</key>
			<string>string</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Creates an input port using the supplied string</string>
		</array>
		<key>returns</key>
		<string>path</string>
		<key>short</key>
		<string>(open-input-string str)</string>
	</dict>
	<key>open-output-file</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>file-path</key>
			<string>fully qualifed path to file</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Takes a string naming an output file to be created and returns an output port capable of writing characters to a new file by that name. If the file cannot be opened, an error is signalled. If a file with the given name already exists, the effect is unspecified.</string>
		</array>
		<key>returns</key>
		<string>path</string>
		<key>short</key>
		<string>(open-output-file file-path)</string>
	</dict>
	<key>open-output-string</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>str</key>
			<string>string</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define str (make-string 100))</string>
			<string>(define port (open-output-string str))</string>
			<string>(write &quot;hello world &quot; port)</string>
			<string>(write 5.5 port)</string>
			<string>(close-output-port port)</string>
			<string>(print str)</string>
		</array>
		<key>long</key>
		<array>
			<string>Create output port using str as backing.  Make sure the backing str has the required length because it will not auto extend.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(open-output-string str)</string>
	</dict>
	<key>or</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array>
			<string>(or (= 2 2) (&gt; 2 1)) =&gt;  #t</string>
			<string>(or (= 2 2) (&lt; 2 1)) =&gt;  #t</string>
			<string>(or #f #f #f)        =&gt;  #f</string>
			<string>(or (memq &apos;b &apos;(a b c))</string>
			<string>    (/ 3 0))         =&gt;  (b c)</string>
		</array>
		<key>long</key>
		<array>
			<string>The &lt;test&gt; expressions are evaluated from left to right,
	  and the value of the first expression that evaluates to a true value
	  (see section 6.3.1) is returned.  Any remaining expressions are not
	  evaluated.  If all expressions evaluate to false values, the value of
	  the last expression is returned.  If there are no expressions then #f
	  is returned.</string>
		</array>
		<key>returns</key>
		<string>If all expressions evaluate to false values, the value
	of the last expression is returned.  If there are no
	expressions then #f is returned.</string>
		<key>short</key>
		<string>(or &lt;test&gt; ...)</string>
	</dict>
	<key>output-port?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>port</key>
			<string>the port to check</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Prediate to check if this is an output port</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(output-port? port)</string>
	</dict>
	<key>pair?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Predicate for cons pair</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(pair? obj)</string>
	</dict>
	<key>pb:cb</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>body</key>
			<string>optional body of one or more expressions</string>
			<key>dur</key>
			<string>duration of callback in beats</string>
			<key>name</key>
			<string>the name to call the function</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Creates a template function called name and temporally recursing at dur with an optional body. After excecution the function template is written to the pasteboard and can be pasted into the editor.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(pb:cb name dur [body])</string>
	</dict>
	<key>pb:cb-list</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>body</key>
			<string>body of one or more expressions</string>
			<key>duration</key>
			<string>duration of callback in beats</string>
			<key>lists</key>
			<string>one or more lists</string>
			<key>name</key>
			<string>the name to call the function</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Creates a template function called name and temporally recursing at duration with body.  this function expects a number of lists as arguments, the first list should be a list of symbols of arguments, any subsequent expressions should provide an s-expression for creating a list (one for each argument). After excecution the function template is written to the pasteboard and can be pasted into the editor.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(pb:cb name dur body [lists])</string>
	</dict>
	<key>peek-char</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>port</key>
			<string>optional port argument</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns the next character available from the input port, without updating the port to point to the following character. If no more characters are available, an end of file object is returned. Port may be omitted, in which case it defaults to the value returned by current-input-port.</string>
		</array>
		<key>returns</key>
		<string>char</string>
		<key>short</key>
		<string>(peek-char [port])</string>
	</dict>
	<key>play</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>channel</key>
			<string>optional midi channel</string>
			<key>duration</key>
			<string>duration in beats</string>
			<key>inst</key>
			<string>audiounit</string>
			<key>offset</key>
			<string>optional offset in beats</string>
			<key>pitch</key>
			<string>pitch</string>
			<key>volume</key>
			<string>volume</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;; if you use a function that passes an argument
;; named &apos;beat&apos; you can use the play macro as
;; a shortcut to play-note.  You MUST bind the 
;; symbol &apos;beat&apos; if you want to use play
;; 
;; the example below is expanded into
;; (play-note (*metro* beat) inst 60 80 (*metro* &apos;dur 0.25))
;; (play-note (*metro* (+ beat .5)) inst 60 80 (*metro* &apos;dur 0.5))
(define loop
   (lambda (beat) 
      ;; use beat
      (play inst 60 80 0.25)
      ;; offset from beat by .5
      (play .5 inst 63 80 0.5)
      (callback (*metro* (+ beat (* .5 1))) &apos;loop (+ beat 1))))

;; calling (*metro* &apos;get-beat 4)
;; returns the next beat value quantized to (in this example) 4
;; this is a beat value since impromptu was started
;; using (*metro* &apos;get-beat 3) would quantize beat to 3
;; using (*metro* &apos;get-beat 1) would quantize beat to 1 etc..
(loop (*metro* &apos;get-beat 4))</string>
		</array>
		<key>long</key>
		<array>
			<string>play is a shortcut macro to stand in for play-note.  Their are two important requirements when using play - firstly that a global metronome bound to the symbol *metro* is available (this is available by default) - secondly that a symbol bound to the symbol &apos;beat&apos; with a value in beats since impromptu was started is available in the current environement.  If these are available then you can use play as a shortcut for play-note such that (play inst 60 80 0.125) is directly expanded into (play-note (*metro* beat) 60 80 (*metro* &apos;dur 0.125))</string>
		</array>
		<key>returns</key>
		<string>number</string>
		<key>short</key>
		<string>(play [offset] inst pitch volume duration [channel])</string>
	</dict>
	<key>play-note</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>audiounit</string>
			<key>duration</key>
			<string>in samples</string>
			<key>midi-channel</key>
			<string>optional midi-channel defaults to 0</string>
			<key>pitch</key>
			<string>0-127 midi</string>
			<key>time</key>
			<string>time in samples to play note</string>
			<key>volume</key>
			<string>0-127 midi</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;; first define an instrument
(define dls (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))
;; next connect dls to the default output node
(au:connect-node dls 0 *au:output-node* 0)
;; lastly update the audio graph to reflect the connection
(au:update-graph)

;; play one note by itself
(play-note (now) inst 60 80 (* *second* 1.0))

;; play three notes together
(dotimes (i 3)
   (play-note (now) inst (random 60 80)  80 (* *second* 1.0)))

;; play a looping sequence of random notes
(define loop
   (lambda (time)
      (play-note time inst (random 40 80) 80 1000)
      (callback (+ time 8000) &apos;loop (+ time 10000))))

;; start the loop
(loop (now))

;; stop the loop by defining loop to be null
(define loop &apos;())

;; define a new loop to play a repeating sequence of notes
;; with a small random twist
(define loop
   (lambda (time pitches)
      (play-note time inst (car pitches) (random 40 80) 8000)
      (callback (+ time 4000) &apos;loop (+ time 5000)
                (if (null? (cdr pitches))
                    (list 60 63 62 (random 65 68) 68 59)
                    (cdr pitches)))))

(loop (now) &apos;(60 63 62 67 68 59))

;; stop the loop by defining loop to be null
(define loop &apos;())

;; define a new loop to play a sequence of chords
(define loop
   (lambda (time chord)
      (for-each (lambda (p)
                   (play-note time inst p 60 *second*))
                chord)
      (callback (+ time 40000) &apos;loop (+ time *second*)
                (cdr (assoc chord &apos;(((60 63 67) 58 62 65)                                    
                                    ((58 62 65) 60 63 67)))))))

(loop (now) &apos;(60 63 67))

(define loop &apos;())</string>
		</array>
		<key>long</key>
		<array>
			<string>Play a note by sending a note-on then a note-off event seperated by duration to au.  Duration is in samples.  Pitch values falling outside of 0-127 are ignored (so you can use negative numbers as rests if you like).  If for some reason you need to send pitch values outside of 0-127 you can call au:midi-out which does not bounds checking.</string>
		</array>
		<key>related</key>
		<string>au:play-note play-sound play</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(play-note time au pitch volume duration [midi-channel])</string>
	</dict>
	<key>play-sound</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>audiounit</string>
			<key>duration</key>
			<string>in samples</string>
			<key>pitch</key>
			<string>real number value where decimal portion is in cents (i.e. 60.25 = C+25cents)</string>
			<key>time</key>
			<string>time in samples to play note</string>
			<key>volume</key>
			<string>real number volume</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(play-sound (now) inst 60.25 80.5 (* *second* 1.0))</string>
		</array>
		<key>long</key>
		<array>
			<string>Play a sound of duration by sending extended api information to the specified au. Duration is in samples.  Pitch values are real numbers where the decimal portion is in cents (i.e. 60.25 = C+25cents).  volumes are also real number values.  NOTE: this only works with audiounits supporting the extended AudioUnit Note API (at the present the only AU I know that supports this is apples DLS). If your AU does not support this use the standard play-note function instead.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(play-sound time au pitch volume duration)</string>
	</dict>
	<key>pop-handler</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For pop-handler</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(pop-handler)</string>
	</dict>
	<key>port?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Predicate check for port</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(port? obj)</string>
	</dict>
	<key>positive?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>num</key>
			<string>number</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>check if num is positive</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(positive? num)</string>
	</dict>
	<key>pred</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For pred</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(pred)</string>
	</dict>
	<key>print</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>objects</key>
			<string>any number of scheme objects</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(print &quot;hell &quot; 0 &quot; w&quot; 0 &quot;rld&quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>Print out any given objects to the log view</string>
		</array>
		<key>related</key>
		<string>print-error print-notification</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(print . objects)</string>
	</dict>
	<key>print-error</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>objects</key>
			<string>scheme objects</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Print any objects to log view as error message in blue and red</string>
		</array>
		<key>related</key>
		<string>print print-notification</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(print-error . objects)</string>
	</dict>
	<key>print-notification</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>objects</key>
			<string>any number of scheme objects</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Print a notification in yellow to the log view</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(print-notification . objects)</string>
	</dict>
	<key>printf</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>args</key>
			<string>any arguments required by format</string>
			<key>format</key>
			<string>format string (as per printf)  accepts (%s string) (%d integer) (%f real) (%@ objc)</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(printf &quot;hello %s&quot; &quot;world&quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>Operates like printf  -  accepts %s (string) %d (integer) %f (real) and %@ (objc object)</string>
		</array>
		<key>related</key>
		<string>print objc:string:with-format</string>
		<key>returns</key>
		<string>string</string>
		<key>short</key>
		<string>(printf format . args)</string>
	</dict>
	<key>procedure?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Predicate check for procedure</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(procedure? obj)</string>
	</dict>
	<key>push-handler</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For push-handler</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(push-handler)</string>
	</dict>
	<key>put</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>key</key>
			<string>scheme object to use as key</string>
			<key>sym</key>
			<string>symbol</string>
			<key>val</key>
			<string>any scheme object to use as the value</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define key &quot;key&quot;)</string>
			<string>(put &apos;test key &quot;value&quot;)</string>
			<string>(get &apos;test key)          =&gt; &quot;value&quot;</string>
		</array>
		<key>long</key>
		<array>
			<string>Assign val with key into symbols property list</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(put sym key val)</string>
	</dict>
	<key>quit</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Exit scheme interpreter.  You generally don&apos;t want to do this!</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(quit)</string>
	</dict>
	<key>quote</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>datum</key>
			<string>external representation of a scheme object</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(quote a)                              =&gt;  a</string>
			<string>(quote #(a b c))                       =&gt;  #(a b c)</string>
			<string>(quote (+ 1 2))                        =&gt;  (+ 1 2)	</string>
			<string></string>
			<string>&apos;a                                     =&gt;  a</string>
			<string>&apos;#(a b c)                              =&gt;  #(a b c)</string>
			<string>&apos;()                                    =&gt;  ()</string>
			<string>&apos;(+ 1 2)                               =&gt;  (+ 1 2)</string>
			<string>&apos;(quote a)                             =&gt;  (quote a)</string>
			<string>&apos;&apos;a                                    =&gt;  (quote a)</string>
		</array>
		<key>long</key>
		<array>
			<string>(quote datum) evaluates to datum. Datum may be any external representation of a Scheme object. This notation is used to include literal constants in Scheme code.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(quote datum)</string>
	</dict>
	<key>quotient</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>num1</key>
			<string>numerator</string>
			<key>num2</key>
			<string>denominator</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>returns the rational value num1/num2 (although impromptu doesn&apos;t currently support rational values)</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(quotient num1 num2)</string>
	</dict>
	<key>random</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>cons pair</key>
			<string>weighted cons pairs</string>
			<key>list</key>
			<string>choose random element from list</string>
			<key>lower-bound</key>
			<string>inclusive lower integer to choose from</string>
			<key>upper-bound</key>
			<string>exclusive upper bound to choose from</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(random)                           =&gt; 0.579</string>
			<string>(random 5)                         =&gt; 4</string>
			<string>(random 5 10)                      =&gt; 7</string>
			<string>(random &apos;(a b c))                  =&gt; b</string>
			<string>(random (cons 0.3 a) (cons 0.7 b)) =&gt; b</string>
		</array>
		<key>long</key>
		<array>
			<string>There are a number of forms of random but each returns a random number see examples for examples</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(random [lower bound] [upper bound] [list] [cons pair])</string>
	</dict>
	<key>random-envelope</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>duration</key>
			<string>duration of envelope in beats</string>
			<key>interval</key>
			<string>interval between each point in beats</string>
			<key>random-args</key>
			<string>any arguments that should be sent to the random function</string>
			<key>whole-number?</key>
			<string>do we want to round all results to whole-numbers</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(random-envelope 4.0 0.25 #t 60 72)</string>
		</array>
		<key>long</key>
		<array>
			<string>Creates a random envelope of duration with as many points as intervals in duration.  random-args are the usual arguments to supply to the random function</string>
		</array>
		<key>returns</key>
		<string>envelope</string>
		<key>short</key>
		<string>(random-envelope duration interval whole-number? . random-args)</string>
	</dict>
	<key>random-gaussian</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>mean</key>
			<string>mean of the distribution (defaults to 0)</string>
			<key>std-dev</key>
			<string>the standard deviation of the distribution (defaults to 1)</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(random-gaussian)			=&gt; -1.2</string>
			<string>(random-gaussian 30 2.5)	=&gt; 31.539</string>
		</array>
		<key>long</key>
		<array>
			<string>returns a random number from the gaussian distribution specified by mean and std-dev</string>
		</array>
		<key>returns</key>
		<string>real</string>
		<key>short</key>
		<string>(random-gaussian [mean] [std-dev])</string>
	</dict>
	<key>random-int</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>internal use only.  use random</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(random-int)</string>
	</dict>
	<key>random-next</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Internal use only</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(random-next)</string>
	</dict>
	<key>random-real</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Internal use only</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(random-real)</string>
	</dict>
	<key>rational?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Predicate check for rational number (impromptu does not currently support rational numbers)</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(rational? obj)</string>
	</dict>
	<key>read</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>port</key>
			<string>optional port defaults to current-input-port</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Read converts external representations of Scheme objects into the objects themselves. That is, it is a parser for the nonterminal datum (see sections External representation and Pairs and lists). Read returns the next object parsable from the given input port, updating port to point to the first character past the end of the external representation of the object.  If an end of file is encountered in the input before any characters are found that can begin an object, then an end of file object is returned. The port remains open, and further attempts to read will also return an end of file object. If an end of file is encountered after the beginning of an object&apos;s external representation, but the external representation is incomplete and therefore not parsable, an error is signalled. The port argument may be omitted, in which case it defaults to the value returned by current-input-port. It is an error to read from a closed port.</string>
		</array>
		<key>returns</key>
		<string>object</string>
		<key>short</key>
		<string>(read [port])</string>
	</dict>
	<key>read-char</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>port</key>
			<string>optional port defaults to current-intput-port</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns the next character available from the input port, updating the port to point to the following character. If no more characters are available, an end of file object is returned. Port may be omitted, in which case it defaults to the value returned by current-input-port.</string>
		</array>
		<key>returns</key>
		<string>char</string>
		<key>short</key>
		<string>(read-char [port])</string>
	</dict>
	<key>real?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Is this a real number?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(real? obj)</string>
	</dict>
	<key>regex:match-all</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>regex</key>
			<string>regular expression string to match str against</string>
			<key>str</key>
			<string>input string</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(regex:match-all &quot;test1234fred5768harry910&quot; &quot;[a-z]*[0-9]*&quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns a list of all matches which regex fits (groups are not required)</string>
		</array>
		<key>returns</key>
		<string>List</string>
		<key>short</key>
		<string>(regex:matched str regex)</string>
	</dict>
	<key>regex:match?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>regex</key>
			<string>regular expression string to match str against</string>
			<key>str</key>
			<string>input string</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(regex:match? &quot;abcde&quot; &quot;abc.*&quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns bool depending on successfully regular expression match</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(regex:match? str regex)</string>
	</dict>
	<key>regex:matched</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>regex</key>
			<string>regular expression string to match str against</string>
			<key>str</key>
			<string>input string</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(regex:matched &quot;test1234&quot; &quot;([a-z]*)([0-9]*)&quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns a list of group matches for regex (where first list match is the whole matched string)</string>
		</array>
		<key>returns</key>
		<string>List</string>
		<key>short</key>
		<string>(regex:matched str regex)</string>
	</dict>
	<key>regex:replace</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>out</key>
			<string>output string (which can include regex groups $1 $2 etc..)</string>
			<key>regex</key>
			<string>regular expression string to match str against</string>
			<key>str</key>
			<string>input string</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(regex:replace &quot;124.96&quot; &quot;([0-9]*).([0-9]*)&quot; &quot;$1,$2&quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>Replace str with out based on regex groups</string>
		</array>
		<key>returns</key>
		<string>string</string>
		<key>short</key>
		<string>(regex:replace str regex out)</string>
	</dict>
	<key>regex:split</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>regex</key>
			<string>regular expression string to match str against</string>
			<key>str</key>
			<string>input string</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(regex:split &quot;a,b,c.d:e&quot; &quot;[,|:.]&quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>Splits input str based on regex split matches</string>
		</array>
		<key>returns</key>
		<string>string</string>
		<key>short</key>
		<string>(regex:split str regex)</string>
	</dict>
	<key>remainder</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>int1</key>
			<string>numerator</string>
			<key>int2</key>
			<string>denominator</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>remainder function</string>
		</array>
		<key>returns</key>
		<string>integer</string>
		<key>short</key>
		<string>(remainder int1 int2)</string>
	</dict>
	<key>replace-all</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>alst</key>
			<string>a list of mappings for objects to replace in lst</string>
			<key>lst</key>
			<string>a scheme list</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(replace-all &apos;(a b c c (d c b a)) &apos;((c . x) (d . y))) =&gt; (a b x x (y x b a))</string>
		</array>
		<key>long</key>
		<array>
			<string>Replace all objects in lst with objects matching keys in alst</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(replace-all lst alst)</string>
	</dict>
	<key>reverse</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>lst</key>
			<string>list</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(reverse &apos;(a b c d e))  =&gt; (e d c b a)</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns a newly allocated list consisting of the elements of list in reverse order.</string>
		</array>
		<key>returns</key>
		<string>list</string>
		<key>short</key>
		<string>(reverse lst)</string>
	</dict>
	<key>round</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>real</key>
			<string>a real number</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(round 5.5) =&gt; 6.0</string>
		</array>
		<key>long</key>
		<array>
			<string>Round returns the closest integer to x, rounding to even when x is halfway between two integers.</string>
		</array>
		<key>returns</key>
		<string>number</string>
		<key>short</key>
		<string>(round real)</string>
	</dict>
	<key>samples-&gt;clock</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>time</key>
			<string>time in clock time (real number) before being converted to samples</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(samples-&gt;clock (now))</string>
		</array>
		<key>long</key>
		<array>
			<string>Takes an integer values in samples since impromptu started and returns a system clock time</string>
		</array>
		<key>returns</key>
		<string>real (time in seconds since 2001)</string>
		<key>short</key>
		<string>(samples-&gt;clock time)</string>
	</dict>
	<key>schedule</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>args</key>
			<string>any arguments required by proc</string>
			<key>proc|symbol</key>
			<string>the procedure to callback into or the symbol of the procedure to callback into</string>
			<key>time</key>
			<string>time to call proc</string>
		</dict>
		<key>examples</key>
		<array>
			<string>; a one off callback</string>
			<string>(schedule (+ (now) (* *minute* 10)) (lambda (str) (print str)) &quot;Hello World&quot;)</string>
			<string></string>
			<string>; a termporally recursive function</string>
			<string>(define loop</string>
			<string>	(lambda (time str)</string>
			<string>		(print &quot;Hello World&quot;)</string>
			<string>		(schedule (+ time 10000) &apos;loop (+ time 11025) str)))</string>
		</array>
		<key>long</key>
		<array>
			<string>Callback to proc (or the proc bound to symbol) at time.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(schedule time proc|symbol . args)</string>
	</dict>
	<key>set!</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define x 2)</string>
			<string>(+ x 1)                 =&gt;  3</string>
			<string>(set! x 4)              =&gt;  unspecified</string>
			<string>(+ x 1)                 =&gt;  5</string>
		</array>
		<key>long</key>
		<array>
			<string>&lt;Expression&gt; is evaluated, and the resulting value is stored in the</string>
			<string>location to which &lt;variable&gt; is bound.  &lt;Variable&gt; must be bound either</string>
			<string>in some region enclosing the set! expression or at top level.  The</string>
			<string>result of the set!  expression is unspecified.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(set! &lt;variable&gt; &lt;expression&gt;)</string>
	</dict>
	<key>set-car!</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>object</string>
			<key>pair</key>
			<string>a cons pair</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define a (cons &apos;b &apos;c))</string>
			<string>(print a)</string>
			<string>(set-car! a &apos;d)         =&gt; (d . c)</string>
		</array>
		<key>long</key>
		<array>
			<string>Stores obj in the car field of pair.</string>
		</array>
		<key>returns</key>
		<string>pair</string>
		<key>short</key>
		<string>(set-car! pair obj)</string>
	</dict>
	<key>set-cdr!</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>a scheme object</string>
			<key>pair</key>
			<string>a cons pair</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define a (cons &apos;b &apos;c))</string>
			<string>(print a)</string>
			<string>(set-cdr! a &apos;d)         =&gt; (b . d)</string>
		</array>
		<key>long</key>
		<array>
			<string>Stores obj in the cdr field of pair</string>
		</array>
		<key>returns</key>
		<string>pair</string>
		<key>short</key>
		<string>(set-cdr! pair obj)</string>
	</dict>
	<key>set-input-port</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>port</key>
			<string>port</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Sets the default input port</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(set-input-port port)</string>
	</dict>
	<key>set-obj-for-key!</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>alist</key>
			<string>the associative list to set obj for key</string>
			<key>key</key>
			<string>The key to use for replace</string>
			<key>obj</key>
			<string>The obj to set at key in alist</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Set obj for key in alist </string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>bool</string>
		<key>short</key>
		<string>(set-obj-for-key! key obj alist)</string>
	</dict>
	<key>set-output-port</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>port</key>
			<string>port</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Sets the default output port</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(set-output-port port)</string>
	</dict>
	<key>set-signal!</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>dur</key>
			<string>duration in seconds</string>
			<key>rate</key>
			<string>control rate of change (defaults to 1/16 of a second)</string>
			<key>value</key>
			<string>value to change variable to over time (duration) OR a lambda function that accepts one argument (the previous value) and returns a new value (which updates the signal).</string>
			<key>variable</key>
			<string>global variable to adjust (must be a number)</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;; change v from 12 to 15 over 5 seconds</string>
			<string>(define v 12)</string>
			<string>(set-signal! v 15 5)</string>
			<string>;; change v from 2 incrementing by powers of 2 over 10 seconds at a control rate of 2 per second (print each change to the log)</string>
			<string>(define v 2)</string>
			<string>(set-signal! v (lambda (x) (print x) (* x 2)) 10 1/2)</string>
		</array>
		<key>long</key>
		<array>
			<string>Change variable from it&apos;s current value to it&apos;s new value over duration. value can be a value to change to or a function that accepts a previous value and returns a new value.  You can stop a signal prematurely by defining the global varaible to the symbol &apos;stop-signal</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(set-signal! variable value duration [rate])</string>
	</dict>
	<key>setp</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>audiounit</string>
			<key>duration</key>
			<string>duration in beats to move linearly to value</string>
			<key>id</key>
			<string>au parameter id</string>
			<key>value</key>
			<string>numeric value to set</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>macro to au:set-param. sets audiounits global parameter id to value with the option of moving linearly to the value over duration. this macro requires that a beat variable be available in the current scope. requires a metronome called *metro* to be bound in the environment</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(setp au id value [duration])</string>
	</dict>
	<key>setpe</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>audiounit</string>
			<key>duration</key>
			<string>duration in beats to move linearly to value</string>
			<key>element</key>
			<string>element number</string>
			<key>id</key>
			<string>au parameter id</string>
			<key>value</key>
			<string>numeric value to set</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>macro to au:set-param. sets audiounits global parameter id to value with the option of moving linearly to the value over duration. this macro requires that a beat variable be available in the current scope. requires a metronome called *metro* to be bound in the environment</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(setpe au id element value [duration])</string>
	</dict>
	<key>setpeg</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>audiounit</string>
			<key>duration</key>
			<string>duration in beats to move linearly to value</string>
			<key>element</key>
			<string>element number</string>
			<key>id</key>
			<string>au parameter id</string>
			<key>scope</key>
			<string>global input output or group</string>
			<key>value</key>
			<string>numeric value to set</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>macro to au:set-param. sets audiounits global parameter id to value with the option of moving linearly to the value over duration. this macro requires that a beat variable be available in the current scope. requires a metronome called *metro* to be bound in the environment</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(setpeg au id scope element value [duration])</string>
	</dict>
	<key>setpegn</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>audiounit</string>
			<key>duration</key>
			<string>duration in beats to move linearly to value</string>
			<key>element</key>
			<string>element number</string>
			<key>id</key>
			<string>au parameter id</string>
			<key>scope</key>
			<string>global input output or group</string>
			<key>value</key>
			<string>numeric value to set</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>macro to au:set-param. sets audiounits global parameter id to value with the option of moving linearly to the value over duration. this macro requires that a beat variable be available in the current scope. requires a metronome called *metro* to be bound in the environment</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(setpegn au id scope element value [duration])</string>
	</dict>
	<key>setpen</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>audiounit</string>
			<key>duration</key>
			<string>duration in beats to move linearly to value</string>
			<key>element</key>
			<string>element number</string>
			<key>id</key>
			<string>au parameter id</string>
			<key>value</key>
			<string>numeric value to set</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>macro to au:set-param. sets audiounits global parameter id to value with the option of moving linearly to the value over duration. this macro requires that a beat variable be available in the current scope. requires a metronome called *metro* to be bound in the environment</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(setpen au id element value [duration])</string>
	</dict>
	<key>setpn</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>audiounit</string>
			<key>duration</key>
			<string>duration in beats to move linearly to value</string>
			<key>id</key>
			<string>au parameter id</string>
			<key>value</key>
			<string>numeric value to set</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>macro to au:set-param. sets audiounits global parameter id to value with the option of moving linearly to the value over duration. requires a metronome called *metro* to be bound in the environment</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(setpn au id value [duration])</string>
	</dict>
	<key>sexpr-&gt;string</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>exr</key>
			<string>a scheme expression</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns an expression as a string</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>string</string>
		<key>short</key>
		<string>(sexpr-&gt;string exr)</string>
	</dict>
	<key>sin</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>num</key>
			<string>number</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>return the sine value of num</string>
		</array>
		<key>returns</key>
		<string>number</string>
		<key>short</key>
		<string>(sin num)</string>
	</dict>
	<key>sinr</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>centre</key>
			<string>the centre point of your oscillation</string>
			<key>cycle</key>
			<string>the cycle of the oscillation</string>
			<key>range</key>
			<string>the amplitude of your oscillation</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>oscillate around a central point using beat as the modulation frequency </string>
		</array>
		<key>returns</key>
		<string>number</string>
		<key>short</key>
		<string>(sinr centre range cycle)</string>
	</dict>
	<key>spaces:bind</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>tuple-matches-with-symbols</key>
			<string>strings are regular expression matches, numbers match numbers, lists of 2 items match numbers - first list item is &lt; &gt; &lt;= &gt;= &lt;&gt; second list item is a number</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Impromptu spaces is based on Tuple Spaces
;; Tuple spaces first appeared in Linda 1972
;;
;; Spaces provides a mechanism for shared memory
;; transparently between processes 
;; and even across hosts.
;;
;; Tuples can be of any length and can include
;; numbers, strings and vectors
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; first let&apos;s add some data to spaces
;; we&apos;ll add a 3-tuple of {string,number,number}
;; tuples can be made up of any number of
;; strings, integers, reals and lists
(spaces:write &quot;stuff&quot; 1 55.5)

;; we read it back by matching against tuples in the space
;; 
;; stings match strings
;; numbers match numbers
;; vectors match vectors
;; #t matches anything
;;
;; You must match from the start of a tuple
;; but you do not need to match against the whole tuple
;;
;; for example, you can just match the first element of the tuple
;; read returns a list of matching tuples (a list of lists)
(define result (spaces:read &quot;stuff&quot;))
(print result)

;; if we add a new 4-tuple {string,num,num,vector}
(spaces:write &quot;stuff&quot; 1 66.6 &apos;#(1 2 3))

;; matching against &quot;stuff&quot; will return both tuples
;; even though the tuples are different lengths
(print &apos;-&gt; (spaces:read &quot;stuff&quot;))

;; we could be more explicit with out tuple match
;; by matching against more of the tuple
(print &apos;-&gt; (spaces:read &quot;stuff&quot; 1 55.5))

;; tuples don&apos;t need to start with strings
(spaces:write 55.5 &apos;#(1 2 3) 70)
(print &apos;-&gt; (spaces:read 55.5))

;; let&apos;s try some more matches
(spaces:write &quot;morestuff&quot; 1 77.7 &apos;#(4 6 7))

;; we could return all tuples
;; whose 2nd element is 1
(print &apos;-&gt; (spaces:read #t 1))

;; you can use as many match criteria as you like
;; here we match explicitly against positions 2 and 4
;; #t matches against anything in positions 1 and 3
(print &apos;-&gt; (spaces:read #t 1 #t &apos;#(1 2 3)))


;; by default spaces uses simple direct string matching
;; &quot;string&quot; == &quot;string&quot;
;; however, if efficiency is not a large concern
;; you can also use regular expression matching
;; by setting regex matches to true
;; (spaces:regex-string-match #t)
;; you can set back to #f at any time.
;;
;; then we can match against &quot;morestuff&quot; and &quot;stuff&quot;
(spaces:regex-string-match #t)
(print &apos;-&gt; (spaces:read &quot;^.*stuff$&quot;))

;; numbers can be searched by providing
;; a search predicate &lt; &gt; &lt;= &gt;= &lt;&gt;
;; with a number
;; as the two elements of a list
;; in the tuple position that we want to test
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt;&gt; . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt;= . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt; . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&gt; . 66.6)))

;; we can also match against vectors
(print &apos;-&gt; (spaces:read #t 1 #t &apos;#(4 6 7)))

;; we can also do a type of read that also removes
;; the returned results from spaces
;; we use spaces:take-all for this purpose
(print &apos;-&gt; (spaces:take-all &quot;.*stuff&quot;))

;; if we now try to read &quot;.*stuff&quot;
;; you would expect an empty result
;; because spaces:take-all will have
;; removed everything.
;; However, spaces:read actually blocks
;; waiting for a match
(print &apos;-&gt; (spaces:read &quot;.*stuff&quot;))

;; so let&apos;s give it something to match
(spaces:write &quot;andrewsstuff&quot; 1 2 3)

;; note that spaces:read just returned a result
;; neat huh!
;; you can also ask take to remove just the 
;; first matched result.  This can be useful
;; as you can potentially add multiple similar 
;; tuples ... something like this
(spaces:write &quot;andrewsstuff&quot; 2 2 3)
(spaces:write &quot;andrewsstuff&quot; 3 2 3)
(spaces:write &quot;andrewsstuff&quot; 4 2 3)

(print &apos;-&gt; (spaces:read &quot;andrewsstuff&quot;))
;; take one at a time
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
;; try again!
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
;; whoops nothing left - better add another one
(spaces:write &quot;andrewsstuff&quot; 5 2 3)

;; spaces includes a bind operator that allows you
;; to bind symbols against the FIRST result of a query.
;; bind operates similarly to read accept that it 
;; does not return a result.  Instead it accepts
;; symbols in tuple positions and binds the result
;; value to the symbol.  bind looks similar to read
;; where #t&apos;s are replaced with symbols to bind

(spaces:write &quot;andrewsstuff&quot; 6 2 3)(spaces:write &quot;andrewsstuff&quot; 7 2 3)
(print &apos;-&gt; (spaces:read &quot;andrewsstuff&quot; #t 2 #t))
(spaces:bind &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2)
(print var1 var2)
;; bind also has a bind take variant that removes
;; the FIRST matched result just like take
(spaces:bindt &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2)
(print var1 var2)
(spaces:bindt &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2)
(print var1 var2)

;; spaces:wait is the opposite of read
;; it blocks until a particular match
;; is NOT available in the spaces db
(spaces:write &quot;test&quot; 1 2 3)
(print &apos;done-waiting (spaces:wait &quot;test&quot; 1 2 3))
(spaces:delete &quot;test&quot; 1 2 3)


;; finally - and most importantly
;; you can use any process (on any host!)
;; as the host of the spaces db
;; you could use ipc:connect-to-process instead!
(ipc:new-process &quot;my-new-proc&quot; 9876)
(set! *spaces:process* &quot;my-new-proc&quot;)

;; everything works exactly the same as before
(spaces:write &quot;helloworld&quot; 1 2 3)
(print &apos;from-my-new-proc-&gt; (spaces:read &quot;helloworld&quot;))
(spaces:bindt &apos;var1 1 &apos;var2 3)
(print var1 var2)
;; including blocking
(print &apos;from-my-new-proc-&gt; (spaces:read &quot;helloworld&quot;))
(spaces:write &quot;helloworld&quot; 4 &apos;#(1 2 3) &quot;another string&quot; 6)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; a more concrete example

(spaces:regex-string-match #f)

;; first define dls
(define dls (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))
(au:connect-node dls 0 *au:output-node* 0)
(au:update-graph)

;; start an infinite loop
;; spaces:bindt will block until it can match a tuple
;; spaces:bindt also removes the tuple that it matches
;; thus forcing it to block again
(define loop
   (lambda ()      
      (spaces:bindt &quot;/mailbox/andrew/note&quot; &apos;time &apos;pitch &apos;volume &apos;duration)
      (play-note (clock-&gt;samples time) dls pitch volume duration)
      (loop)))

;; start the loop
(loop)

;; add a new note
(spaces:write &quot;/mailbox/andrew/note&quot; (clock) 60 80 20000)

;; try adding three notes at once
(begin (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 60 80 20000)
       (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 63 80 20000)
       (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 67 80 20000))

;; now start a second loop to control the first loop
;; this second loop could happily be in a second process
;; or even a remote host
(define loop2
   (lambda (beat) 
      (spaces:write &quot;/mailbox/andrew/note&quot; 
                    (samples-&gt;clock (*metro* beat))
                    (random 40 80)
                    (random 50 70)
                    3500)
      (callback (*metro* (+ beat (* .5 .5))) &apos;loop2 (+ beat .5))))

(loop2 (*metro* &apos;get-beat 4))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; if we wanted multiple clients all reading the same 
;; spaces db then we could either
;; a) write multiple times (with indexes for example)
;;    for each host so that bindt removed only that
;;    particular clients tuple
;; b) use spaces:wait and spaces:delete as the
;;    modifications below demonstrate. this example will
;;    work for any number of clients connected to the 
;;    same spaces db
(define loop
   (lambda ()      
      (spaces:bind &quot;/mailbox/andrew/note&quot; &apos;time &apos;pitch &apos;volume &apos;duration)
      (play-note (clock-&gt;samples time) dls pitch volume duration)
      (spaces:wait &quot;/mailbox/andrew/note&quot; time pitch volume duration)
      (loop)))

(define loop2
   (lambda (beat) 
      (spaces:delete &quot;/mailbox/andrew/note&quot;)
      (spaces:write &quot;/mailbox/andrew/note&quot; 
                    (samples-&gt;clock (*metro* beat))
                    (random 40 80)
                    (random 50 70)
                    3500)
      (callback (*metro* (+ beat (* .5 .5))) &apos;loop2 (+ beat .5))))
</string>
		</array>
		<key>long</key>
		<array>
			<string>works similarly to read but instead of returning values it binds them to supplied symbols. symbols act like #t in read but bind the value from that tuple position.  only the first matched tuple is bound.  no change is made to the db</string>
		</array>
		<key>related</key>
		<string>ipc:read ipc:write ipc:take ipc:delete ipc:bind ipc:bindt</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(spaces:bind . tuple-matches-with-symbols)</string>
	</dict>
	<key>spaces:bindt</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>tuple-matches-with-symbols</key>
			<string>strings are regular expression matches, numbers match numbers, lists of 2 items match numbers - first list item is &lt; &gt; &lt;= &gt;= &lt;&gt; second list item is a number</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Impromptu spaces is based on Tuple Spaces
;; Tuple spaces first appeared in Linda 1972
;;
;; Spaces provides a mechanism for shared memory
;; transparently between processes 
;; and even across hosts.
;;
;; Tuples can be of any length and can include
;; numbers, strings and vectors
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; first let&apos;s add some data to spaces
;; we&apos;ll add a 3-tuple of {string,number,number}
;; tuples can be made up of any number of
;; strings, integers, reals and lists
(spaces:write &quot;stuff&quot; 1 55.5)

;; we read it back by matching against tuples in the space
;; 
;; stings match strings
;; numbers match numbers
;; vectors match vectors
;; #t matches anything
;;
;; You must match from the start of a tuple
;; but you do not need to match against the whole tuple
;;
;; for example, you can just match the first element of the tuple
;; read returns a list of matching tuples (a list of lists)
(define result (spaces:read &quot;stuff&quot;))
(print result)

;; if we add a new 4-tuple {string,num,num,vector}
(spaces:write &quot;stuff&quot; 1 66.6 &apos;#(1 2 3))

;; matching against &quot;stuff&quot; will return both tuples
;; even though the tuples are different lengths
(print &apos;-&gt; (spaces:read &quot;stuff&quot;))

;; we could be more explicit with out tuple match
;; by matching against more of the tuple
(print &apos;-&gt; (spaces:read &quot;stuff&quot; 1 55.5))

;; tuples don&apos;t need to start with strings
(spaces:write 55.5 &apos;#(1 2 3) 70)
(print &apos;-&gt; (spaces:read 55.5))

;; let&apos;s try some more matches
(spaces:write &quot;morestuff&quot; 1 77.7 &apos;#(4 6 7))

;; we could return all tuples
;; whose 2nd element is 1
(print &apos;-&gt; (spaces:read #t 1))

;; you can use as many match criteria as you like
;; here we match explicitly against positions 2 and 4
;; #t matches against anything in positions 1 and 3
(print &apos;-&gt; (spaces:read #t 1 #t &apos;#(1 2 3)))


;; by default spaces uses simple direct string matching
;; &quot;string&quot; == &quot;string&quot;
;; however, if efficiency is not a large concern
;; you can also use regular expression matching
;; by setting regex matches to true
;; (spaces:regex-string-match #t)
;; you can set back to #f at any time.
;;
;; then we can match against &quot;morestuff&quot; and &quot;stuff&quot;
(spaces:regex-string-match #t)
(print &apos;-&gt; (spaces:read &quot;^.*stuff$&quot;))

;; numbers can be searched by providing
;; a search predicate &lt; &gt; &lt;= &gt;= &lt;&gt;
;; with a number
;; as the two elements of a list
;; in the tuple position that we want to test
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt;&gt; . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt;= . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt; . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&gt; . 66.6)))

;; we can also match against vectors
(print &apos;-&gt; (spaces:read #t 1 #t &apos;#(4 6 7)))

;; we can also do a type of read that also removes
;; the returned results from spaces
;; we use spaces:take-all for this purpose
(print &apos;-&gt; (spaces:take-all &quot;.*stuff&quot;))

;; if we now try to read &quot;.*stuff&quot;
;; you would expect an empty result
;; because spaces:take-all will have
;; removed everything.
;; However, spaces:read actually blocks
;; waiting for a match
(print &apos;-&gt; (spaces:read &quot;.*stuff&quot;))

;; so let&apos;s give it something to match
(spaces:write &quot;andrewsstuff&quot; 1 2 3)

;; note that spaces:read just returned a result
;; neat huh!
;; you can also ask take to remove just the 
;; first matched result.  This can be useful
;; as you can potentially add multiple similar 
;; tuples ... something like this
(spaces:write &quot;andrewsstuff&quot; 2 2 3)
(spaces:write &quot;andrewsstuff&quot; 3 2 3)
(spaces:write &quot;andrewsstuff&quot; 4 2 3)

(print &apos;-&gt; (spaces:read &quot;andrewsstuff&quot;))
;; take one at a time
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
;; try again!
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
;; whoops nothing left - better add another one
(spaces:write &quot;andrewsstuff&quot; 5 2 3)

;; spaces includes a bind operator that allows you
;; to bind symbols against the FIRST result of a query.
;; bind operates similarly to read accept that it 
;; does not return a result.  Instead it accepts
;; symbols in tuple positions and binds the result
;; value to the symbol.  bind looks similar to read
;; where #t&apos;s are replaced with symbols to bind

(spaces:write &quot;andrewsstuff&quot; 6 2 3)(spaces:write &quot;andrewsstuff&quot; 7 2 3)
(print &apos;-&gt; (spaces:read &quot;andrewsstuff&quot; #t 2 #t))
(spaces:bind &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2)
(print var1 var2)
;; bind also has a bind take variant that removes
;; the FIRST matched result just like take
(spaces:bindt &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2)
(print var1 var2)
(spaces:bindt &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2)
(print var1 var2)

;; spaces:wait is the opposite of read
;; it blocks until a particular match
;; is NOT available in the spaces db
(spaces:write &quot;test&quot; 1 2 3)
(print &apos;done-waiting (spaces:wait &quot;test&quot; 1 2 3))
(spaces:delete &quot;test&quot; 1 2 3)


;; finally - and most importantly
;; you can use any process (on any host!)
;; as the host of the spaces db
;; you could use ipc:connect-to-process instead!
(ipc:new-process &quot;my-new-proc&quot; 9876)
(set! *spaces:process* &quot;my-new-proc&quot;)

;; everything works exactly the same as before
(spaces:write &quot;helloworld&quot; 1 2 3)
(print &apos;from-my-new-proc-&gt; (spaces:read &quot;helloworld&quot;))
(spaces:bindt &apos;var1 1 &apos;var2 3)
(print var1 var2)
;; including blocking
(print &apos;from-my-new-proc-&gt; (spaces:read &quot;helloworld&quot;))
(spaces:write &quot;helloworld&quot; 4 &apos;#(1 2 3) &quot;another string&quot; 6)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; a more concrete example

(spaces:regex-string-match #f)

;; first define dls
(define dls (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))
(au:connect-node dls 0 *au:output-node* 0)
(au:update-graph)

;; start an infinite loop
;; spaces:bindt will block until it can match a tuple
;; spaces:bindt also removes the tuple that it matches
;; thus forcing it to block again
(define loop
   (lambda ()      
      (spaces:bindt &quot;/mailbox/andrew/note&quot; &apos;time &apos;pitch &apos;volume &apos;duration)
      (play-note (clock-&gt;samples time) dls pitch volume duration)
      (loop)))

;; start the loop
(loop)

;; add a new note
(spaces:write &quot;/mailbox/andrew/note&quot; (clock) 60 80 20000)

;; try adding three notes at once
(begin (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 60 80 20000)
       (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 63 80 20000)
       (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 67 80 20000))

;; now start a second loop to control the first loop
;; this second loop could happily be in a second process
;; or even a remote host
(define loop2
   (lambda (beat) 
      (spaces:write &quot;/mailbox/andrew/note&quot; 
                    (samples-&gt;clock (*metro* beat))
                    (random 40 80)
                    (random 50 70)
                    3500)
      (callback (*metro* (+ beat (* .5 .5))) &apos;loop2 (+ beat .5))))

(loop2 (*metro* &apos;get-beat 4))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; if we wanted multiple clients all reading the same 
;; spaces db then we could either
;; a) write multiple times (with indexes for example)
;;    for each host so that bindt removed only that
;;    particular clients tuple
;; b) use spaces:wait and spaces:delete as the
;;    modifications below demonstrate. this example will
;;    work for any number of clients connected to the 
;;    same spaces db
(define loop
   (lambda ()      
      (spaces:bind &quot;/mailbox/andrew/note&quot; &apos;time &apos;pitch &apos;volume &apos;duration)
      (play-note (clock-&gt;samples time) dls pitch volume duration)
      (spaces:wait &quot;/mailbox/andrew/note&quot; time pitch volume duration)
      (loop)))

(define loop2
   (lambda (beat) 
      (spaces:delete &quot;/mailbox/andrew/note&quot;)
      (spaces:write &quot;/mailbox/andrew/note&quot; 
                    (samples-&gt;clock (*metro* beat))
                    (random 40 80)
                    (random 50 70)
                    3500)
      (callback (*metro* (+ beat (* .5 .5))) &apos;loop2 (+ beat .5))))
</string>
		</array>
		<key>long</key>
		<array>
			<string>works similarly to read but instead of returning values it binds them to supplied symbols. symbols act like #t in read but bind the value from that tuple position.  only the first matched tuple is bound and removed from the db</string>
		</array>
		<key>related</key>
		<string>ipc:read ipc:write ipc:take ipc:delete ipc:bind ipc:bindt</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(spaces:bindt . tuple-matches-with-symbols)</string>
	</dict>
	<key>spaces:delete</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>tuple-matches</key>
			<string>strings are regular expression matches, numbers match numbers, lists of 2 items match numbers - first list item is &lt; &gt; &lt;= &gt;= &lt;&gt; second list item is a number</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Impromptu spaces is based on Tuple Spaces
;; Tuple spaces first appeared in Linda 1972
;;
;; Spaces provides a mechanism for shared memory
;; transparently between processes 
;; and even across hosts.
;;
;; Tuples can be of any length and can include
;; numbers, strings and vectors
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; first let&apos;s add some data to spaces
;; we&apos;ll add a 3-tuple of {string,number,number}
;; tuples can be made up of any number of
;; strings, integers, reals and lists
(spaces:write &quot;stuff&quot; 1 55.5)

;; we read it back by matching against tuples in the space
;; 
;; stings match strings
;; numbers match numbers
;; vectors match vectors
;; #t matches anything
;;
;; You must match from the start of a tuple
;; but you do not need to match against the whole tuple
;;
;; for example, you can just match the first element of the tuple
;; read returns a list of matching tuples (a list of lists)
(define result (spaces:read &quot;stuff&quot;))
(print result)

;; if we add a new 4-tuple {string,num,num,vector}
(spaces:write &quot;stuff&quot; 1 66.6 &apos;#(1 2 3))

;; matching against &quot;stuff&quot; will return both tuples
;; even though the tuples are different lengths
(print &apos;-&gt; (spaces:read &quot;stuff&quot;))

;; we could be more explicit with out tuple match
;; by matching against more of the tuple
(print &apos;-&gt; (spaces:read &quot;stuff&quot; 1 55.5))

;; tuples don&apos;t need to start with strings
(spaces:write 55.5 &apos;#(1 2 3) 70)
(print &apos;-&gt; (spaces:read 55.5))

;; let&apos;s try some more matches
(spaces:write &quot;morestuff&quot; 1 77.7 &apos;#(4 6 7))

;; we could return all tuples
;; whose 2nd element is 1
(print &apos;-&gt; (spaces:read #t 1))

;; you can use as many match criteria as you like
;; here we match explicitly against positions 2 and 4
;; #t matches against anything in positions 1 and 3
(print &apos;-&gt; (spaces:read #t 1 #t &apos;#(1 2 3)))


;; by default spaces uses simple direct string matching
;; &quot;string&quot; == &quot;string&quot;
;; however, if efficiency is not a large concern
;; you can also use regular expression matching
;; by setting regex matches to true
;; (spaces:regex-string-match #t)
;; you can set back to #f at any time.
;;
;; then we can match against &quot;morestuff&quot; and &quot;stuff&quot;
(spaces:regex-string-match #t)
(print &apos;-&gt; (spaces:read &quot;^.*stuff$&quot;))

;; numbers can be searched by providing
;; a search predicate &lt; &gt; &lt;= &gt;= &lt;&gt;
;; with a number
;; as the two elements of a list
;; in the tuple position that we want to test
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt;&gt; . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt;= . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt; . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&gt; . 66.6)))

;; we can also match against vectors
(print &apos;-&gt; (spaces:read #t 1 #t &apos;#(4 6 7)))

;; we can also do a type of read that also removes
;; the returned results from spaces
;; we use spaces:take-all for this purpose
(print &apos;-&gt; (spaces:take-all &quot;.*stuff&quot;))

;; if we now try to read &quot;.*stuff&quot;
;; you would expect an empty result
;; because spaces:take-all will have
;; removed everything.
;; However, spaces:read actually blocks
;; waiting for a match
(print &apos;-&gt; (spaces:read &quot;.*stuff&quot;))

;; so let&apos;s give it something to match
(spaces:write &quot;andrewsstuff&quot; 1 2 3)

;; note that spaces:read just returned a result
;; neat huh!
;; you can also ask take to remove just the 
;; first matched result.  This can be useful
;; as you can potentially add multiple similar 
;; tuples ... something like this
(spaces:write &quot;andrewsstuff&quot; 2 2 3)
(spaces:write &quot;andrewsstuff&quot; 3 2 3)
(spaces:write &quot;andrewsstuff&quot; 4 2 3)

(print &apos;-&gt; (spaces:read &quot;andrewsstuff&quot;))
;; take one at a time
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
;; try again!
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
;; whoops nothing left - better add another one
(spaces:write &quot;andrewsstuff&quot; 5 2 3)

;; read also accepts symbols in tuple positions and binds 
;; the result value of the tuple position of the symbol
;; to the symbol in the current environement

(spaces:write &quot;andrewsstuff&quot; 6 2 3)(spaces:write &quot;andrewsstuff&quot; 7 2 3)
(print &apos;-&gt; (spaces:read &quot;andrewsstuff&quot; #t 2 #t))
(print &apos;-&gt; (spaces:read &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2))
(print var1 var2)
;; take also allows you to bind symbols.
;; the FIRST matched result just like take
(spaces:take &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2)
(print var1 var2)
(spaces:take &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2)
(print var1 var2)

;; spaces:wait is the opposite of read
;; it blocks until a particular match
;; is NOT available in the spaces db
(spaces:write &quot;test&quot; 1 2 3)
(print &apos;done-waiting (spaces:wait &quot;test&quot; 1 2 3))
(spaces:delete &quot;test&quot; 1 2 3)


;; finally - and most importantly
;; you can use any process (on any host!)
;; as the host of the spaces db
;; you could use ipc:connect-to-process instead!
(ipc:new-process &quot;my-new-proc&quot; 9876)
(set! *spaces:process* &quot;my-new-proc&quot;)

;; everything works exactly the same as before
(spaces:write &quot;helloworld&quot; 1 2 3)
(print &apos;from-my-new-proc-&gt; (spaces:read &quot;helloworld&quot;))
(spaces:take &apos;var1 1 &apos;var2 3)
(print var1 var2)
;; including blocking
(print &apos;from-my-new-proc-&gt; (spaces:read &quot;helloworld&quot;))
(spaces:write &quot;helloworld&quot; 4 &apos;#(1 2 3) &quot;another string&quot; 6)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; a more concrete example

(spaces:regex-string-match #f)

;; first define dls
(define dls (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))
(au:connect-node dls 0 *au:output-node* 0)
(au:update-graph)

;; start an infinite loop
;; spaces:take will block until it can match a tuple
;; spaces:take also removes the tuple that it matches
;; thus forcing it to block again
(define loop
   (lambda ()      
      (spaces:take &quot;/mailbox/andrew/note&quot; &apos;time &apos;pitch &apos;volume &apos;duration)
      (play-note (clock-&gt;samples time) dls pitch volume duration)
      (loop)))

;; start the loop
(loop)

;; add a new note
(spaces:write &quot;/mailbox/andrew/note&quot; (clock) 60 80 20000)

;; try adding three notes at once
(begin (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 60 80 20000)
       (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 63 80 20000)
       (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 67 80 20000))

;; now start a second loop to control the first loop
;; this second loop could happily be in a second process
;; or even a remote host
(define loop2
   (lambda (beat) 
      (spaces:write &quot;/mailbox/andrew/note&quot; 
                    (samples-&gt;clock (*metro* beat))
                    (random 40 80)
                    (random 50 70)
                    3500)
      (callback (*metro* (+ beat (* .5 .5))) &apos;loop2 (+ beat .5))))

(loop2 (*metro* &apos;get-beat 4))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; if we wanted multiple clients all reading the same 
;; spaces db then we could either
;; a) write multiple times (with indexes for example)
;;    for each host so that read removed only that
;;    particular clients tuple
;; b) use spaces:wait and spaces:delete as the
;;    modifications below demonstrate. this example will
;;    work for any number of clients connected to the 
;;    same spaces db
(define loop
   (lambda ()      
      (spaces:read &quot;/mailbox/andrew/note&quot; &apos;time &apos;pitch &apos;volume &apos;duration)
      (play-note (clock-&gt;samples time) dls pitch volume duration)
      (spaces:wait &quot;/mailbox/andrew/note&quot; time pitch volume duration)
      (loop)))

(define loop2
   (lambda (beat) 
      (spaces:delete &quot;/mailbox/andrew/note&quot;)
      (spaces:write &quot;/mailbox/andrew/note&quot; 
                    (samples-&gt;clock (*metro* beat))
                    (random 40 80)
                    (random 50 70)
                    3500)
      (callback (*metro* (+ beat (* .5 .5))) &apos;loop2 (+ beat .5))))</string>
		</array>
		<key>long</key>
		<array>
			<string>Delete works like read but does not return matches, instead it deletes them from the spaces db.  Similar to spaces:take-all but does not block and does not return matches.</string>
		</array>
		<key>related</key>
		<string>ipc:read ipc:write ipc:take ipc:delete ipc:bind ipc:bindt ipc:wait</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(spaces:delete . tuple-matches)</string>
	</dict>
	<key>spaces:load</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>filename</key>
			<string>file to load spaces db from</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Impromptu spaces is based on Tuple Spaces
;; Tuple spaces first appeared in Linda 1972
;;
;; Spaces provides a mechanism for shared memory
;; transparently between processes 
;; and even across hosts.
;;
;; Tuples can be of any length and can include
;; numbers, strings and vectors
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; first let&apos;s add some data to spaces
;; we&apos;ll add a 3-tuple of {string,number,number}
;; tuples can be made up of any number of
;; strings, integers, reals and lists
(spaces:write &quot;stuff&quot; 1 55.5)

;; we read it back by matching against tuples in the space
;; 
;; stings match strings
;; numbers match numbers
;; vectors match vectors
;; #t matches anything
;;
;; You must match from the start of a tuple
;; but you do not need to match against the whole tuple
;;
;; for example, you can just match the first element of the tuple
;; read returns a list of matching tuples (a list of lists)
(define result (spaces:read &quot;stuff&quot;))
(print result)

;; if we add a new 4-tuple {string,num,num,vector}
(spaces:write &quot;stuff&quot; 1 66.6 &apos;#(1 2 3))

;; matching against &quot;stuff&quot; will return both tuples
;; even though the tuples are different lengths
(print &apos;-&gt; (spaces:read &quot;stuff&quot;))

;; we could be more explicit with out tuple match
;; by matching against more of the tuple
(print &apos;-&gt; (spaces:read &quot;stuff&quot; 1 55.5))

;; tuples don&apos;t need to start with strings
(spaces:write 55.5 &apos;#(1 2 3) 70)
(print &apos;-&gt; (spaces:read 55.5))

;; let&apos;s try some more matches
(spaces:write &quot;morestuff&quot; 1 77.7 &apos;#(4 6 7))

;; we could return all tuples
;; whose 2nd element is 1
(print &apos;-&gt; (spaces:read #t 1))

;; you can use as many match criteria as you like
;; here we match explicitly against positions 2 and 4
;; #t matches against anything in positions 1 and 3
(print &apos;-&gt; (spaces:read #t 1 #t &apos;#(1 2 3)))


;; by default spaces uses simple direct string matching
;; &quot;string&quot; == &quot;string&quot;
;; however, if efficiency is not a large concern
;; you can also use regular expression matching
;; by setting regex matches to true
;; (spaces:regex-string-match #t)
;; you can set back to #f at any time.
;;
;; then we can match against &quot;morestuff&quot; and &quot;stuff&quot;
(spaces:regex-string-match #t)
(print &apos;-&gt; (spaces:read &quot;^.*stuff$&quot;))

;; numbers can be searched by providing
;; a search predicate &lt; &gt; &lt;= &gt;= &lt;&gt;
;; with a number
;; as the two elements of a list
;; in the tuple position that we want to test
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt;&gt; . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt;= . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt; . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&gt; . 66.6)))

;; we can also match against vectors
(print &apos;-&gt; (spaces:read #t 1 #t &apos;#(4 6 7)))

;; we can also do a type of read that also removes
;; the returned results from spaces
;; we use spaces:take-all for this purpose
(print &apos;-&gt; (spaces:take-all &quot;.*stuff&quot;))

;; if we now try to read &quot;.*stuff&quot;
;; you would expect an empty result
;; because spaces:take-all will have
;; removed everything.
;; However, spaces:read actually blocks
;; waiting for a match
(print &apos;-&gt; (spaces:read &quot;.*stuff&quot;))

;; so let&apos;s give it something to match
(spaces:write &quot;andrewsstuff&quot; 1 2 3)

;; note that spaces:read just returned a result
;; neat huh!
;; you can also ask take to remove just the 
;; first matched result.  This can be useful
;; as you can potentially add multiple similar 
;; tuples ... something like this
(spaces:write &quot;andrewsstuff&quot; 2 2 3)
(spaces:write &quot;andrewsstuff&quot; 3 2 3)
(spaces:write &quot;andrewsstuff&quot; 4 2 3)

(print &apos;-&gt; (spaces:read &quot;andrewsstuff&quot;))
;; take one at a time
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
;; try again!
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
;; whoops nothing left - better add another one
(spaces:write &quot;andrewsstuff&quot; 5 2 3)

;; spaces includes a bind operator that allows you
;; to bind symbols against the FIRST result of a query.
;; bind operates similarly to read accept that it 
;; does not return a result.  Instead it accepts
;; symbols in tuple positions and binds the result
;; value to the symbol.  bind looks similar to read
;; where #t&apos;s are replaced with symbols to bind

(spaces:write &quot;andrewsstuff&quot; 6 2 3)(spaces:write &quot;andrewsstuff&quot; 7 2 3)
(print &apos;-&gt; (spaces:read &quot;andrewsstuff&quot; #t 2 #t))
(spaces:bind &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2)
(print var1 var2)
;; bind also has a bind take variant that removes
;; the FIRST matched result just like take
(spaces:bindt &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2)
(print var1 var2)
(spaces:bindt &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2)
(print var1 var2)

;; spaces:wait is the opposite of read
;; it blocks until a particular match
;; is NOT available in the spaces db
(spaces:write &quot;test&quot; 1 2 3)
(print &apos;done-waiting (spaces:wait &quot;test&quot; 1 2 3))
(spaces:delete &quot;test&quot; 1 2 3)


;; finally - and most importantly
;; you can use any process (on any host!)
;; as the host of the spaces db
;; you could use ipc:connect-to-process instead!
(ipc:new-process &quot;my-new-proc&quot; 9876)
(set! *spaces:process* &quot;my-new-proc&quot;)

;; everything works exactly the same as before
(spaces:write &quot;helloworld&quot; 1 2 3)
(print &apos;from-my-new-proc-&gt; (spaces:read &quot;helloworld&quot;))
(spaces:bindt &apos;var1 1 &apos;var2 3)
(print var1 var2)
;; including blocking
(print &apos;from-my-new-proc-&gt; (spaces:read &quot;helloworld&quot;))
(spaces:write &quot;helloworld&quot; 4 &apos;#(1 2 3) &quot;another string&quot; 6)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; a more concrete example

(spaces:regex-string-match #f)

;; first define dls
(define dls (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))
(au:connect-node dls 0 *au:output-node* 0)
(au:update-graph)

;; start an infinite loop
;; spaces:bindt will block until it can match a tuple
;; spaces:bindt also removes the tuple that it matches
;; thus forcing it to block again
(define loop
   (lambda ()      
      (spaces:bindt &quot;/mailbox/andrew/note&quot; &apos;time &apos;pitch &apos;volume &apos;duration)
      (play-note (clock-&gt;samples time) dls pitch volume duration)
      (loop)))

;; start the loop
(loop)

;; add a new note
(spaces:write &quot;/mailbox/andrew/note&quot; (clock) 60 80 20000)

;; try adding three notes at once
(begin (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 60 80 20000)
       (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 63 80 20000)
       (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 67 80 20000))

;; now start a second loop to control the first loop
;; this second loop could happily be in a second process
;; or even a remote host
(define loop2
   (lambda (beat) 
      (spaces:write &quot;/mailbox/andrew/note&quot; 
                    (samples-&gt;clock (*metro* beat))
                    (random 40 80)
                    (random 50 70)
                    3500)
      (callback (*metro* (+ beat (* .5 .5))) &apos;loop2 (+ beat .5))))

(loop2 (*metro* &apos;get-beat 4))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; if we wanted multiple clients all reading the same 
;; spaces db then we could either
;; a) write multiple times (with indexes for example)
;;    for each host so that bindt removed only that
;;    particular clients tuple
;; b) use spaces:wait and spaces:delete as the
;;    modifications below demonstrate. this example will
;;    work for any number of clients connected to the 
;;    same spaces db
(define loop
   (lambda ()      
      (spaces:bind &quot;/mailbox/andrew/note&quot; &apos;time &apos;pitch &apos;volume &apos;duration)
      (play-note (clock-&gt;samples time) dls pitch volume duration)
      (spaces:wait &quot;/mailbox/andrew/note&quot; time pitch volume duration)
      (loop)))

(define loop2
   (lambda (beat) 
      (spaces:delete &quot;/mailbox/andrew/note&quot;)
      (spaces:write &quot;/mailbox/andrew/note&quot; 
                    (samples-&gt;clock (*metro* beat))
                    (random 40 80)
                    (random 50 70)
                    3500)
      (callback (*metro* (+ beat (* .5 .5))) &apos;loop2 (+ beat .5))))
</string>
		</array>
		<key>long</key>
		<array>
			<string>loads a spaces db from file</string>
		</array>
		<key>related</key>
		<string>ipc:read ipc:write ipc:take ipc:delete ipc:bind ipc:bindt ipc:wait ipc:save</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(spaces:load filename)</string>
	</dict>
	<key>spaces:read</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>tuple-matches</key>
			<string>strings are regular expression matches, numbers match numbers, lists of 2 items match numbers - first list item is &lt; &gt; &lt;= &gt;= &lt;&gt; second list item is a number</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Impromptu spaces is based on Tuple Spaces
;; Tuple spaces first appeared in Linda 1972
;;
;; Spaces provides a mechanism for shared memory
;; transparently between processes 
;; and even across hosts.
;;
;; Tuples can be of any length and can include
;; numbers, strings and vectors
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; first let&apos;s add some data to spaces
;; we&apos;ll add a 3-tuple of {string,number,number}
;; tuples can be made up of any number of
;; strings, integers, reals and lists
(spaces:write &quot;stuff&quot; 1 55.5)

;; we read it back by matching against tuples in the space
;; 
;; stings match strings
;; numbers match numbers
;; vectors match vectors
;; #t matches anything
;;
;; You must match from the start of a tuple
;; but you do not need to match against the whole tuple
;;
;; for example, you can just match the first element of the tuple
;; read returns a list of matching tuples (a list of lists)
(define result (spaces:read &quot;stuff&quot;))
(print result)

;; if we add a new 4-tuple {string,num,num,vector}
(spaces:write &quot;stuff&quot; 1 66.6 &apos;#(1 2 3))

;; matching against &quot;stuff&quot; will return both tuples
;; even though the tuples are different lengths
(print &apos;-&gt; (spaces:read &quot;stuff&quot;))

;; we could be more explicit with out tuple match
;; by matching against more of the tuple
(print &apos;-&gt; (spaces:read &quot;stuff&quot; 1 55.5))

;; tuples don&apos;t need to start with strings
(spaces:write 55.5 &apos;#(1 2 3) 70)
(print &apos;-&gt; (spaces:read 55.5))

;; let&apos;s try some more matches
(spaces:write &quot;morestuff&quot; 1 77.7 &apos;#(4 6 7))

;; we could return all tuples
;; whose 2nd element is 1
(print &apos;-&gt; (spaces:read #t 1))

;; you can use as many match criteria as you like
;; here we match explicitly against positions 2 and 4
;; #t matches against anything in positions 1 and 3
(print &apos;-&gt; (spaces:read #t 1 #t &apos;#(1 2 3)))


;; by default spaces uses simple direct string matching
;; &quot;string&quot; == &quot;string&quot;
;; however, if efficiency is not a large concern
;; you can also use regular expression matching
;; by setting regex matches to true
;; (spaces:regex-string-match #t)
;; you can set back to #f at any time.
;;
;; then we can match against &quot;morestuff&quot; and &quot;stuff&quot;
(spaces:regex-string-match #t)
(print &apos;-&gt; (spaces:read &quot;^.*stuff$&quot;))

;; numbers can be searched by providing
;; a search predicate &lt; &gt; &lt;= &gt;= &lt;&gt;
;; with a number
;; as the two elements of a list
;; in the tuple position that we want to test
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt;&gt; . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt;= . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt; . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&gt; . 66.6)))

;; we can also match against vectors
(print &apos;-&gt; (spaces:read #t 1 #t &apos;#(4 6 7)))

;; we can also do a type of read that also removes
;; the returned results from spaces
;; we use spaces:take-all for this purpose
(print &apos;-&gt; (spaces:take-all &quot;.*stuff&quot;))

;; if we now try to read &quot;.*stuff&quot;
;; you would expect an empty result
;; because spaces:take-all will have
;; removed everything.
;; However, spaces:read actually blocks
;; waiting for a match
(print &apos;-&gt; (spaces:read &quot;.*stuff&quot;))

;; so let&apos;s give it something to match
(spaces:write &quot;andrewsstuff&quot; 1 2 3)

;; note that spaces:read just returned a result
;; neat huh!
;; you can also ask take to remove just the 
;; first matched result.  This can be useful
;; as you can potentially add multiple similar 
;; tuples ... something like this
(spaces:write &quot;andrewsstuff&quot; 2 2 3)
(spaces:write &quot;andrewsstuff&quot; 3 2 3)
(spaces:write &quot;andrewsstuff&quot; 4 2 3)

(print &apos;-&gt; (spaces:read &quot;andrewsstuff&quot;))
;; take one at a time
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
;; try again!
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
;; whoops nothing left - better add another one
(spaces:write &quot;andrewsstuff&quot; 5 2 3)

;; read also accepts symbols in tuple positions and binds 
;; the result value of the tuple position of the symbol
;; to the symbol in the current environement

(spaces:write &quot;andrewsstuff&quot; 6 2 3)(spaces:write &quot;andrewsstuff&quot; 7 2 3)
(print &apos;-&gt; (spaces:read &quot;andrewsstuff&quot; #t 2 #t))
(print &apos;-&gt; (spaces:read &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2))
(print var1 var2)
;; take also allows you to bind symbols.
;; the FIRST matched result just like take
(spaces:take &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2)
(print var1 var2)
(spaces:take &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2)
(print var1 var2)

;; spaces:wait is the opposite of read
;; it blocks until a particular match
;; is NOT available in the spaces db
(spaces:write &quot;test&quot; 1 2 3)
(print &apos;done-waiting (spaces:wait &quot;test&quot; 1 2 3))
(spaces:delete &quot;test&quot; 1 2 3)


;; finally - and most importantly
;; you can use any process (on any host!)
;; as the host of the spaces db
;; you could use ipc:connect-to-process instead!
(ipc:new-process &quot;my-new-proc&quot; 9876)
(set! *spaces:process* &quot;my-new-proc&quot;)

;; everything works exactly the same as before
(spaces:write &quot;helloworld&quot; 1 2 3)
(print &apos;from-my-new-proc-&gt; (spaces:read &quot;helloworld&quot;))
(spaces:take &apos;var1 1 &apos;var2 3)
(print var1 var2)
;; including blocking
(print &apos;from-my-new-proc-&gt; (spaces:read &quot;helloworld&quot;))
(spaces:write &quot;helloworld&quot; 4 &apos;#(1 2 3) &quot;another string&quot; 6)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; a more concrete example

(spaces:regex-string-match #f)

;; first define dls
(define dls (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))
(au:connect-node dls 0 *au:output-node* 0)
(au:update-graph)

;; start an infinite loop
;; spaces:take will block until it can match a tuple
;; spaces:take also removes the tuple that it matches
;; thus forcing it to block again
(define loop
   (lambda ()      
      (spaces:take &quot;/mailbox/andrew/note&quot; &apos;time &apos;pitch &apos;volume &apos;duration)
      (play-note (clock-&gt;samples time) dls pitch volume duration)
      (loop)))

;; start the loop
(loop)

;; add a new note
(spaces:write &quot;/mailbox/andrew/note&quot; (clock) 60 80 20000)

;; try adding three notes at once
(begin (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 60 80 20000)
       (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 63 80 20000)
       (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 67 80 20000))

;; now start a second loop to control the first loop
;; this second loop could happily be in a second process
;; or even a remote host
(define loop2
   (lambda (beat) 
      (spaces:write &quot;/mailbox/andrew/note&quot; 
                    (samples-&gt;clock (*metro* beat))
                    (random 40 80)
                    (random 50 70)
                    3500)
      (callback (*metro* (+ beat (* .5 .5))) &apos;loop2 (+ beat .5))))

(loop2 (*metro* &apos;get-beat 4))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; if we wanted multiple clients all reading the same 
;; spaces db then we could either
;; a) write multiple times (with indexes for example)
;;    for each host so that read removed only that
;;    particular clients tuple
;; b) use spaces:wait and spaces:delete as the
;;    modifications below demonstrate. this example will
;;    work for any number of clients connected to the 
;;    same spaces db
(define loop
   (lambda ()      
      (spaces:read &quot;/mailbox/andrew/note&quot; &apos;time &apos;pitch &apos;volume &apos;duration)
      (play-note (clock-&gt;samples time) dls pitch volume duration)
      (spaces:wait &quot;/mailbox/andrew/note&quot; time pitch volume duration)
      (loop)))

(define loop2
   (lambda (beat) 
      (spaces:delete &quot;/mailbox/andrew/note&quot;)
      (spaces:write &quot;/mailbox/andrew/note&quot; 
                    (samples-&gt;clock (*metro* beat))
                    (random 40 80)
                    (random 50 70)
                    3500)
      (callback (*metro* (+ beat (* .5 .5))) &apos;loop2 (+ beat .5))))</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns a vector of vectors that match tuple-matches. binds any symbol arguments.  matched tuples are left intact in the database</string>
		</array>
		<key>related</key>
		<string>ipc:read ipc:write ipc:take ipc:delete ipc:bind ipc:bindt ipc:wait</string>
		<key>returns</key>
		<string>a vector of vectors</string>
		<key>short</key>
		<string>(spaces:read . tuple-matches)</string>
	</dict>
	<key>spaces:regex-string-match</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>bool</key>
			<string>should we use regex matches #t or simple string matches #f (default is #f)</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Impromptu spaces is based on Tuple Spaces
;; Tuple spaces first appeared in Linda 1972
;;
;; Spaces provides a mechanism for shared memory
;; transparently between processes 
;; and even across hosts.
;;
;; Tuples can be of any length and can include
;; numbers, strings and vectors
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; first let&apos;s add some data to spaces
;; we&apos;ll add a 3-tuple of {string,number,number}
;; tuples can be made up of any number of
;; strings, integers, reals and lists
(spaces:write &quot;stuff&quot; 1 55.5)

;; we read it back by matching against tuples in the space
;; 
;; stings match strings
;; numbers match numbers
;; vectors match vectors
;; #t matches anything
;;
;; You must match from the start of a tuple
;; but you do not need to match against the whole tuple
;;
;; for example, you can just match the first element of the tuple
;; read returns a list of matching tuples (a list of lists)
(define result (spaces:read &quot;stuff&quot;))
(print result)

;; if we add a new 4-tuple {string,num,num,vector}
(spaces:write &quot;stuff&quot; 1 66.6 &apos;#(1 2 3))

;; matching against &quot;stuff&quot; will return both tuples
;; even though the tuples are different lengths
(print &apos;-&gt; (spaces:read &quot;stuff&quot;))

;; we could be more explicit with out tuple match
;; by matching against more of the tuple
(print &apos;-&gt; (spaces:read &quot;stuff&quot; 1 55.5))

;; tuples don&apos;t need to start with strings
(spaces:write 55.5 &apos;#(1 2 3) 70)
(print &apos;-&gt; (spaces:read 55.5))

;; let&apos;s try some more matches
(spaces:write &quot;morestuff&quot; 1 77.7 &apos;#(4 6 7))

;; we could return all tuples
;; whose 2nd element is 1
(print &apos;-&gt; (spaces:read #t 1))

;; you can use as many match criteria as you like
;; here we match explicitly against positions 2 and 4
;; #t matches against anything in positions 1 and 3
(print &apos;-&gt; (spaces:read #t 1 #t &apos;#(1 2 3)))


;; by default spaces uses simple direct string matching
;; &quot;string&quot; == &quot;string&quot;
;; however, if efficiency is not a large concern
;; you can also use regular expression matching
;; by setting regex matches to true
;; (spaces:regex-string-match #t)
;; you can set back to #f at any time.
;;
;; then we can match against &quot;morestuff&quot; and &quot;stuff&quot;
(spaces:regex-string-match #t)
(print &apos;-&gt; (spaces:read &quot;^.*stuff$&quot;))

;; numbers can be searched by providing
;; a search predicate &lt; &gt; &lt;= &gt;= &lt;&gt;
;; with a number
;; as the two elements of a list
;; in the tuple position that we want to test
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt;&gt; . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt;= . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt; . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&gt; . 66.6)))

;; we can also match against vectors
(print &apos;-&gt; (spaces:read #t 1 #t &apos;#(4 6 7)))

;; we can also do a type of read that also removes
;; the returned results from spaces
;; we use spaces:take-all for this purpose
(print &apos;-&gt; (spaces:take-all &quot;.*stuff&quot;))

;; if we now try to read &quot;.*stuff&quot;
;; you would expect an empty result
;; because spaces:take-all will have
;; removed everything.
;; However, spaces:read actually blocks
;; waiting for a match
(print &apos;-&gt; (spaces:read &quot;.*stuff&quot;))

;; so let&apos;s give it something to match
(spaces:write &quot;andrewsstuff&quot; 1 2 3)

;; note that spaces:read just returned a result
;; neat huh!
;; you can also ask take to remove just the 
;; first matched result.  This can be useful
;; as you can potentially add multiple similar 
;; tuples ... something like this
(spaces:write &quot;andrewsstuff&quot; 2 2 3)
(spaces:write &quot;andrewsstuff&quot; 3 2 3)
(spaces:write &quot;andrewsstuff&quot; 4 2 3)

(print &apos;-&gt; (spaces:read &quot;andrewsstuff&quot;))
;; take one at a time
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
;; try again!
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
;; whoops nothing left - better add another one
(spaces:write &quot;andrewsstuff&quot; 5 2 3)

;; spaces includes a bind operator that allows you
;; to bind symbols against the FIRST result of a query.
;; bind operates similarly to read accept that it 
;; does not return a result.  Instead it accepts
;; symbols in tuple positions and binds the result
;; value to the symbol.  bind looks similar to read
;; where #t&apos;s are replaced with symbols to bind

(spaces:write &quot;andrewsstuff&quot; 6 2 3)(spaces:write &quot;andrewsstuff&quot; 7 2 3)
(print &apos;-&gt; (spaces:read &quot;andrewsstuff&quot; #t 2 #t))
(spaces:bind &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2)
(print var1 var2)
;; bind also has a bind take variant that removes
;; the FIRST matched result just like take
(spaces:bindt &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2)
(print var1 var2)
(spaces:bindt &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2)
(print var1 var2)

;; spaces:wait is the opposite of read
;; it blocks until a particular match
;; is NOT available in the spaces db
(spaces:write &quot;test&quot; 1 2 3)
(print &apos;done-waiting (spaces:wait &quot;test&quot; 1 2 3))
(spaces:delete &quot;test&quot; 1 2 3)


;; finally - and most importantly
;; you can use any process (on any host!)
;; as the host of the spaces db
;; you could use ipc:connect-to-process instead!
(ipc:new-process &quot;my-new-proc&quot; 9876)
(set! *spaces:process* &quot;my-new-proc&quot;)

;; everything works exactly the same as before
(spaces:write &quot;helloworld&quot; 1 2 3)
(print &apos;from-my-new-proc-&gt; (spaces:read &quot;helloworld&quot;))
(spaces:bindt &apos;var1 1 &apos;var2 3)
(print var1 var2)
;; including blocking
(print &apos;from-my-new-proc-&gt; (spaces:read &quot;helloworld&quot;))
(spaces:write &quot;helloworld&quot; 4 &apos;#(1 2 3) &quot;another string&quot; 6)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; a more concrete example

(spaces:regex-string-match #f)

;; first define dls
(define dls (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))
(au:connect-node dls 0 *au:output-node* 0)
(au:update-graph)

;; start an infinite loop
;; spaces:bindt will block until it can match a tuple
;; spaces:bindt also removes the tuple that it matches
;; thus forcing it to block again
(define loop
   (lambda ()      
      (spaces:bindt &quot;/mailbox/andrew/note&quot; &apos;time &apos;pitch &apos;volume &apos;duration)
      (play-note (clock-&gt;samples time) dls pitch volume duration)
      (loop)))

;; start the loop
(loop)

;; add a new note
(spaces:write &quot;/mailbox/andrew/note&quot; (clock) 60 80 20000)

;; try adding three notes at once
(begin (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 60 80 20000)
       (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 63 80 20000)
       (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 67 80 20000))

;; now start a second loop to control the first loop
;; this second loop could happily be in a second process
;; or even a remote host
(define loop2
   (lambda (beat) 
      (spaces:write &quot;/mailbox/andrew/note&quot; 
                    (samples-&gt;clock (*metro* beat))
                    (random 40 80)
                    (random 50 70)
                    3500)
      (callback (*metro* (+ beat (* .5 .5))) &apos;loop2 (+ beat .5))))

(loop2 (*metro* &apos;get-beat 4))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; if we wanted multiple clients all reading the same 
;; spaces db then we could either
;; a) write multiple times (with indexes for example)
;;    for each host so that bindt removed only that
;;    particular clients tuple
;; b) use spaces:wait and spaces:delete as the
;;    modifications below demonstrate. this example will
;;    work for any number of clients connected to the 
;;    same spaces db
(define loop
   (lambda ()      
      (spaces:bind &quot;/mailbox/andrew/note&quot; &apos;time &apos;pitch &apos;volume &apos;duration)
      (play-note (clock-&gt;samples time) dls pitch volume duration)
      (spaces:wait &quot;/mailbox/andrew/note&quot; time pitch volume duration)
      (loop)))

(define loop2
   (lambda (beat) 
      (spaces:delete &quot;/mailbox/andrew/note&quot;)
      (spaces:write &quot;/mailbox/andrew/note&quot; 
                    (samples-&gt;clock (*metro* beat))
                    (random 40 80)
                    (random 50 70)
                    3500)
      (callback (*metro* (+ beat (* .5 .5))) &apos;loop2 (+ beat .5))))
</string>
		</array>
		<key>long</key>
		<array>
			<string>should spaces use regex string matches or simple string matches (default is #f)</string>
		</array>
		<key>related</key>
		<string>ipc:read ipc:write ipc:take ipc:delete ipc:bind ipc:bindt</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(spaces:regex-string-match bool)</string>
	</dict>
	<key>spaces:save</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>filename</key>
			<string>file to write spaces db to</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Impromptu spaces is based on Tuple Spaces
;; Tuple spaces first appeared in Linda 1972
;;
;; Spaces provides a mechanism for shared memory
;; transparently between processes 
;; and even across hosts.
;;
;; Tuples can be of any length and can include
;; numbers, strings and vectors
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; first let&apos;s add some data to spaces
;; we&apos;ll add a 3-tuple of {string,number,number}
;; tuples can be made up of any number of
;; strings, integers, reals and lists
(spaces:write &quot;stuff&quot; 1 55.5)

;; we read it back by matching against tuples in the space
;; 
;; stings match strings
;; numbers match numbers
;; vectors match vectors
;; #t matches anything
;;
;; You must match from the start of a tuple
;; but you do not need to match against the whole tuple
;;
;; for example, you can just match the first element of the tuple
;; read returns a list of matching tuples (a list of lists)
(define result (spaces:read &quot;stuff&quot;))
(print result)

;; if we add a new 4-tuple {string,num,num,vector}
(spaces:write &quot;stuff&quot; 1 66.6 &apos;#(1 2 3))

;; matching against &quot;stuff&quot; will return both tuples
;; even though the tuples are different lengths
(print &apos;-&gt; (spaces:read &quot;stuff&quot;))

;; we could be more explicit with out tuple match
;; by matching against more of the tuple
(print &apos;-&gt; (spaces:read &quot;stuff&quot; 1 55.5))

;; tuples don&apos;t need to start with strings
(spaces:write 55.5 &apos;#(1 2 3) 70)
(print &apos;-&gt; (spaces:read 55.5))

;; let&apos;s try some more matches
(spaces:write &quot;morestuff&quot; 1 77.7 &apos;#(4 6 7))

;; we could return all tuples
;; whose 2nd element is 1
(print &apos;-&gt; (spaces:read #t 1))

;; you can use as many match criteria as you like
;; here we match explicitly against positions 2 and 4
;; #t matches against anything in positions 1 and 3
(print &apos;-&gt; (spaces:read #t 1 #t &apos;#(1 2 3)))


;; by default spaces uses simple direct string matching
;; &quot;string&quot; == &quot;string&quot;
;; however, if efficiency is not a large concern
;; you can also use regular expression matching
;; by setting regex matches to true
;; (spaces:regex-string-match #t)
;; you can set back to #f at any time.
;;
;; then we can match against &quot;morestuff&quot; and &quot;stuff&quot;
(spaces:regex-string-match #t)
(print &apos;-&gt; (spaces:read &quot;^.*stuff$&quot;))

;; numbers can be searched by providing
;; a search predicate &lt; &gt; &lt;= &gt;= &lt;&gt;
;; with a number
;; as the two elements of a list
;; in the tuple position that we want to test
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt;&gt; . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt;= . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt; . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&gt; . 66.6)))

;; we can also match against vectors
(print &apos;-&gt; (spaces:read #t 1 #t &apos;#(4 6 7)))

;; we can also do a type of read that also removes
;; the returned results from spaces
;; we use spaces:take-all for this purpose
(print &apos;-&gt; (spaces:take-all &quot;.*stuff&quot;))

;; if we now try to read &quot;.*stuff&quot;
;; you would expect an empty result
;; because spaces:take-all will have
;; removed everything.
;; However, spaces:read actually blocks
;; waiting for a match
(print &apos;-&gt; (spaces:read &quot;.*stuff&quot;))

;; so let&apos;s give it something to match
(spaces:write &quot;andrewsstuff&quot; 1 2 3)

;; note that spaces:read just returned a result
;; neat huh!
;; you can also ask take to remove just the 
;; first matched result.  This can be useful
;; as you can potentially add multiple similar 
;; tuples ... something like this
(spaces:write &quot;andrewsstuff&quot; 2 2 3)
(spaces:write &quot;andrewsstuff&quot; 3 2 3)
(spaces:write &quot;andrewsstuff&quot; 4 2 3)

(print &apos;-&gt; (spaces:read &quot;andrewsstuff&quot;))
;; take one at a time
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
;; try again!
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
;; whoops nothing left - better add another one
(spaces:write &quot;andrewsstuff&quot; 5 2 3)

;; spaces includes a bind operator that allows you
;; to bind symbols against the FIRST result of a query.
;; bind operates similarly to read accept that it 
;; does not return a result.  Instead it accepts
;; symbols in tuple positions and binds the result
;; value to the symbol.  bind looks similar to read
;; where #t&apos;s are replaced with symbols to bind

(spaces:write &quot;andrewsstuff&quot; 6 2 3)(spaces:write &quot;andrewsstuff&quot; 7 2 3)
(print &apos;-&gt; (spaces:read &quot;andrewsstuff&quot; #t 2 #t))
(spaces:bind &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2)
(print var1 var2)
;; bind also has a bind take variant that removes
;; the FIRST matched result just like take
(spaces:bindt &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2)
(print var1 var2)
(spaces:bindt &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2)
(print var1 var2)

;; spaces:wait is the opposite of read
;; it blocks until a particular match
;; is NOT available in the spaces db
(spaces:write &quot;test&quot; 1 2 3)
(print &apos;done-waiting (spaces:wait &quot;test&quot; 1 2 3))
(spaces:delete &quot;test&quot; 1 2 3)


;; finally - and most importantly
;; you can use any process (on any host!)
;; as the host of the spaces db
;; you could use ipc:connect-to-process instead!
(ipc:new-process &quot;my-new-proc&quot; 9876)
(set! *spaces:process* &quot;my-new-proc&quot;)

;; everything works exactly the same as before
(spaces:write &quot;helloworld&quot; 1 2 3)
(print &apos;from-my-new-proc-&gt; (spaces:read &quot;helloworld&quot;))
(spaces:bindt &apos;var1 1 &apos;var2 3)
(print var1 var2)
;; including blocking
(print &apos;from-my-new-proc-&gt; (spaces:read &quot;helloworld&quot;))
(spaces:write &quot;helloworld&quot; 4 &apos;#(1 2 3) &quot;another string&quot; 6)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; a more concrete example

(spaces:regex-string-match #f)

;; first define dls
(define dls (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))
(au:connect-node dls 0 *au:output-node* 0)
(au:update-graph)

;; start an infinite loop
;; spaces:bindt will block until it can match a tuple
;; spaces:bindt also removes the tuple that it matches
;; thus forcing it to block again
(define loop
   (lambda ()      
      (spaces:bindt &quot;/mailbox/andrew/note&quot; &apos;time &apos;pitch &apos;volume &apos;duration)
      (play-note (clock-&gt;samples time) dls pitch volume duration)
      (loop)))

;; start the loop
(loop)

;; add a new note
(spaces:write &quot;/mailbox/andrew/note&quot; (clock) 60 80 20000)

;; try adding three notes at once
(begin (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 60 80 20000)
       (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 63 80 20000)
       (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 67 80 20000))

;; now start a second loop to control the first loop
;; this second loop could happily be in a second process
;; or even a remote host
(define loop2
   (lambda (beat) 
      (spaces:write &quot;/mailbox/andrew/note&quot; 
                    (samples-&gt;clock (*metro* beat))
                    (random 40 80)
                    (random 50 70)
                    3500)
      (callback (*metro* (+ beat (* .5 .5))) &apos;loop2 (+ beat .5))))

(loop2 (*metro* &apos;get-beat 4))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; if we wanted multiple clients all reading the same 
;; spaces db then we could either
;; a) write multiple times (with indexes for example)
;;    for each host so that bindt removed only that
;;    particular clients tuple
;; b) use spaces:wait and spaces:delete as the
;;    modifications below demonstrate. this example will
;;    work for any number of clients connected to the 
;;    same spaces db
(define loop
   (lambda ()      
      (spaces:bind &quot;/mailbox/andrew/note&quot; &apos;time &apos;pitch &apos;volume &apos;duration)
      (play-note (clock-&gt;samples time) dls pitch volume duration)
      (spaces:wait &quot;/mailbox/andrew/note&quot; time pitch volume duration)
      (loop)))

(define loop2
   (lambda (beat) 
      (spaces:delete &quot;/mailbox/andrew/note&quot;)
      (spaces:write &quot;/mailbox/andrew/note&quot; 
                    (samples-&gt;clock (*metro* beat))
                    (random 40 80)
                    (random 50 70)
                    3500)
      (callback (*metro* (+ beat (* .5 .5))) &apos;loop2 (+ beat .5))))
</string>
		</array>
		<key>long</key>
		<array>
			<string>saves a spaces db to disk. can be reloaded using spaces:load</string>
		</array>
		<key>related</key>
		<string>ipc:read ipc:write ipc:take ipc:delete ipc:bind ipc:bindt</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(spaces:save filename)</string>
	</dict>
	<key>spaces:take</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>tuple-matches</key>
			<string>strings are regular expression matches, numbers match numbers, lists of 2 items match numbers - first list item is &lt; &gt; &lt;= &gt;= &lt;&gt; second list item is a number</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Impromptu spaces is based on Tuple Spaces
;; Tuple spaces first appeared in Linda 1972
;;
;; Spaces provides a mechanism for shared memory
;; transparently between processes 
;; and even across hosts.
;;
;; Tuples can be of any length and can include
;; numbers, strings and vectors
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; first let&apos;s add some data to spaces
;; we&apos;ll add a 3-tuple of {string,number,number}
;; tuples can be made up of any number of
;; strings, integers, reals and lists
(spaces:write &quot;stuff&quot; 1 55.5)

;; we read it back by matching against tuples in the space
;; 
;; stings match strings
;; numbers match numbers
;; vectors match vectors
;; #t matches anything
;;
;; You must match from the start of a tuple
;; but you do not need to match against the whole tuple
;;
;; for example, you can just match the first element of the tuple
;; read returns a list of matching tuples (a list of lists)
(define result (spaces:read &quot;stuff&quot;))
(print result)

;; if we add a new 4-tuple {string,num,num,vector}
(spaces:write &quot;stuff&quot; 1 66.6 &apos;#(1 2 3))

;; matching against &quot;stuff&quot; will return both tuples
;; even though the tuples are different lengths
(print &apos;-&gt; (spaces:read &quot;stuff&quot;))

;; we could be more explicit with out tuple match
;; by matching against more of the tuple
(print &apos;-&gt; (spaces:read &quot;stuff&quot; 1 55.5))

;; tuples don&apos;t need to start with strings
(spaces:write 55.5 &apos;#(1 2 3) 70)
(print &apos;-&gt; (spaces:read 55.5))

;; let&apos;s try some more matches
(spaces:write &quot;morestuff&quot; 1 77.7 &apos;#(4 6 7))

;; we could return all tuples
;; whose 2nd element is 1
(print &apos;-&gt; (spaces:read #t 1))

;; you can use as many match criteria as you like
;; here we match explicitly against positions 2 and 4
;; #t matches against anything in positions 1 and 3
(print &apos;-&gt; (spaces:read #t 1 #t &apos;#(1 2 3)))


;; by default spaces uses simple direct string matching
;; &quot;string&quot; == &quot;string&quot;
;; however, if efficiency is not a large concern
;; you can also use regular expression matching
;; by setting regex matches to true
;; (spaces:regex-string-match #t)
;; you can set back to #f at any time.
;;
;; then we can match against &quot;morestuff&quot; and &quot;stuff&quot;
(spaces:regex-string-match #t)
(print &apos;-&gt; (spaces:read &quot;^.*stuff$&quot;))

;; numbers can be searched by providing
;; a search predicate &lt; &gt; &lt;= &gt;= &lt;&gt;
;; with a number
;; as the two elements of a list
;; in the tuple position that we want to test
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt;&gt; . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt;= . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt; . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&gt; . 66.6)))

;; we can also match against vectors
(print &apos;-&gt; (spaces:read #t 1 #t &apos;#(4 6 7)))

;; we can also do a type of read that also removes
;; the returned results from spaces
;; we use spaces:take-all for this purpose
(print &apos;-&gt; (spaces:take-all &quot;.*stuff&quot;))

;; if we now try to read &quot;.*stuff&quot;
;; you would expect an empty result
;; because spaces:take-all will have
;; removed everything.
;; However, spaces:read actually blocks
;; waiting for a match
(print &apos;-&gt; (spaces:read &quot;.*stuff&quot;))

;; so let&apos;s give it something to match
(spaces:write &quot;andrewsstuff&quot; 1 2 3)

;; note that spaces:read just returned a result
;; neat huh!
;; you can also ask take to remove just the 
;; first matched result.  This can be useful
;; as you can potentially add multiple similar 
;; tuples ... something like this
(spaces:write &quot;andrewsstuff&quot; 2 2 3)
(spaces:write &quot;andrewsstuff&quot; 3 2 3)
(spaces:write &quot;andrewsstuff&quot; 4 2 3)

(print &apos;-&gt; (spaces:read &quot;andrewsstuff&quot;))
;; take one at a time
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
;; try again!
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
;; whoops nothing left - better add another one
(spaces:write &quot;andrewsstuff&quot; 5 2 3)

;; read also accepts symbols in tuple positions and binds 
;; the result value of the tuple position of the symbol
;; to the symbol in the current environement

(spaces:write &quot;andrewsstuff&quot; 6 2 3)(spaces:write &quot;andrewsstuff&quot; 7 2 3)
(print &apos;-&gt; (spaces:read &quot;andrewsstuff&quot; #t 2 #t))
(print &apos;-&gt; (spaces:read &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2))
(print var1 var2)
;; take also allows you to bind symbols.
;; the FIRST matched result just like take
(spaces:take &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2)
(print var1 var2)
(spaces:take &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2)
(print var1 var2)

;; spaces:wait is the opposite of read
;; it blocks until a particular match
;; is NOT available in the spaces db
(spaces:write &quot;test&quot; 1 2 3)
(print &apos;done-waiting (spaces:wait &quot;test&quot; 1 2 3))
(spaces:delete &quot;test&quot; 1 2 3)


;; finally - and most importantly
;; you can use any process (on any host!)
;; as the host of the spaces db
;; you could use ipc:connect-to-process instead!
(ipc:new-process &quot;my-new-proc&quot; 9876)
(set! *spaces:process* &quot;my-new-proc&quot;)

;; everything works exactly the same as before
(spaces:write &quot;helloworld&quot; 1 2 3)
(print &apos;from-my-new-proc-&gt; (spaces:read &quot;helloworld&quot;))
(spaces:take &apos;var1 1 &apos;var2 3)
(print var1 var2)
;; including blocking
(print &apos;from-my-new-proc-&gt; (spaces:read &quot;helloworld&quot;))
(spaces:write &quot;helloworld&quot; 4 &apos;#(1 2 3) &quot;another string&quot; 6)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; a more concrete example

(spaces:regex-string-match #f)

;; first define dls
(define dls (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))
(au:connect-node dls 0 *au:output-node* 0)
(au:update-graph)

;; start an infinite loop
;; spaces:take will block until it can match a tuple
;; spaces:take also removes the tuple that it matches
;; thus forcing it to block again
(define loop
   (lambda ()      
      (spaces:take &quot;/mailbox/andrew/note&quot; &apos;time &apos;pitch &apos;volume &apos;duration)
      (play-note (clock-&gt;samples time) dls pitch volume duration)
      (loop)))

;; start the loop
(loop)

;; add a new note
(spaces:write &quot;/mailbox/andrew/note&quot; (clock) 60 80 20000)

;; try adding three notes at once
(begin (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 60 80 20000)
       (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 63 80 20000)
       (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 67 80 20000))

;; now start a second loop to control the first loop
;; this second loop could happily be in a second process
;; or even a remote host
(define loop2
   (lambda (beat) 
      (spaces:write &quot;/mailbox/andrew/note&quot; 
                    (samples-&gt;clock (*metro* beat))
                    (random 40 80)
                    (random 50 70)
                    3500)
      (callback (*metro* (+ beat (* .5 .5))) &apos;loop2 (+ beat .5))))

(loop2 (*metro* &apos;get-beat 4))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; if we wanted multiple clients all reading the same 
;; spaces db then we could either
;; a) write multiple times (with indexes for example)
;;    for each host so that read removed only that
;;    particular clients tuple
;; b) use spaces:wait and spaces:delete as the
;;    modifications below demonstrate. this example will
;;    work for any number of clients connected to the 
;;    same spaces db
(define loop
   (lambda ()      
      (spaces:read &quot;/mailbox/andrew/note&quot; &apos;time &apos;pitch &apos;volume &apos;duration)
      (play-note (clock-&gt;samples time) dls pitch volume duration)
      (spaces:wait &quot;/mailbox/andrew/note&quot; time pitch volume duration)
      (loop)))

(define loop2
   (lambda (beat) 
      (spaces:delete &quot;/mailbox/andrew/note&quot;)
      (spaces:write &quot;/mailbox/andrew/note&quot; 
                    (samples-&gt;clock (*metro* beat))
                    (random 40 80)
                    (random 50 70)
                    3500)
      (callback (*metro* (+ beat (* .5 .5))) &apos;loop2 (+ beat .5))))</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns a vector containing a single vector that matches tuple-matches.  if muliple tuples match the criteria only the first is removed and returned.</string>
		</array>
		<key>related</key>
		<string>ipc:read ipc:write ipc:take ipc:delete ipc:bind ipc:bindt</string>
		<key>returns</key>
		<string>a vector containing a single vector</string>
		<key>short</key>
		<string>(spaces:take . tuple-matches)</string>
	</dict>
	<key>spaces:take-all</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>tuple-matches</key>
			<string>strings are regular expression matches, numbers match numbers, lists of 2 items match numbers - first list item is &lt; &gt; &lt;= &gt;= &lt;&gt; second list item is a number</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Impromptu spaces is based on Tuple Spaces
;; Tuple spaces first appeared in Linda 1972
;;
;; Spaces provides a mechanism for shared memory
;; transparently between processes 
;; and even across hosts.
;;
;; Tuples can be of any length and can include
;; numbers, strings and vectors
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; first let&apos;s add some data to spaces
;; we&apos;ll add a 3-tuple of {string,number,number}
;; tuples can be made up of any number of
;; strings, integers, reals and lists
(spaces:write &quot;stuff&quot; 1 55.5)

;; we read it back by matching against tuples in the space
;; 
;; stings match strings
;; numbers match numbers
;; vectors match vectors
;; #t matches anything
;;
;; You must match from the start of a tuple
;; but you do not need to match against the whole tuple
;;
;; for example, you can just match the first element of the tuple
;; read returns a list of matching tuples (a list of lists)
(define result (spaces:read &quot;stuff&quot;))
(print result)

;; if we add a new 4-tuple {string,num,num,vector}
(spaces:write &quot;stuff&quot; 1 66.6 &apos;#(1 2 3))

;; matching against &quot;stuff&quot; will return both tuples
;; even though the tuples are different lengths
(print &apos;-&gt; (spaces:read &quot;stuff&quot;))

;; we could be more explicit with out tuple match
;; by matching against more of the tuple
(print &apos;-&gt; (spaces:read &quot;stuff&quot; 1 55.5))

;; tuples don&apos;t need to start with strings
(spaces:write 55.5 &apos;#(1 2 3) 70)
(print &apos;-&gt; (spaces:read 55.5))

;; let&apos;s try some more matches
(spaces:write &quot;morestuff&quot; 1 77.7 &apos;#(4 6 7))

;; we could return all tuples
;; whose 2nd element is 1
(print &apos;-&gt; (spaces:read #t 1))

;; you can use as many match criteria as you like
;; here we match explicitly against positions 2 and 4
;; #t matches against anything in positions 1 and 3
(print &apos;-&gt; (spaces:read #t 1 #t &apos;#(1 2 3)))


;; by default spaces uses simple direct string matching
;; &quot;string&quot; == &quot;string&quot;
;; however, if efficiency is not a large concern
;; you can also use regular expression matching
;; by setting regex matches to true
;; (spaces:regex-string-match #t)
;; you can set back to #f at any time.
;;
;; then we can match against &quot;morestuff&quot; and &quot;stuff&quot;
(spaces:regex-string-match #t)
(print &apos;-&gt; (spaces:read &quot;^.*stuff$&quot;))

;; numbers can be searched by providing
;; a search predicate &lt; &gt; &lt;= &gt;= &lt;&gt;
;; with a number
;; as the two elements of a list
;; in the tuple position that we want to test
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt;&gt; . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt;= . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt; . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&gt; . 66.6)))

;; we can also match against vectors
(print &apos;-&gt; (spaces:read #t 1 #t &apos;#(4 6 7)))

;; we can also do a type of read that also removes
;; the returned results from spaces
;; we use spaces:take-all for this purpose
(print &apos;-&gt; (spaces:take-all &quot;.*stuff&quot;))

;; if we now try to read &quot;.*stuff&quot;
;; you would expect an empty result
;; because spaces:take-all will have
;; removed everything.
;; However, spaces:read actually blocks
;; waiting for a match
(print &apos;-&gt; (spaces:read &quot;.*stuff&quot;))

;; so let&apos;s give it something to match
(spaces:write &quot;andrewsstuff&quot; 1 2 3)

;; note that spaces:read just returned a result
;; neat huh!
;; you can also ask take to remove just the 
;; first matched result.  This can be useful
;; as you can potentially add multiple similar 
;; tuples ... something like this
(spaces:write &quot;andrewsstuff&quot; 2 2 3)
(spaces:write &quot;andrewsstuff&quot; 3 2 3)
(spaces:write &quot;andrewsstuff&quot; 4 2 3)

(print &apos;-&gt; (spaces:read &quot;andrewsstuff&quot;))
;; take one at a time
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
;; try again!
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
;; whoops nothing left - better add another one
(spaces:write &quot;andrewsstuff&quot; 5 2 3)

;; read also accepts symbols in tuple positions and binds 
;; the result value of the tuple position of the symbol
;; to the symbol in the current environement

(spaces:write &quot;andrewsstuff&quot; 6 2 3)(spaces:write &quot;andrewsstuff&quot; 7 2 3)
(print &apos;-&gt; (spaces:read &quot;andrewsstuff&quot; #t 2 #t))
(print &apos;-&gt; (spaces:read &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2))
(print var1 var2)
;; take also allows you to bind symbols.
;; the FIRST matched result just like take
(spaces:take &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2)
(print var1 var2)
(spaces:take &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2)
(print var1 var2)

;; spaces:wait is the opposite of read
;; it blocks until a particular match
;; is NOT available in the spaces db
(spaces:write &quot;test&quot; 1 2 3)
(print &apos;done-waiting (spaces:wait &quot;test&quot; 1 2 3))
(spaces:delete &quot;test&quot; 1 2 3)


;; finally - and most importantly
;; you can use any process (on any host!)
;; as the host of the spaces db
;; you could use ipc:connect-to-process instead!
(ipc:new-process &quot;my-new-proc&quot; 9876)
(set! *spaces:process* &quot;my-new-proc&quot;)

;; everything works exactly the same as before
(spaces:write &quot;helloworld&quot; 1 2 3)
(print &apos;from-my-new-proc-&gt; (spaces:read &quot;helloworld&quot;))
(spaces:take &apos;var1 1 &apos;var2 3)
(print var1 var2)
;; including blocking
(print &apos;from-my-new-proc-&gt; (spaces:read &quot;helloworld&quot;))
(spaces:write &quot;helloworld&quot; 4 &apos;#(1 2 3) &quot;another string&quot; 6)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; a more concrete example

(spaces:regex-string-match #f)

;; first define dls
(define dls (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))
(au:connect-node dls 0 *au:output-node* 0)
(au:update-graph)

;; start an infinite loop
;; spaces:take will block until it can match a tuple
;; spaces:take also removes the tuple that it matches
;; thus forcing it to block again
(define loop
   (lambda ()      
      (spaces:take &quot;/mailbox/andrew/note&quot; &apos;time &apos;pitch &apos;volume &apos;duration)
      (play-note (clock-&gt;samples time) dls pitch volume duration)
      (loop)))

;; start the loop
(loop)

;; add a new note
(spaces:write &quot;/mailbox/andrew/note&quot; (clock) 60 80 20000)

;; try adding three notes at once
(begin (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 60 80 20000)
       (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 63 80 20000)
       (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 67 80 20000))

;; now start a second loop to control the first loop
;; this second loop could happily be in a second process
;; or even a remote host
(define loop2
   (lambda (beat) 
      (spaces:write &quot;/mailbox/andrew/note&quot; 
                    (samples-&gt;clock (*metro* beat))
                    (random 40 80)
                    (random 50 70)
                    3500)
      (callback (*metro* (+ beat (* .5 .5))) &apos;loop2 (+ beat .5))))

(loop2 (*metro* &apos;get-beat 4))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; if we wanted multiple clients all reading the same 
;; spaces db then we could either
;; a) write multiple times (with indexes for example)
;;    for each host so that read removed only that
;;    particular clients tuple
;; b) use spaces:wait and spaces:delete as the
;;    modifications below demonstrate. this example will
;;    work for any number of clients connected to the 
;;    same spaces db
(define loop
   (lambda ()      
      (spaces:read &quot;/mailbox/andrew/note&quot; &apos;time &apos;pitch &apos;volume &apos;duration)
      (play-note (clock-&gt;samples time) dls pitch volume duration)
      (spaces:wait &quot;/mailbox/andrew/note&quot; time pitch volume duration)
      (loop)))

(define loop2
   (lambda (beat) 
      (spaces:delete &quot;/mailbox/andrew/note&quot;)
      (spaces:write &quot;/mailbox/andrew/note&quot; 
                    (samples-&gt;clock (*metro* beat))
                    (random 40 80)
                    (random 50 70)
                    3500)
      (callback (*metro* (+ beat (* .5 .5))) &apos;loop2 (+ beat .5))))</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns a vector of vectors that match tuple-matches. removes tuples that match from the spaces db</string>
		</array>
		<key>related</key>
		<string>ipc:read ipc:write ipc:take ipc:delete ipc:bind ipc:bindt</string>
		<key>returns</key>
		<string>a vector of vectors</string>
		<key>short</key>
		<string>(spaces:take-all . tuple-matches)</string>
	</dict>
	<key>spaces:wait</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>tuple-matches</key>
			<string>strings are regular expression matches, numbers match numbers, lists of 2 items match numbers - first list item is &lt; &gt; &lt;= &gt;= &lt;&gt; second list item is a number</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Impromptu spaces is based on Tuple Spaces
;; Tuple spaces first appeared in Linda 1972
;;
;; Spaces provides a mechanism for shared memory
;; transparently between processes 
;; and even across hosts.
;;
;; Tuples can be of any length and can include
;; numbers, strings and vectors
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; first let&apos;s add some data to spaces
;; we&apos;ll add a 3-tuple of {string,number,number}
;; tuples can be made up of any number of
;; strings, integers, reals and lists
(spaces:write &quot;stuff&quot; 1 55.5)

;; we read it back by matching against tuples in the space
;; 
;; stings match strings
;; numbers match numbers
;; vectors match vectors
;; #t matches anything
;;
;; You must match from the start of a tuple
;; but you do not need to match against the whole tuple
;;
;; for example, you can just match the first element of the tuple
;; read returns a list of matching tuples (a list of lists)
(define result (spaces:read &quot;stuff&quot;))
(print result)

;; if we add a new 4-tuple {string,num,num,vector}
(spaces:write &quot;stuff&quot; 1 66.6 &apos;#(1 2 3))

;; matching against &quot;stuff&quot; will return both tuples
;; even though the tuples are different lengths
(print &apos;-&gt; (spaces:read &quot;stuff&quot;))

;; we could be more explicit with out tuple match
;; by matching against more of the tuple
(print &apos;-&gt; (spaces:read &quot;stuff&quot; 1 55.5))

;; tuples don&apos;t need to start with strings
(spaces:write 55.5 &apos;#(1 2 3) 70)
(print &apos;-&gt; (spaces:read 55.5))

;; let&apos;s try some more matches
(spaces:write &quot;morestuff&quot; 1 77.7 &apos;#(4 6 7))

;; we could return all tuples
;; whose 2nd element is 1
(print &apos;-&gt; (spaces:read #t 1))

;; you can use as many match criteria as you like
;; here we match explicitly against positions 2 and 4
;; #t matches against anything in positions 1 and 3
(print &apos;-&gt; (spaces:read #t 1 #t &apos;#(1 2 3)))


;; by default spaces uses simple direct string matching
;; &quot;string&quot; == &quot;string&quot;
;; however, if efficiency is not a large concern
;; you can also use regular expression matching
;; by setting regex matches to true
;; (spaces:regex-string-match #t)
;; you can set back to #f at any time.
;;
;; then we can match against &quot;morestuff&quot; and &quot;stuff&quot;
(spaces:regex-string-match #t)
(print &apos;-&gt; (spaces:read &quot;^.*stuff$&quot;))

;; numbers can be searched by providing
;; a search predicate &lt; &gt; &lt;= &gt;= &lt;&gt;
;; with a number
;; as the two elements of a list
;; in the tuple position that we want to test
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt;&gt; . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt;= . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt; . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&gt; . 66.6)))

;; we can also match against vectors
(print &apos;-&gt; (spaces:read #t 1 #t &apos;#(4 6 7)))

;; we can also do a type of read that also removes
;; the returned results from spaces
;; we use spaces:take-all for this purpose
(print &apos;-&gt; (spaces:take-all &quot;.*stuff&quot;))

;; if we now try to read &quot;.*stuff&quot;
;; you would expect an empty result
;; because spaces:take-all will have
;; removed everything.
;; However, spaces:read actually blocks
;; waiting for a match
(print &apos;-&gt; (spaces:read &quot;.*stuff&quot;))

;; so let&apos;s give it something to match
(spaces:write &quot;andrewsstuff&quot; 1 2 3)

;; note that spaces:read just returned a result
;; neat huh!
;; you can also ask take to remove just the 
;; first matched result.  This can be useful
;; as you can potentially add multiple similar 
;; tuples ... something like this
(spaces:write &quot;andrewsstuff&quot; 2 2 3)
(spaces:write &quot;andrewsstuff&quot; 3 2 3)
(spaces:write &quot;andrewsstuff&quot; 4 2 3)

(print &apos;-&gt; (spaces:read &quot;andrewsstuff&quot;))
;; take one at a time
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
;; try again!
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
;; whoops nothing left - better add another one
(spaces:write &quot;andrewsstuff&quot; 5 2 3)

;; read also accepts symbols in tuple positions and binds 
;; the result value of the tuple position of the symbol
;; to the symbol in the current environement

(spaces:write &quot;andrewsstuff&quot; 6 2 3)(spaces:write &quot;andrewsstuff&quot; 7 2 3)
(print &apos;-&gt; (spaces:read &quot;andrewsstuff&quot; #t 2 #t))
(print &apos;-&gt; (spaces:read &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2))
(print var1 var2)
;; take also allows you to bind symbols.
;; the FIRST matched result just like take
(spaces:take &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2)
(print var1 var2)
(spaces:take &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2)
(print var1 var2)

;; spaces:wait is the opposite of read
;; it blocks until a particular match
;; is NOT available in the spaces db
(spaces:write &quot;test&quot; 1 2 3)
(print &apos;done-waiting (spaces:wait &quot;test&quot; 1 2 3))
(spaces:delete &quot;test&quot; 1 2 3)


;; finally - and most importantly
;; you can use any process (on any host!)
;; as the host of the spaces db
;; you could use ipc:connect-to-process instead!
(ipc:new-process &quot;my-new-proc&quot; 9876)
(set! *spaces:process* &quot;my-new-proc&quot;)

;; everything works exactly the same as before
(spaces:write &quot;helloworld&quot; 1 2 3)
(print &apos;from-my-new-proc-&gt; (spaces:read &quot;helloworld&quot;))
(spaces:take &apos;var1 1 &apos;var2 3)
(print var1 var2)
;; including blocking
(print &apos;from-my-new-proc-&gt; (spaces:read &quot;helloworld&quot;))
(spaces:write &quot;helloworld&quot; 4 &apos;#(1 2 3) &quot;another string&quot; 6)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; a more concrete example

(spaces:regex-string-match #f)

;; first define dls
(define dls (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))
(au:connect-node dls 0 *au:output-node* 0)
(au:update-graph)

;; start an infinite loop
;; spaces:take will block until it can match a tuple
;; spaces:take also removes the tuple that it matches
;; thus forcing it to block again
(define loop
   (lambda ()      
      (spaces:take &quot;/mailbox/andrew/note&quot; &apos;time &apos;pitch &apos;volume &apos;duration)
      (play-note (clock-&gt;samples time) dls pitch volume duration)
      (loop)))

;; start the loop
(loop)

;; add a new note
(spaces:write &quot;/mailbox/andrew/note&quot; (clock) 60 80 20000)

;; try adding three notes at once
(begin (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 60 80 20000)
       (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 63 80 20000)
       (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 67 80 20000))

;; now start a second loop to control the first loop
;; this second loop could happily be in a second process
;; or even a remote host
(define loop2
   (lambda (beat) 
      (spaces:write &quot;/mailbox/andrew/note&quot; 
                    (samples-&gt;clock (*metro* beat))
                    (random 40 80)
                    (random 50 70)
                    3500)
      (callback (*metro* (+ beat (* .5 .5))) &apos;loop2 (+ beat .5))))

(loop2 (*metro* &apos;get-beat 4))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; if we wanted multiple clients all reading the same 
;; spaces db then we could either
;; a) write multiple times (with indexes for example)
;;    for each host so that read removed only that
;;    particular clients tuple
;; b) use spaces:wait and spaces:delete as the
;;    modifications below demonstrate. this example will
;;    work for any number of clients connected to the 
;;    same spaces db
(define loop
   (lambda ()      
      (spaces:read &quot;/mailbox/andrew/note&quot; &apos;time &apos;pitch &apos;volume &apos;duration)
      (play-note (clock-&gt;samples time) dls pitch volume duration)
      (spaces:wait &quot;/mailbox/andrew/note&quot; time pitch volume duration)
      (loop)))

(define loop2
   (lambda (beat) 
      (spaces:delete &quot;/mailbox/andrew/note&quot;)
      (spaces:write &quot;/mailbox/andrew/note&quot; 
                    (samples-&gt;clock (*metro* beat))
                    (random 40 80)
                    (random 50 70)
                    3500)
      (callback (*metro* (+ beat (* .5 .5))) &apos;loop2 (+ beat .5))))</string>
		</array>
		<key>long</key>
		<array>
			<string>Blocks until the tuple-matches do NOT exist in the db  (opposite of spaces:read)</string>
		</array>
		<key>related</key>
		<string>ipc:read ipc:write ipc:take ipc:delete ipc:bind ipc:bindt</string>
		<key>returns</key>
		<string>an empty vector</string>
		<key>short</key>
		<string>(spaces:wait . tuple-matches)</string>
	</dict>
	<key>spaces:write</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>tuple</key>
			<string>any number of strings, numbers and vectors</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Impromptu spaces is based on Tuple Spaces
;; Tuple spaces first appeared in Linda 1972
;;
;; Spaces provides a mechanism for shared memory
;; transparently between processes 
;; and even across hosts.
;;
;; Tuples can be of any length and can include
;; numbers, strings and vectors
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; first let&apos;s add some data to spaces
;; we&apos;ll add a 3-tuple of {string,number,number}
;; tuples can be made up of any number of
;; strings, integers, reals and lists
(spaces:write &quot;stuff&quot; 1 55.5)

;; we read it back by matching against tuples in the space
;; 
;; stings match strings
;; numbers match numbers
;; vectors match vectors
;; #t matches anything
;;
;; You must match from the start of a tuple
;; but you do not need to match against the whole tuple
;;
;; for example, you can just match the first element of the tuple
;; read returns a list of matching tuples (a list of lists)
(define result (spaces:read &quot;stuff&quot;))
(print result)

;; if we add a new 4-tuple {string,num,num,vector}
(spaces:write &quot;stuff&quot; 1 66.6 &apos;#(1 2 3))

;; matching against &quot;stuff&quot; will return both tuples
;; even though the tuples are different lengths
(print &apos;-&gt; (spaces:read &quot;stuff&quot;))

;; we could be more explicit with out tuple match
;; by matching against more of the tuple
(print &apos;-&gt; (spaces:read &quot;stuff&quot; 1 55.5))

;; tuples don&apos;t need to start with strings
(spaces:write 55.5 &apos;#(1 2 3) 70)
(print &apos;-&gt; (spaces:read 55.5))

;; let&apos;s try some more matches
(spaces:write &quot;morestuff&quot; 1 77.7 &apos;#(4 6 7))

;; we could return all tuples
;; whose 2nd element is 1
(print &apos;-&gt; (spaces:read #t 1))

;; you can use as many match criteria as you like
;; here we match explicitly against positions 2 and 4
;; #t matches against anything in positions 1 and 3
(print &apos;-&gt; (spaces:read #t 1 #t &apos;#(1 2 3)))


;; by default spaces uses simple direct string matching
;; &quot;string&quot; == &quot;string&quot;
;; however, if efficiency is not a large concern
;; you can also use regular expression matching
;; by setting regex matches to true
;; (spaces:regex-string-match #t)
;; you can set back to #f at any time.
;;
;; then we can match against &quot;morestuff&quot; and &quot;stuff&quot;
(spaces:regex-string-match #t)
(print &apos;-&gt; (spaces:read &quot;^.*stuff$&quot;))

;; numbers can be searched by providing
;; a search predicate &lt; &gt; &lt;= &gt;= &lt;&gt;
;; with a number
;; as the two elements of a list
;; in the tuple position that we want to test
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt;&gt; . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt;= . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&lt; . 66.6)))
(print &apos;-&gt; (spaces:read #t #t &apos;(&gt; . 66.6)))

;; we can also match against vectors
(print &apos;-&gt; (spaces:read #t 1 #t &apos;#(4 6 7)))

;; we can also do a type of read that also removes
;; the returned results from spaces
;; we use spaces:take-all for this purpose
(print &apos;-&gt; (spaces:take-all &quot;.*stuff&quot;))

;; if we now try to read &quot;.*stuff&quot;
;; you would expect an empty result
;; because spaces:take-all will have
;; removed everything.
;; However, spaces:read actually blocks
;; waiting for a match
(print &apos;-&gt; (spaces:read &quot;.*stuff&quot;))

;; so let&apos;s give it something to match
(spaces:write &quot;andrewsstuff&quot; 1 2 3)

;; note that spaces:read just returned a result
;; neat huh!
;; you can also ask take to remove just the 
;; first matched result.  This can be useful
;; as you can potentially add multiple similar 
;; tuples ... something like this
(spaces:write &quot;andrewsstuff&quot; 2 2 3)
(spaces:write &quot;andrewsstuff&quot; 3 2 3)
(spaces:write &quot;andrewsstuff&quot; 4 2 3)

(print &apos;-&gt; (spaces:read &quot;andrewsstuff&quot;))
;; take one at a time
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
;; try again!
(print &apos;-&gt; (spaces:take &quot;andrewsstuff&quot;))
;; whoops nothing left - better add another one
(spaces:write &quot;andrewsstuff&quot; 5 2 3)

;; spaces includes a bind operator that allows you
;; to bind symbols against the FIRST result of a query.
;; bind operates similarly to read accept that it 
;; does not return a result.  Instead it accepts
;; symbols in tuple positions and binds the result
;; value to the symbol.  bind looks similar to read
;; where #t&apos;s are replaced with symbols to bind

(spaces:write &quot;andrewsstuff&quot; 6 2 3)(spaces:write &quot;andrewsstuff&quot; 7 2 3)
(print &apos;-&gt; (spaces:read &quot;andrewsstuff&quot; #t 2 #t))
(spaces:bind &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2)
(print var1 var2)
;; bind also has a bind take variant that removes
;; the FIRST matched result just like take
(spaces:bindt &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2)
(print var1 var2)
(spaces:bindt &quot;andrewsstuff&quot; &apos;var1 2 &apos;var2)
(print var1 var2)

;; spaces:wait is the opposite of read
;; it blocks until a particular match
;; is NOT available in the spaces db
(spaces:write &quot;test&quot; 1 2 3)
(print &apos;done-waiting (spaces:wait &quot;test&quot; 1 2 3))
(spaces:delete &quot;test&quot; 1 2 3)


;; finally - and most importantly
;; you can use any process (on any host!)
;; as the host of the spaces db
;; you could use ipc:connect-to-process instead!
(ipc:new-process &quot;my-new-proc&quot; 9876)
(set! *spaces:process* &quot;my-new-proc&quot;)

;; everything works exactly the same as before
(spaces:write &quot;helloworld&quot; 1 2 3)
(print &apos;from-my-new-proc-&gt; (spaces:read &quot;helloworld&quot;))
(spaces:bindt &apos;var1 1 &apos;var2 3)
(print var1 var2)
;; including blocking
(print &apos;from-my-new-proc-&gt; (spaces:read &quot;helloworld&quot;))
(spaces:write &quot;helloworld&quot; 4 &apos;#(1 2 3) &quot;another string&quot; 6)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; a more concrete example

(spaces:regex-string-match #f)

;; first define dls
(define dls (au:make-node &quot;aumu&quot; &quot;dls &quot; &quot;appl&quot;))
(au:connect-node dls 0 *au:output-node* 0)
(au:update-graph)

;; start an infinite loop
;; spaces:bindt will block until it can match a tuple
;; spaces:bindt also removes the tuple that it matches
;; thus forcing it to block again
(define loop
   (lambda ()      
      (spaces:bindt &quot;/mailbox/andrew/note&quot; &apos;time &apos;pitch &apos;volume &apos;duration)
      (play-note (clock-&gt;samples time) dls pitch volume duration)
      (loop)))

;; start the loop
(loop)

;; add a new note
(spaces:write &quot;/mailbox/andrew/note&quot; (clock) 60 80 20000)

;; try adding three notes at once
(begin (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 60 80 20000)
       (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 63 80 20000)
       (spaces:write &quot;/mailbox/andrew/note&quot; (clock) 67 80 20000))

;; now start a second loop to control the first loop
;; this second loop could happily be in a second process
;; or even a remote host
(define loop2
   (lambda (beat) 
      (spaces:write &quot;/mailbox/andrew/note&quot; 
                    (samples-&gt;clock (*metro* beat))
                    (random 40 80)
                    (random 50 70)
                    3500)
      (callback (*metro* (+ beat (* .5 .5))) &apos;loop2 (+ beat .5))))

(loop2 (*metro* &apos;get-beat 4))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; if we wanted multiple clients all reading the same 
;; spaces db then we could either
;; a) write multiple times (with indexes for example)
;;    for each host so that bindt removed only that
;;    particular clients tuple
;; b) use spaces:wait and spaces:delete as the
;;    modifications below demonstrate. this example will
;;    work for any number of clients connected to the 
;;    same spaces db
(define loop
   (lambda ()      
      (spaces:bind &quot;/mailbox/andrew/note&quot; &apos;time &apos;pitch &apos;volume &apos;duration)
      (play-note (clock-&gt;samples time) dls pitch volume duration)
      (spaces:wait &quot;/mailbox/andrew/note&quot; time pitch volume duration)
      (loop)))

(define loop2
   (lambda (beat) 
      (spaces:delete &quot;/mailbox/andrew/note&quot;)
      (spaces:write &quot;/mailbox/andrew/note&quot; 
                    (samples-&gt;clock (*metro* beat))
                    (random 40 80)
                    (random 50 70)
                    3500)
      (callback (*metro* (+ beat (* .5 .5))) &apos;loop2 (+ beat .5))))
</string>
		</array>
		<key>long</key>
		<array>
			<string>writes an n-tuple made up of any number of strings, vectors and numbers</string>
		</array>
		<key>related</key>
		<string>ipc:read ipc:write ipc:take ipc:delete ipc:bind ipc:bindt</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(spaces:write . tuple)</string>
	</dict>
	<key>sqrt</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>num</key>
			<string>number</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Return the square root of num</string>
		</array>
		<key>returns</key>
		<string>number</string>
		<key>short</key>
		<string>(sqrt num)</string>
	</dict>
	<key>start-note</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>an aumu or augn</string>
			<key>channel</key>
			<string>optional midi channel defaults to 0</string>
			<key>pitch</key>
			<string>midi pitch number</string>
			<key>time</key>
			<string>in samples</string>
			<key>volume</key>
			<string>midi volume number</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Send a note-on event to au of pitch and volume. pitch values outside 0-127 are ignored.  use au:midi-out if for some reason you want to send pitch values outside 0-127</string>
		</array>
		<key>related</key>
		<string>stop-sound au:midi-out</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(start-note time au pitch volume [channel])</string>
	</dict>
	<key>start-sound</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>an aumu or augn</string>
			<key>pitch</key>
			<string>a real number value where decimal numbers are in cents (i.e. 60.25 is C+25cents)</string>
			<key>time</key>
			<string>in samples</string>
			<key>volume</key>
			<string>real number volume</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Sends a start sound event to an audiounit supporting the extended AU note api. pitch values are real numbers where decimals represent cents (i.e. 60.25 is a middle C+25 cents). volume is also a real number value.  NOTE: this only works with audiounits supporting the extended AudioUnit Note API (at the present the only AU I know that supports this is apples DLS). If your AU does not support this use the standard start-note function instead.</string>
		</array>
		<key>related</key>
		<string>stop-sound au:midi-out</string>
		<key>returns</key>
		<string>a unique integer note-index which must be passed to stop-sound to stop the sound</string>
		<key>short</key>
		<string>(start-sound time au pitch volume)</string>
	</dict>
	<key>stop-note</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>an aumu or augn</string>
			<key>channel</key>
			<string>optional channel defaults to 0</string>
			<key>pitch</key>
			<string>midi pitch number</string>
			<key>time</key>
			<string>time in samples</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>send note-off to au. pitch values outside of 0-127 are ignored.</string>
		</array>
		<key>related</key>
		<string>start-note stop-sound au:midi-out</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(stop-note time au pitch [channel])</string>
	</dict>
	<key>stop-sound</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>au</key>
			<string>an aumu or augn</string>
			<key>note-index</key>
			<string>unique integer note index</string>
			<key>pitch</key>
			<string>midi pitch number</string>
			<key>time</key>
			<string>time in samples</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>stops the sound associated with note-index.   NOTE: this only works with audiounits supporting the extended AudioUnit Note API (at the present the only AU I know that supports this is apples DLS). If your AU does not support this use the standard stop-note function instead.</string>
		</array>
		<key>related</key>
		<string>start-sound start-note stop-sound start-sound au:midi-out</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(stop-sound time au pitch note-index)</string>
	</dict>
	<key>string</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>chars</key>
			<string>characters</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns a string made up of chars</string>
		</array>
		<key>returns</key>
		<string>string</string>
		<key>short</key>
		<string>(string . chars)</string>
	</dict>
	<key>string-&gt;anyatom</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>predicate</key>
			<string>predicate function</string>
			<key>str</key>
			<string>string</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>No Description For string-&gt;anyatom</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(string-&gt;anyatom str predicate)</string>
	</dict>
	<key>string-&gt;atom</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>str</key>
			<string>string</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>No Description For string-&gt;atom</string>
		</array>
		<key>returns</key>
		<string>symbol</string>
		<key>short</key>
		<string>(string-&gt;atom string)</string>
	</dict>
	<key>string-&gt;cptr</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>string</key>
			<string>a scheme string object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>returns string as a cptr object</string>
		</array>
		<key>returns</key>
		<string>cptr</string>
		<key>short</key>
		<string>(string-&gt;ctpr string)</string>
	</dict>
	<key>string-&gt;data</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>str</key>
			<string>string</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns string as an NSData object</string>
		</array>
		<key>returns</key>
		<string>objc</string>
		<key>short</key>
		<string>(string-&gt;data str)</string>
	</dict>
	<key>string-&gt;list</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>str</key>
			<string>string</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(string-&gt;list &quot;hello&quot;) =&gt; (104 101 108 108 111)</string>
		</array>
		<key>long</key>
		<array>
			<string>returns the list of characters that make up str</string>
		</array>
		<key>returns</key>
		<string>list</string>
		<key>short</key>
		<string>(string-&gt;list str)</string>
	</dict>
	<key>string-&gt;number</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>str</key>
			<string>string</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(string-&gt;number &quot;5.5&quot;) =&gt; 5.5</string>
		</array>
		<key>long</key>
		<array>
			<string>Return the number represented by str</string>
		</array>
		<key>returns</key>
		<string>number</string>
		<key>short</key>
		<string>(string-&gt;number str)</string>
	</dict>
	<key>string-&gt;sexpr</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>string</key>
			<string>a scheme string containing a valid scheme expression.</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns the scheme sexpr represeted by the given string.  You can then treat the sexpr just as any normal expression (i.e. eval it etc.).</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>scheme object</string>
		<key>short</key>
		<string>(string-&gt;sexpr string)</string>
	</dict>
	<key>string-&gt;symbol</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>str</key>
			<string>string</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(string-&gt;symbol &quot;hello&quot;) =&gt; hello</string>
		</array>
		<key>long</key>
		<array>
			<string>returns the symbol represented by str</string>
		</array>
		<key>returns</key>
		<string>symbol</string>
		<key>short</key>
		<string>(string-&gt;symbol str)</string>
	</dict>
	<key>string-append</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>strings</key>
			<string>any number of strings to append</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(string-append &quot;Impromptu is &quot; (number-&gt;string 1) &quot; year old!&quot;) =&gt; &quot;Impromptu is 1 year old!&quot;</string>
		</array>
		<key>long</key>
		<array>
			<string>Append strings to form one string</string>
		</array>
		<key>returns</key>
		<string>string</string>
		<key>short</key>
		<string>(string-append . strings)</string>
	</dict>
	<key>string-ci&lt;=?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For string-ci&lt;=?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(string-ci&lt;=?)</string>
	</dict>
	<key>string-ci&lt;?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For string-ci&lt;?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(string-ci&lt;?)</string>
	</dict>
	<key>string-ci=?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For string-ci=?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(string-ci=?)</string>
	</dict>
	<key>string-ci&gt;=?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For string-ci&gt;=?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(string-ci&gt;=?)</string>
	</dict>
	<key>string-ci&gt;?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For string-ci&gt;?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(string-ci&gt;?)</string>
	</dict>
	<key>string-cmp?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For string-cmp?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(string-cmp?)</string>
	</dict>
	<key>string-copy</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>str</key>
			<string>string</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns a new copy of str</string>
		</array>
		<key>returns</key>
		<string>string</string>
		<key>short</key>
		<string>(string-copy str)</string>
	</dict>
	<key>string-fill!</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>char</key>
			<string>character</string>
			<key>str</key>
			<string>string</string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Fills every element in str with char.  str must be a mutable str (i.e. not a literal)</string>
		</array>
		<key>related</key>
		<string>make-string</string>
		<key>returns</key>
		<string>string</string>
		<key>short</key>
		<string>(string-fill! str char)</string>
	</dict>
	<key>string-join</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>join</key>
			<string>join string</string>
			<key>str-list</key>
			<string>list of strings to join</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(string-join (list &quot;a&quot; &quot;b&quot; &quot;c&quot;) &quot;,&quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns a single string of strings (str-list) joined with (join)</string>
		</array>
		<key>returns</key>
		<string>sting</string>
		<key>short</key>
		<string>(string-join str-list join)</string>
	</dict>
	<key>string-length</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>str</key>
			<string>string</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(string-length &quot;hello&quot;) =&gt; 5</string>
		</array>
		<key>long</key>
		<array>
			<string>The number of chars that make up str</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(string-length str)</string>
	</dict>
	<key>string-ref</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>k</key>
			<string>index into str</string>
			<key>str</key>
			<string>string</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(string-ref &quot;hello&quot; 3) =&gt; 108</string>
		</array>
		<key>long</key>
		<array>
			<string>returns character at index k in str</string>
		</array>
		<key>returns</key>
		<string>character</string>
		<key>short</key>
		<string>(string-ref str k)</string>
	</dict>
	<key>string-replace</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>replace</key>
			<string>string</string>
			<key>str</key>
			<string>string</string>
			<key>with</key>
			<string>string</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(string-replace &quot;string in string&quot; &quot;string&quot; &quot;in&quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>returns the list of characters that make up str</string>
		</array>
		<key>returns</key>
		<string>string</string>
		<key>short</key>
		<string>(string-replace str replace with)</string>
	</dict>
	<key>string-set!</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>char</key>
			<string>char to insert at index</string>
			<key>k</key>
			<string>index into str</string>
			<key>str</key>
			<string>mutable string</string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Sets the character at index k in str to char. string must be mutable</string>
		</array>
		<key>related</key>
		<string>make-string</string>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(string-set! str k char)</string>
	</dict>
	<key>string-split</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>split</key>
			<string>string to split on</string>
			<key>str</key>
			<string>input string</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(string-split &quot;1,2,3,4,5&quot; &quot;,&quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns a list of strings based on split. The opposite of string-join</string>
		</array>
		<key>returns</key>
		<string>list</string>
		<key>short</key>
		<string>(string-split str split)</string>
	</dict>
	<key>string-strip</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>str</key>
			<string>input string</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(string-strip &quot;  a b c &quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>Removes all leading and trailing whitespace</string>
		</array>
		<key>returns</key>
		<string>string</string>
		<key>short</key>
		<string>(string-strip str)</string>
	</dict>
	<key>string&lt;=?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For string&lt;=?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(string&lt;=? a b)</string>
	</dict>
	<key>string&lt;?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For string&lt;?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(string&lt;? a b)</string>
	</dict>
	<key>string=?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For string=?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(string=? a b)</string>
	</dict>
	<key>string&gt;=?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For string&gt;=?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(string&gt;=? a b)</string>
	</dict>
	<key>string&gt;?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For string&gt;?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(string&gt;? a b)</string>
	</dict>
	<key>string?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Predicate check for string</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(string? obj)</string>
	</dict>
	<key>substring</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>end</key>
			<string>index for end of substring</string>
			<key>start</key>
			<string>index for start of substring</string>
			<key>str</key>
			<string>string</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(substring &quot;hello&quot; 2 4) =&gt; &quot;ll&quot;</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns the substring of str between indexs start and end</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(substring str start end)</string>
	</dict>
	<key>succ</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>num</key>
			<string>an integer to find the successor of</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;; 2
(succ 1)
;; 4
(succ (succ (succ 1)))</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns the successor of num (1 returns 2, 2 returns 3 etc.)</string>
		</array>
		<key>returns</key>
		<string>integer</string>
		<key>short</key>
		<string>(succ num)</string>
	</dict>
	<key>symbol-&gt;string</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>sym</key>
			<string>symbol</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns string representation of sym</string>
		</array>
		<key>returns</key>
		<string>string</string>
		<key>short</key>
		<string>(symbol-&gt;string sym)</string>
	</dict>
	<key>symbol?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Predicate check for symbol</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(symbol? obj)</string>
	</dict>
	<key>sys:clear-log-view</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>clears the log view</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(sys:clear-log-view)</string>
	</dict>
	<key>sys:livecoding-error-hook?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>bool</key>
			<string>#t of #f</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;; turn on livecoding error hook
(sys:livecoding-error-hook #t)

;; with livecoding-error-hook on   
;; this temporal recursion will continue
;; to play the second note even though &apos;pitch
;; is an unbound symbol
(define loop
   (lambda (beat) 
      ;; symbol a is not bound but loop continues to function
      (play piano pitch 80 1)
      (play piano 63 80 1)
      (callback (*metro* (+ beat (* 1/2 1))) &apos;loop (+ beat 1))))

(loop (*metro* &apos;get-beat 4))

;; by redefining the error hook we can provide
;; additional specialisation - such as replacing
;; any unbound symbol with 60!
;; 
;; eval below and both notes will play
;; &apos;pitch being replaced by 60
(define *livecoding-error-hook* 
   (lambda (msg a) 
      (cond ((symbol? a) 60)
            (else 0))))</string>
		</array>
		<key>long</key>
		<array>
			<string>Turns on error capture for livecoding performances</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(sys:livecoding-error-hook? bool)</string>
	</dict>
	<key>sys:clear-scheduler</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array>
			<string>(sys:clear-scheduler)</string>
		</array>
		<key>long</key>
		<array>
			<string>Remove all pending events from the scheduler queue</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(sys:clear-scheduler)</string>
	</dict>
	<key>sys:dynamic-call</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array>
			<string>(define a 1)

(define f1 
   (lambda (str)
      (print &apos;f1 str a)))

;; test f1
(f1 &quot;lexical&quot;)

(define f2
   (lambda (str)
      (print &apos;f2 str a b)))

;; testing f2 will fail - unbound variable b
(f2 &quot;lexical&quot;)

(define f3
   (lambda (a)
      (let ((b 3))
         (sys:dynamic-call f1 &quot;dynamic&quot;)
         (f1 &quot;lexical&quot;)
         (sys:dynamic-call f2 &quot;dynamic&quot;))))         

(f3 2)</string>
		</array>
		<key>long</key>
		<array>
			<string>Operates like apply but imposes the current environment dynamically.  This is as opposed to the lexical context usually used.  See examples.</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>objc</string>
		<key>short</key>
		<string>(sys:dynamic-call closure . args)</string>
	</dict>
	<key>sys:gc</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For gc</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gc)</string>
	</dict>
	<key>sys:gc-verbose</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For gc-verbose</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(gc-verbose)</string>
	</dict>
	<key>sys:get-documentation-dictionary</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns the documentation dictionary as an NSMutableDictionary allowing users to add documentation for functions in their libraries</string>
		</array>
		<key>related</key>
		<string>ipc:define ipc:new-process</string>
		<key>returns</key>
		<string>objc</string>
		<key>short</key>
		<string>(sys:get-documentation-dictionary</string>
	</dict>
	<key>sys:get-string-from-message-bar</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns the current value of the text editors message bar as a scheme string</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>string</string>
		<key>short</key>
		<string>(sys:get-string-from-message-bar)</string>
	</dict>
	<key>sys:get-text-buffer</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>buffer</key>
			<string>which buffer number to get (0 is the first buffer)</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>returns a string representation of the NSTextStorage which backs the impromptu buffer</string>
		</array>
		<key>returns</key>
		<string>NSString</string>
		<key>short</key>
		<string>(sys:get-text-buffer buffer)</string>
	</dict>
	<key>sys:hostname</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>returns the hostname of the machine - be aware that this function blocks and can take a while to resolve the hostname</string>
		</array>
		<key>returns</key>
		<string>string</string>
		<key>short</key>
		<string>(sys:hostname)</string>
	</dict>
	<key>sys:impromptu-help</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>directory</key>
			<string>optionally provide a directory to write an html copy to</string>
			<key>examples</key>
			<string>optionally print examples</string>
			<key>symbol</key>
			<string>the symbol to print help on</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Prints help on symbol to the log view.  optionally include examples and optionally write an html version to directory</string>
		</array>
		<key>related</key>
		<string></string>
		<key>returns</key>
		<string>image</string>
		<key>short</key>
		<string>(sys:impromptu-help symbol [examples] [directory])</string>
	</dict>
	<key>sys:new-segment</key>
	<dict>
		<key>arguments</key>
		<dict/>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Assigns a new memory block to the GC</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(sys:new-segment)</string>
	</dict>
	<key>sys:register-for-eval-callbacks</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>function-name</key>
			<string>the string name of a function to callback to</string>
			<key>process-name</key>
			<string>the process name to callback into</string>
		</dict>
		<key>examples</key>
		<array>
			<string>;; echo all evaluations to the utility process
;; and to a log file with a timestamp
;; 
;; note that we could ipc:eval-string in any process
;; so you could have a synchronous session running 
;; across two machines by using a remote process!!

(define *logfile* (open-output-file &quot;/tmp/expr.log&quot;))

(define my-eval-echo
   (lambda (expr)
      (write (cons (now) expr) *logfile*)))
      (ipc:eval-string &quot;utility process&quot; expr)))

;; register my-eval-echo to start receiving
;; evals from the text editor
(sys:register-for-eval-callbacks &quot;my-eval-echo&quot; &quot;primary process&quot;)

;; let&apos;s eval some stuff then
(define frank 48)
(define james 52)
(define henry 32)

;; eval this and you should see two prints to the log
;; one from the primary process
;; one from the utility process
;; note that frank james and henry have been
;; defined properly in 
;; both &quot;primary process&quot; and &quot;utility process&quot;
(print (ipc:get-process-name) james henry frank)

;; when done with file close port
(close-port *logfile*)


;; at a future time you could then &quot;playback&quot; the log
;; by doing something like this
(define playback   
   (lambda (*log* offset)
      (let ((entry (read *log*)))
         (if (eof-object? entry) (close-port *log*)
             (let ((time (- (car entry) offset))
                   (expr (cdr entry)))
                (if (= offset 0) (begin (set! offset (- time (now)))
                                        (set! time (- time offset))))
                (sys:wait time)
                (print (now) &apos;evaluating expr &apos;at time)
                (ipc:eval-string &quot;primary process&quot; expr)
                (playback *log* offset))))))

;; clear au graph and log before starting
(begin (au:clear-graph)
       (sys:clear-log-view)
       (playback (open-input-file &quot;/tmp/expr.log&quot;) 0))</string>
		</array>
		<key>long</key>
		<array>
			<string>register to start receiving a callback whenever a scheme expression is evaluated.  You must build a function that takes a single string argument in the process that you want to receive eval notifications in.  Then specify the function name (as a string) and a process name to callback into.  A single string argument containing the expression is passed to your function each time an expression is evaluated.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(sys:register-for-eval-callbacks function-name process-name)</string>
	</dict>
	<key>sys:run-applescript</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>string</key>
			<string>the applescript to compile and run provided as a string</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>executes the apple script provided in string. returns an NSAppleEventDescriptor on success or #f on fail</string>
		</array>
		<key>returns</key>
		<string>NSAppleEventDescriptor on success or #f on fail</string>
		<key>short</key>
		<string>(sys:run-applescript string)</string>
	</dict>
	<key>sys:set-global-time</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>time</key>
			<string>time to set global clock too</string>
		</dict>
		<key>examples</key>
		<array>
			<string>; reset clock to time 0</string>
			<string>(set-global-time 0)</string>
		</array>
		<key>long</key>
		<array>
			<string>Sets the global clock to time in samples. combine this with OSC to create a basic network time protocol.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(sys:set-global-time time)</string>
	</dict>
	<key>sys:set-pasteboard</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>string</key>
			<string>string can be either a scheme string or NSString</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Adds string to the pasteboard. (i.e. you can paste from the pasteboard back into the editor)</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(sys:set-pasteboard string)</string>
	</dict>
	<key>sys:set-text-buffer</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>buffer</key>
			<string>which buffer number to edit (0 is the first buffer)</string>
			<key>length</key>
			<string>how much text should we overwrite with string (location+length):  if no location is provided then length defaults to the end of the text buffer (i.e. all text) - if a location is provided then length defaults to 0 (i.e. just insert)</string>
			<key>location</key>
			<string>character location in buffer to add text.  default location is 0 (start of text buffer)</string>
			<key>string</key>
			<string>string to add to text buffer</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>inserts text in the given text buffer.  The text buffer number must always be provide along with a string to insert.  If no other arguments are provided then the string will replace the entire buffer.  If just a location is provided the string will be inserted at the location.  If a location and a length is provide then string will overwrite the at location+length</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(sys:set-text-buffer buffer [location] [length] string)</string>
	</dict>
	<key>sys:sleep</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>sleep-time</key>
			<string>how many samples to sleep for</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>A synchronous sleep.  Sleeps for sleep-time samples. A sleep-time of 0 (i.e. no sleep) will still force a context switch (i.e. allow another task to run) so is useful as a yield in long running functions.  WARNING: you cannot use sys:sleep at the top-level - it must be in some context (even if just a begin)</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(sys:sleep sleep-time)</string>
	</dict>
	<key>sys:task-queue-logging</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>boolean</key>
			<string>#t or #f</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Turn on/off task-queue-logging</string>
		</array>
		<key>returns</key>
		<string>number</string>
		<key>short</key>
		<string>(sys:task-queue-logging boolean)</string>
	</dict>
	<key>sys:verbose-error-logging</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>boolean</key>
			<string>#t or #f</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Turn on/off verbose error logging</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(sys:verbose-error-logging boolean)</string>
	</dict>
	<key>sys:wait</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>until-time</key>
			<string>the time in samples to wake up</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>A synchronous wait akin to a sleep.  Sleeps until time has been reached. A time of (now) (i.e. no sleep) will still force a context switch (i.e. allow another task to run) so is useful as a yield in long running functions. WARNING: you cannot use sys:wait at the top-level - it must be in some context (even if just a begin)</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(sys:wait until-time)</string>
	</dict>
	<key>sys:write-log-view</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>path</key>
			<string>string path to file</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Writes the current contents of the log view to fully qualified path to file</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(sys:write-log-view path)</string>
	</dict>
	<key>tail</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>No Description For tail</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(tail stream)</string>
	</dict>
	<key>tan</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>num</key>
			<string>number</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Return the tan of num</string>
		</array>
		<key>returns</key>
		<string>number</string>
		<key>short</key>
		<string>(tan num)</string>
	</dict>
	<key>tanr</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>centre</key>
			<string>the centre point of your oscillation</string>
			<key>cycle</key>
			<string>the cycle of the oscillation</string>
			<key>range</key>
			<string>the amplitude of your oscillation</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>tangent around centre with range and cycles per beat (requires beat variable to be present in environment). requires a metronome called *metro* to be bound in the environment</string>
		</array>
		<key>returns</key>
		<string>number</string>
		<key>short</key>
		<string>(tanr centre range cycle)</string>
	</dict>
	<key>throw</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>str</key>
			<string>optional error message for use if thrown outside a catch</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define myfunc</string>
			<string>   (lambda (x)</string>
			<string>      (if (negative? x) (throw) x)))</string>
			<string></string>
			<string>(catch (print-error &quot;Negatives Not Allowed&quot;)</string>
			<string>       (print &quot;Try 5&quot;)</string>
			<string>       (print (myfunc 5))</string>
			<string>       (print &quot;Try -5&quot;)</string>
			<string>       (print (myfunc -5)))	</string>
		</array>
		<key>long</key>
		<array>
			<string>Throws an exception</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(throw [str])</string>
	</dict>
	<key>tracing</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key></key>
			<string></string>
		</dict>
		<key>examples</key>
		<array>
			<string></string>
		</array>
		<key>long</key>
		<array>
			<string>Tracing is currently disabled</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(tracing)</string>
	</dict>
	<key>truncate</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>num</key>
			<string>number</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Truncate num</string>
		</array>
		<key>returns</key>
		<string>number</string>
		<key>short</key>
		<string>(truncate num)</string>
	</dict>
	<key>vector</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>objs</key>
			<string>any number of scheme objects</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(vector &apos;a 5.5 &quot;string&quot;) =&gt; #(a 5.5 &quot;string&quot;)</string>
		</array>
		<key>long</key>
		<array>
			<string>Create vector whose elements are the arguments objs</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(vector . objs)</string>
	</dict>
	<key>vector-&gt;list</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>v</key>
			<string>vector</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(vector-&gt;list (vector &apos;a &apos;b &apos;c)) =&gt; (a b c)</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns a list made up with the elements of v</string>
		</array>
		<key>returns</key>
		<string>list</string>
		<key>short</key>
		<string>(vector-&gt;list v)</string>
	</dict>
	<key>vector-equal?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>v1</key>
			<string>vector</string>
			<key>v2</key>
			<string>vector</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Are two vectors equal.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(vector-equal? v1 v2)</string>
	</dict>
	<key>vector-fill!</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>fill</key>
			<string>scheme object</string>
			<key>v</key>
			<string>vector</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Stores fill in every element of vector.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(vector-fill! v fill)</string>
	</dict>
	<key>vector-length</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>v</key>
			<string>vector</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Returns the number of elements in v</string>
		</array>
		<key>returns</key>
		<string>integer</string>
		<key>short</key>
		<string>(vector-length v)</string>
	</dict>
	<key>vector-recycle</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>bool</key>
			<string>boolean</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(vector-recycle #t)</string>
		</array>
		<key>long</key>
		<array>
			<string>If set to true vector recycle will reuse vector cells instead of reassigning new ones which need to be garbage collected.  don&apos;t use this unless you know what you&apos;re doing!</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(vector-recycle bool)</string>
	</dict>
	<key>vector-ref</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>k</key>
			<string>index into vector</string>
			<key>v</key>
			<string>vector</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(vector-ref (vector &apos;a &apos;b &apos;c) 1)  =&gt; b</string>
		</array>
		<key>long</key>
		<array>
			<string>Returns the kth element of v</string>
		</array>
		<key>returns</key>
		<string>object</string>
		<key>short</key>
		<string>(vector-ref v k)</string>
	</dict>
	<key>vector-set!</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>k</key>
			<string>index into vector</string>
			<key>obj</key>
			<string>object to set at k</string>
			<key>v</key>
			<string>vector</string>
		</dict>
		<key>examples</key>
		<array>
			<string>(define v1 (vector 1 2 3 4 5))</string>
			<string>(vector-set! v1 2 &apos;hello)</string>
			<string>(print v1)</string>
		</array>
		<key>long</key>
		<array>
			<string>Sets element k of v to obj.  make sure that v is not literal</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(vector-set! v k obj)</string>
	</dict>
	<key>vector?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>object</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Predicate check for vector</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(vector? obj)</string>
	</dict>
	<key>with-input-from-file</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>str</key>
			<string></string>
			<key>thunk</key>
			<string></string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>String should be a string naming a file, and proc should be a procedure of no arguments. For with-input-from-file, the file should already exist; for with-output-to-file, the effect is unspecified if the file already exists. The file is opened for input or output, an input or output port connected to it is made the default value returned by current-input-port or current-output-port (and is used by (read), (write obj), and so forth), and the thunk is called with no arguments. When the thunk returns, the port is closed and the previous default is restored. With-input-from-file and with-output-to-file return(s) the value(s) yielded by thunk. If an escape procedure is used to escape from the continuation of these procedures, their behavior is implementation dependent.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(with-input-from-file str thunk)</string>
	</dict>
	<key>with-input-output-from-to-files</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>str</key>
			<string></string>
			<key>thunk</key>
			<string></string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>String should be a string naming a file, and proc should be a procedure of no arguments. For with-input-from-file, the file should already exist; for with-output-to-file, the effect is unspecified if the file already exists. The file is opened for input or output, an input or output port connected to it is made the default value returned by current-input-port or current-output-port (and is used by (read), (write obj), and so forth), and the thunk is called with no arguments. When the thunk returns, the port is closed and the previous default is restored. With-input-from-file and with-output-to-file return(s) the value(s) yielded by thunk. If an escape procedure is used to escape from the continuation of these procedures, their behavior is implementation dependent.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(with-input-output-from-to-files str thunk)</string>
	</dict>
	<key>with-output-to-file</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>str</key>
			<string></string>
			<key>thunk</key>
			<string></string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>String should be a string naming a file, and proc should be a procedure of no arguments. For with-input-from-file, the file should already exist; for with-output-to-file, the effect is unspecified if the file already exists. The file is opened for input or output, an input or output port connected to it is made the default value returned by current-input-port or current-output-port (and is used by (read), (write obj), and so forth), and the thunk is called with no arguments. When the thunk returns, the port is closed and the previous default is restored. With-input-from-file and with-output-to-file return(s) the value(s) yielded by thunk. If an escape procedure is used to escape from the continuation of these procedures, their behavior is implementation dependent.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(with-output-to-file str thunk)</string>
	</dict>
	<key>write</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>obj</key>
			<string>object</string>
			<key>port</key>
			<string>optional port argument</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Writes a written representation of obj to the given port. Strings that appear in the written representation are enclosed in doublequotes, and within those strings backslash and doublequote characters are escaped by backslashes. Character objects are written using the #\ notation. Write returns an unspecified value. The port argument may be omitted, in which case it defaults to the value returned by current-output-port</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(write obj [port])</string>
	</dict>
	<key>write-char</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>char</key>
			<string>character</string>
			<key>port</key>
			<string>optional port argument</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Writes the character char (not an external representation of the character) to the given port and returns an unspecified value. The port argument may be omitted, in which case it defaults to the value returned by current-output-port.</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(write-char char [port])</string>
	</dict>
	<key>zero?</key>
	<dict>
		<key>arguments</key>
		<dict>
			<key>num</key>
			<string>number</string>
		</dict>
		<key>examples</key>
		<array/>
		<key>long</key>
		<array>
			<string>Predicate to check number for zero?</string>
		</array>
		<key>returns</key>
		<string>boolean</string>
		<key>short</key>
		<string>(zero? num)</string>
	</dict>
</dict>
</plist>
